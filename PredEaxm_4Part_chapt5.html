<html lang="ko" style="" class="cssscrollbar Desktop PC zoom object-fit gteIE9orSUA Chrome width-large lt-width-xlarge"><head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>예상문제 </title>
<style>
/* AUTO:exam-ui start */
/* 클릭 가능 UX */
a.b2.help,
.cp1question1 .lst1 .li1,
.cp1question1 .lst1 .li1 a {
  cursor: pointer;
}
/* hover (navy) */
.cp1question1 .lst1 .li1:hover {
  background: rgba(31, 42, 68, 0.06);
}
/* 선택 표시 (navy) */
.cp1question1 .lst1 .li1.is-selected {
  background: rgba(31, 42, 68, 0.12);
  border-radius: 6px;
}
.cp1question1 .lst1 .li1.is-selected .t1 {
  font-weight: 600;
  color: #2980b9; /* 딥 블루 */
}
/* 정답 (navy) */
.cp1question1 .lst1 .li1.is-correct {
  background: rgba(52, 152, 219, 0.18); /* 라이트 블루 */
  border-radius: 6px;
}
.cp1question1 .lst1 .li1.is-correct .t1 {
  font-weight: 700;
  color: #2980b9; /* 딥 블루 */
}
/* 오답 */
.cp1question1 .lst1 .li1.is-wrong {
  background: rgba(160, 30, 30, 0.12);
  border-radius: 6px;
}
.cp1question1 .lst1 .li1.is-wrong .t1 {
  font-weight: 600;
  color: #7a1f1f;
}
/* 보기 버튼 (navy) */
a.b2.help {
  color: #2980b9; /* 딥 블루 */
}
a.b2.help.on {
  font-weight: 600;
}
/* AUTO:exam-ui end */


/* AUTO:clickable-ui start */
a.b2.help,
.cp1question1 .lst1 .li1,
.cp1question1 .lst1 .li1 a {
  cursor: pointer;
}
.cp1question1 .lst1 .li1:hover {
  background: rgba(0, 0, 0, 0.04);
}
a.b2.help:hover {
  opacity: 0.85;
}
/* AUTO:clickable-ui end */
/* AUTO:mobile-scroll-fix start */
html {
  scroll-behavior: smooth;
}
.container {
  max-width: 600px;
  width: 100%;
  margin: 0 auto;
}
/* AUTO:mobile-scroll-fix end */
body {width:100%;}
	.eg1 {padding:10px 0px; text-align:center;width:100%;}
	.tg2 {border-bottom:1px solid #ddd;padding:5% 5%;display:none}
	.cp1question1 {padding-bottom:12px;}
	img {
	  width: 100%;
	  height: 100%;
	  object-fit: contain; /* 또는 cover */
	}
h2 a {
  font-size: 16px;        /* 글씨 크기 */
  text-decoration: none;  /* 밑줄 제거 */
  color: #333;            /* 기본 글자 색 */
  font-weight: 500;       /* 약간 두껍게 */
  transition: color 0.3s ease; /* hover 시 부드럽게 색 변화 */
}
h2 a:hover {
  color: #007acc;         /* hover 시 포인트 색 */
}

/* AUTO:cp1dlist2-style start */
.cp1dlist2 {
  display: flex;
  justify-content: flex-end;
  background-color: #f0f0f0;
  border-radius: 12px;
  padding: 10px 15px;
}

.cp1dlist2 ul {
  list-style: none;
  margin: 0;
  padding: 0;
  display: flex;
  gap: 10px;
}

.em2 {
  color: #d63031;
}
/* AUTO:cp1dlist2-style end */

</style>
</head>
<body>
<div class="container clearfix">
<div id="body" tabindex="-1">
<!-- container -->
<div class="container clearfix">
<!-- #forPrint -->
<div id="forPrint">
<!-- _content -->
<div id="body_content">
<h2><a href="./index.html"> &lt; 돌아가기</a>

<span class="all-controls" style="margin-left: 15px; vertical-align: middle;">
    <button type="button" onclick="window.controlAllAnswers(true)" style="padding: 6px 12px; background-color: #2c3e50; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 13px; font-weight: bold;">전체 정답 보기</button>
    <button type="button" onclick="window.controlAllAnswers(false)" style="padding: 6px 12px; background-color: #95a5a6; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 13px; font-weight: bold; margin-left: 5px;">전체 가리기</button>
</span></h2>
<!-- container -->
<div class="container clearfix">
<!-- cp1dlist2 -->
<div class="cp1dlist2">
<ul class="dl1">
<li class="di1">
<a class="a1">
<b class="dt1">총 문제</b>
<span class="dd1">63개</span>
</a>
</li>
<li class="di1">
<a class="a1">
<b class="dt1">맞춘 문제</b>
<span class="dd1"><b class="em1">0개</b></span>
</a>
</li>
<li class="di1">
<a class="a1">
<b class="dt1">틀린 문제</b>
<span class="dd1"><b class="em2">0개</b></span>
</a>
</li>
<li class="di1">
<a class="a1">
<b class="dt1">안 푼 문제</b>
<span class="dd1"><b class="em3">63개</b></span>
</a>
</li>
</ul>
</div>
<!-- /cp1dlist2 -->
<h3 class="hb1 h3">5장 - 데이터 마이닝</h3>
<!-- cp1question1 -->
<div class="cp1question1">
<div class="sg1">
<div class="w1">
<span class="g1">4과목</span>
<span class="g1">데이터 마이닝 개요</span>
<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
</div>
</div>
<div class="tg1">
<strong class="tt1">
<span class="tt1n">1.</span>
<span class="tt1t1">
				다음 중 대용량 데이터 속에서 숨겨진 지식 또는 새로운 규칙을 추출해 내는 과정을 일컫는 것은?							</span>
</strong>
<span class="tt1t1">
</span>
</div>
<ol class="lst1">
<li class="li1"><a class="a1"><span class="t1">
			지식경영					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			의사결정지원시스템					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			데이터웨어하우징					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			데이터마이닝					</span></a></li>
</ol>
<div class="eg1">
<a class="b2 help" href="#m-help1a1" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
<span class="t1">정답보기</span>
<i class="ic1"></i>
</a>
</div>
<div class="tg2 loaded" id="m-help1a1" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
<strong class="tt1">정답</strong>
<div class="t2">
<i class="t2n">4</i>
<span class="t2t1">
			데이터마이닝			</span>
</div>
<br/>
<strong class="tt1">해설</strong>
<div class="t1">
		데이터 마이닝은 대용량 데이터에서 의미있는 패턴을 파악하거나 예측하여 의사결정에 활용하는 방법이다.				</div>


<div class="more-c">
<strong class="tt1">비기봇 해설</strong>
<div class="t1">
				정답은 4번입니다.<br/>
<br/>
문제는 대용량 데이터에서 숨겨진 지식이나 새로운 규칙을 추출하는 과정을 묻고 있습니다. 이는 데이터 분석의 한 분야로, 다양한 기법을 통해 데이터에서 유의미한 정보를 찾아내는 것을 목표로 합니다.<br/>
<br/>
1. 지식경영<br/>
: 지식경영은 조직 내 지식을 체계적으로 관리하고 활용하여 경쟁력을 높이는 경영 전략입니다. 데이터 분석과는 다소 다른 개념입니다.<br/>
<br/>
2. 의사결정지원시스템<br/>
: 의사결정지원시스템은 의사결정을 돕기 위해 데이터를 분석하고 정보를 제공하는 시스템입니다. 데이터에서 직접 지식을 추출하는 과정과는 차이가 있습니다.<br/>
<br/>
3. 데이터웨어하우징<br/>
: 데이터웨어하우징은 대량의 데이터를 저장하고 관리하는 시스템으로, 데이터의 저장과 관리에 중점을 둡니다. 데이터에서 지식을 추출하는 과정과는 다릅니다.<br/>
<br/>
4. 데이터마이닝<br/>
: 데이터마이닝은 대용량 데이터에서 패턴이나 규칙을 찾아내는 과정으로, 문제에서 묻는 '숨겨진 지식 또는 새로운 규칙을 추출해 내는 과정'에 해당합니다.<br/>
<br/>
<br/>
데이터마이닝은 대용량 데이터에서 유의미한 패턴이나 규칙을 찾아내는 과정으로, 문제에서 묻는 '숨겨진 지식 또는 새로운 규칙을 추출해 내는 과정'에 정확히 부합합니다. 다른 선택지들은 데이터 관리나 의사결정 지원과 관련이 있지만, 직접적으로 지식을 추출하는 과정은 아닙니다.<br/>
<br/>
따라서, 정답은 '4. 데이터마이닝' 입니다.<br/>
</div>
<div class="t2">
									#데이터마이닝									# 대용량 데이터									# 지식 추출									# 규칙 발견							</div>
</div>

</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
<div class="sg1">
<div class="w1">
<span class="g1">4과목</span>
<span class="g1">데이터 마이닝 개요</span>
<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
</div>
</div>
<div class="tg1">
<strong class="tt1">
<span class="tt1n">2.</span>
<span class="tt1t1">
				다음 중 반응 변수가 범주형인 경우 예측모형의 주목적으로 가장 적절한 것은?							</span>
</strong>
<span class="tt1t1">
</span>
</div>
<ol class="lst1">
<li class="li1"><a class="a1"><span class="t1">
			연관 분석					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			분류					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			시뮬레이션					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			최적화					</span></a></li>
</ol>
<div class="eg1">
<a class="b2 help" href="#m-help1a2" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
<span class="t1">정답보기</span>
<i class="ic1"></i>
</a>
</div>
<div class="tg2 loaded" id="m-help1a2" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
<strong class="tt1">정답</strong>
<div class="t2">
<i class="t2n">2</i>
<span class="t2t1">
			분류			</span>
</div>
<br/>
<strong class="tt1">해설</strong>
<div class="t1">
		반응변수가 범주형인 경우 예측모형의 주목적은 분류이다.				</div>


<div class="more-c">
<strong class="tt1">비기봇 해설</strong>
<div class="t1">
				정답은 2번입니다.<br/>
<br/>
반응 변수가 범주형인 경우, 예측 모형의 주목적은 주어진 데이터를 기반으로 범주를 예측하는 것입니다. 이는 주로 분류 문제로 다루어지며, 범주형 데이터의 특성상 각 데이터 포인트가 특정 범주에 속하는지를 예측하는 것이 중요합니다.<br/>
<br/>
1. 연관 분석<br/>
: 연관 분석은 주로 데이터 내의 항목 간의 관계를 찾는 데 사용되며, 범주형 반응 변수의 예측과는 직접적인 관련이 없습니다.<br/>
<br/>
2. 분류<br/>
: 분류는 범주형 반응 변수를 예측하는 데 가장 적합한 방법입니다. 이는 데이터를 특정 범주로 나누는 작업을 포함하며, 범주형 데이터의 특성에 맞는 예측 모형입니다.<br/>
<br/>
3. 시뮬레이션<br/>
: 시뮬레이션은 주로 시스템의 동작을 모방하여 결과를 예측하는 방법으로, 범주형 반응 변수의 예측과는 직접적인 관련이 없습니다.<br/>
<br/>
4. 최적화<br/>
: 최적화는 주어진 조건 하에서 최적의 해를 찾는 방법으로, 범주형 반응 변수의 예측과는 직접적인 관련이 없습니다.<br/>
<br/>
<br/>
범주형 반응 변수를 예측하는 데 가장 적합한 방법은 분류입니다. 이는 데이터를 특정 범주로 나누는 작업을 포함하며, 범주형 데이터의 특성에 맞는 예측 모형입니다. 다른 선택지들은 범주형 반응 변수의 예측과는 직접적인 관련이 없습니다.<br/>
<br/>
따라서, 정답은 '2. 분류' 입니다.<br/>
</div>
<div class="t2">
									#범주형 변수									# 예측 모형									# 분류									# 데이터 분석							</div>
</div>

</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
<div class="sg1">
<div class="w1">
<span class="g1">4과목</span>
<span class="g1">데이터 마이닝 개요</span>
<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
</div>
</div>
<div class="tg1">
<strong class="tt1">
<span class="tt1n">3.</span>
<span class="tt1t1">
				다음 데이터 마이닝의  대표적인 기능 중 이질적인 모집단을 세분화하는 기능으로 적절한 것은?							</span>
</strong>
<span class="tt1t1">
</span>
</div>
<ol class="lst1">
<li class="li1"><a class="a1"><span class="t1">
			분류분석					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			모수추정					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			군집분석					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			연관분석					</span></a></li>
</ol>
<div class="eg1">
<a class="b2 help" href="#m-help1a3" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
<span class="t1">정답보기</span>
<i class="ic1"></i>
</a>
</div>
<div class="tg2 loaded" id="m-help1a3" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
<strong class="tt1">정답</strong>
<div class="t2">
<i class="t2n">3</i>
<span class="t2t1">
			군집분석			</span>
</div>
<br/>
<strong class="tt1">해설</strong>
<div class="t1">
		군집분석은 각 객체의 유사성을 측정하여 유사성이 높은 대상 집단을 분류하고, 군집에 속한 객체들의 유사성과 서로 다른 군집에 속한 객체간의 상이성을 규명하는 분석 방법이다.				</div>


<div class="more-c">
<strong class="tt1">비기봇 해설</strong>
<div class="t1">
				정답은 3번입니다.<br/>
<br/>
데이터 마이닝의 주요 기능 중 하나는 데이터를 분석하여 유사한 특성을 가진 그룹으로 나누는 것입니다. 이는 데이터의 패턴을 이해하고, 데이터 내의 구조를 파악하는 데 도움을 줍니다.<br/>
<br/>
1. 분류분석<br/>
: 분류분석은 주어진 데이터에 대해 미리 정의된 클래스 레이블을 예측하는 데 사용됩니다. 이는 주로 지도 학습에 해당합니다.<br/>
<br/>
2. 모수추정<br/>
: 모수추정은 통계적 방법으로 모집단의 특성을 추정하는 과정입니다. 이는 데이터 마이닝의 세분화 기능과는 직접적인 관련이 없습니다.<br/>
<br/>
3. 군집분석<br/>
: 군집분석은 데이터 내의 유사한 특성을 가진 객체들을 그룹으로 묶는 비지도 학습 방법입니다. 이는 이질적인 모집단을 세분화하는 데 적합합니다.<br/>
<br/>
4. 연관분석<br/>
: 연관분석은 데이터 내의 항목 간의 관계를 발견하는 데 사용됩니다. 이는 주로 장바구니 분석과 같은 분야에서 사용됩니다.<br/>
<br/>
<br/>
군집분석은 데이터 마이닝에서 이질적인 모집단을 세분화하는 데 사용되는 대표적인 방법입니다. 이는 데이터 내의 유사한 특성을 가진 객체들을 그룹으로 묶어 구조를 파악하는 데 도움을 줍니다. 다른 선택지들은 각각의 목적과 사용 분야가 다르며, 이질적인 모집단을 세분화하는 기능과는 직접적인 관련이 없습니다.<br/>
<br/>
따라서, 정답은 '3. 군집분석' 입니다.<br/>
</div>
<div class="t2">
									#데이터 마이닝									# 군집분석									# 비지도 학습									# 세분화							</div>
</div>

</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
<div class="sg1">
<div class="w1">
<span class="g1">4과목</span>
<span class="g1">데이터 마이닝 개요</span>
<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
</div>
</div>
<div class="tg1">
<strong class="tt1">
<span class="tt1n">4.</span>
<span class="tt1t1">
				한 보험회사에서는 자사 고객의 보험갱신 여부를 고객의 인구통계학적 특성, 보험가입 채널, 상품 종류 등의 정보를 사용하여 예측하려고 한다. 다음 중 가장 적절한 분석 기법은 무엇인가? 							</span>
</strong>
<span class="tt1t1">
</span>
</div>
<ol class="lst1">
<li class="li1"><a class="a1"><span class="t1">
			시계열분석					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			랜덤포레스트					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			k-means 군집분석					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			주성분분석					</span></a></li>
</ol>
<div class="eg1">
<a class="b2 help" href="#m-help1a4" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
<span class="t1">정답보기</span>
<i class="ic1"></i>
</a>
</div>
<div class="tg2 loaded" id="m-help1a4" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
<strong class="tt1">정답</strong>
<div class="t2">
<i class="t2n">2</i>
<span class="t2t1">
			랜덤포레스트			</span>
</div>
<br/>
<strong class="tt1">해설</strong>
<div class="t1">
		랜덤포레스트 분석 기법은 데이터 마이닝 방법론의 앙상블 기법 중 하나로 분류분석 문제를 해결하기 위한 의사결정나무와 같은 방법론이지만 의사결정나무에서 나타나는 과대적합/과소적합의 문제를 해결할 수 있다.				</div>


<div class="more-c">
<strong class="tt1">비기봇 해설</strong>
<div class="t1">
				정답은 2번입니다.<br/>
<br/>
보험회사의 고객 보험갱신 여부를 예측하는 문제는 고객의 인구통계학적 특성, 보험가입 채널, 상품 종류 등의 다양한 변수를 고려하여 고객이 보험을 갱신할지 여부를 예측하는 문제입니다. 이는 분류 문제로, 고객의 특성을 기반으로 두 가지 범주(갱신 또는 비갱신) 중 하나를 예측하는 것입니다. 분류 문제에서는 주로 의사결정나무, 로지스틱 회귀, 랜덤포레스트와 같은 기법이 사용됩니다. 랜덤포레스트는 여러 개의 의사결정나무를 사용하여 예측의 정확성을 높이는 앙상블 기법으로, 다양한 변수와 복잡한 데이터 구조를 다룰 때 유용합니다.<br/>
<br/>
1. 시계열분석 <br/>
: 시계열분석은 시간의 흐름에 따라 변화하는 데이터를 분석하여 미래의 값을 예측하는 기법입니다. 주로 주식 시장 예측, 기후 변화 예측 등 시간에 따른 패턴을 분석할 때 사용됩니다. 보험갱신 여부는 시간의 흐름보다는 고객의 특성에 따라 결정되므로, 시계열분석은 적절하지 않습니다.<br/>
<br/>
2. 랜덤포레스트 <br/>
: 랜덤포레스트는 여러 개의 의사결정나무를 결합하여 예측의 정확성을 높이는 앙상블 기법입니다. 각 나무는 데이터의 무작위 샘플을 사용하여 학습하며, 최종 예측은 모든 나무의 예측을 종합하여 결정합니다. 이는 다양한 변수와 복잡한 데이터 구조를 다룰 때 유용하며, 고객의 보험갱신 여부를 예측하는 데 적합합니다.<br/>
<br/>
3. k-means 군집분석 <br/>
: k-means 군집분석은 데이터를 유사한 특성을 가진 그룹으로 나누는 비지도 학습 기법입니다. 이는 데이터의 구조를 이해하고 그룹을 식별하는 데 유용하지만, 특정 범주를 예측하는 데는 적합하지 않습니다. 따라서 보험갱신 여부를 예측하는 데는 부적절합니다.<br/>
<br/>
4. 주성분분석 <br/>
: 주성분분석(PCA)은 고차원의 데이터를 저차원으로 변환하여 데이터의 주요 패턴을 파악하는 데 사용됩니다. 이는 데이터의 차원을 줄이고 시각화하는 데 유용하지만, 직접적인 예측 문제를 해결하는 데는 적합하지 않습니다. 따라서 보험갱신 여부를 예측하는 데는 부적절합니다.<br/>
<br/>
보험갱신 여부를 예측하는 문제는 고객의 다양한 특성을 기반으로 두 가지 범주 중 하나를 예측하는 분류 문제입니다. 랜덤포레스트는 여러 개의 의사결정나무를 결합하여 예측의 정확성을 높이는 기법으로, 다양한 변수와 복잡한 데이터 구조를 다룰 때 유용합니다. 시계열분석은 시간의 흐름에 따른 예측에 적합하고, k-means 군집분석은 데이터를 그룹으로 나누는 데 사용되며, 주성분분석은 데이터의 차원을 줄이는 데 사용되므로, 이 문제에 적합하지 않습니다.<br/>
따라서, 정답은 '2. 랜덤포레스트' 입니다.<br/>
</div>
<div class="t2">
									#보험갱신									# 분류 문제									# 랜덤포레스트									# 의사결정나무									# 앙상블 기법							</div>
</div>

</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
<div class="sg1">
<div class="w1">
<span class="g1">4과목</span>
<span class="g1">데이터 마이닝 개요</span>
<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
</div>
</div>
<div class="tg1">
<strong class="tt1">
<span class="tt1n">5.</span>
<span class="tt1t1">
				데이터 마이닝 단계 중 모델링 목적에 따라 목적변수를 정리하고 필요한 데이터를 데이터 마이닝 소프트웨어에 적용할 수 있도록 준비하는 단계는? 							</span>
</strong>
<span class="tt1t1">
</span>
</div>
<ol class="lst1">
<li class="li1"><a class="a1"><span class="t1">
			데이터 마이닝 기법의 적용					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			목적 정의					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			데이터 가공					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			데이터 준비					</span></a></li>
</ol>
<div class="eg1">
<a class="b2 help" href="#m-help1a5" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
<span class="t1">정답보기</span>
<i class="ic1"></i>
</a>
</div>
<div class="tg2 loaded" id="m-help1a5" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
<strong class="tt1">정답</strong>
<div class="t2">
<i class="t2n">3</i>
<span class="t2t1">
			데이터 가공			</span>
</div>
<br/>
<strong class="tt1">해설</strong>
<div class="t1">
		데이터 가공 단계는 모델링 목적에 따라 목적변수를 정리하고 필요한 데이터를 데이터 마이닝 소프트웨어에 적용할 수 있도록 준비하는 단계이다.				</div>


<div class="more-c">
<strong class="tt1">비기봇 해설</strong>
<div class="t1">
				데이터 마이닝 단계 중 모델링 목적에 따라 목적변수를 정리하고 필요한 데이터를 데이터 마이닝 소프트웨어에 적용할 수 있도록 준비하는 단계는 '데이터 가공' 단계입니다.<br/>
<br/>
데이터 마이닝 프로세스는 일반적으로 다음과 같은 5단계로 구성됩니다:<br/>
<br/>
1. 목적 정의: 데이터 마이닝을 통해 달성하고자 하는 목적을 명확히 정의합니다.<br/>
<br/>
2. 데이터 준비: 모델링 단계에 앞서 데이터를 준비하는 단계입니다.<br/>
<br/>
3. 데이터 가공: 데이터 준비 단계에서 가공된 데이터를 분석에 적합한 형태로 변환합니다.<br/>
<br/>
4. 데이터 마이닝 기법 적용: 다양한 데이터 마이닝 기법을 적용하여 데이터에서 유의미한 패턴과 규칙을 발견합니다.<br/>
<br/>
5. 결과 평가 및 활용: 도출된 결과를 평가하고, 이를 실제 의사결정에 활용합니다.<br/>
<br/>
따라서 데이터 마이닝 단계 중 모델링 목적에 따라 목적변수를 정리하고 필요한 데이터를 데이터 마이닝 소프트웨어에 적용할 수 있도록 준비하는 단계는 '데이터 가공' 단계입니다.<br/>
</div>
<div class="t2">
									# 데이터 마이닝									# 목적 정의									# 데이터 가공									# 데이터 준비							</div>
</div>

</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
<div class="sg1">
<div class="w1">
<span class="g1">4과목</span>
<span class="g1">데이터 마이닝 개요</span>
<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
</div>
</div>
<div class="tg1">
<strong class="tt1">
<span class="tt1n">6.</span>
<span class="tt1t1">
				다음 중 분석기법의 활용 분야가 나머지와 다른 하나를 고르시오. 							</span>
</strong>
<span class="tt1t1">
</span>
</div>
<ol class="lst1">
<li class="li1"><a class="a1"><span class="t1">
			로지스틱 회귀분석					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			인공신경망					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			의사결정나무					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			SOM					</span></a></li>
</ol>
<div class="eg1">
<a class="b2 help" href="#m-help1a6" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
<span class="t1">정답보기</span>
<i class="ic1"></i>
</a>
</div>
<div class="tg2 loaded" id="m-help1a6" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
<strong class="tt1">정답</strong>
<div class="t2">
<i class="t2n">4</i>
<span class="t2t1">
			SOM			</span>
</div>
<br/>
<strong class="tt1">해설</strong>
<div class="t1">
		SOM은 비지도 학습에 해당하고 나머지 항목은 지도학습에 해당한다.				</div>


<div class="more-c">
<strong class="tt1">비기봇 해설</strong>
<div class="t1">
				정답은 4번입니다.<br/>
<br/>
이 문제는 다양한 분석 기법의 활용 분야를 이해하고, 그 중에서 다른 하나를 식별하는 능력을 평가합니다. 각 기법이 주로 사용되는 분야를 이해하는 것이 중요합니다.<br/>
<br/>
1. 로지스틱 회귀분석<br/>
: 로지스틱 회귀분석은 주로 이진 분류 문제에 사용되며, 결과가 두 가지 범주로 나뉘는 경우에 적합합니다.<br/>
<br/>
2. 인공신경망<br/>
: 인공신경망은 복잡한 패턴 인식과 예측 문제에 사용되며, 이미지나 음성 인식 등 다양한 분야에 활용됩니다.<br/>
<br/>
3. 의사결정나무<br/>
: 의사결정나무는 분류와 회귀 문제 모두에 사용되며, 데이터의 구조를 시각적으로 이해하는 데 유용합니다.<br/>
<br/>
4. SOM<br/>
: SOM(Self-Organizing Map)은 주로 데이터의 군집화와 시각화에 사용되며, 비지도 학습의 한 형태입니다.<br/>
<br/>
<br/>
SOM은 비지도 학습 기법으로, 주로 데이터의 군집화와 시각화에 사용됩니다. 반면, 나머지 세 기법은 지도 학습에 속하며, 주로 분류나 회귀 문제에 사용됩니다. 따라서 SOM이 다른 세 기법과 활용 분야가 다릅니다.<br/>
<br/>
따라서, 정답은 '4. SOM' 입니다.<br/>
</div>
<div class="t2">
									#로지스틱 회귀분석									# 인공신경망									# 의사결정나무									# SOM							</div>
</div>

</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
<div class="sg1">
<div class="w1">
<span class="g1">4과목</span>
<span class="g1">인공신경망분석</span>
<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
</div>
</div>
<div class="tg1">
<strong class="tt1">
<span class="tt1n">7.</span>
<span class="tt1t1">
				과대적합(Overfitting)은 통계나 기계학습의 모델에서 변수가 너무 많아 모델이 복잡하고 과대하게 학습될 때 주로 발생한다. 다음 중 과대 적합에 대한 설명으로 가장 부적절한 것은?							</span>
</strong>
<span class="tt1t1">
</span>
</div>
<ol class="lst1">
<li class="li1"><a class="a1"><span class="t1">
			생성된 모델이 훈련 데이터에 너무 최적화되어 학습하여 테스트 데이터의 작은 변화에 민감하게 반응하는 경우는 발생하지 않는다.					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			학습 데이터가 모집단의 특성을 충분히 설명하지 못할 때 자주 발생한다. 					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			변수가 너무 많아 모형이 복잡할 때 생긴다.					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			과대적합이 발생할 것으로 예상되면 학습을 종료하고 업데이트하는 과정을 반복해 과대적합을 방지할 수 있다. 					</span></a></li>
</ol>
<div class="eg1">
<a class="b2 help" href="#m-help1a7" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
<span class="t1">정답보기</span>
<i class="ic1"></i>
</a>
</div>
<div class="tg2 loaded" id="m-help1a7" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
<strong class="tt1">정답</strong>
<div class="t2">
<i class="t2n">1</i>
<span class="t2t1">
			생성된 모델이 훈련 데이터에 너무 최적화되어 학습하여 테스트 데이터의 작은 변화에 민감하게 반응하는 경우는 발생하지 않는다.			</span>
</div>
<br/>
<strong class="tt1">해설</strong>
<div class="t1">
		생성된 모델이 훈련 데이터에 최적화되어 있기 때문에 테스트 데이터의 작은 변화에 민감하게 반응한다.				</div>


<div class="more-c">
<strong class="tt1">비기봇 해설</strong>
<div class="t1">
				정답은 1번입니다.<br/>
<br/>
과대적합(Overfitting)은 모델이 학습 데이터에 너무 최적화되어, 학습 데이터에서는 높은 정확도를 보이지만 새로운 데이터나 테스트 데이터에서는 성능이 떨어지는 현상을 말합니다. 이는 모델이 학습 데이터의 노이즈까지 학습하여 일반화 능력이 떨어지기 때문입니다. 과대적합은 주로 모델의 복잡도가 높거나, 학습 데이터가 충분하지 않을 때 발생합니다. 이를 방지하기 위해서는 모델의 복잡도를 줄이거나, 더 많은 데이터를 수집하거나, 정규화 기법을 사용하는 등의 방법이 있습니다.<br/>
<br/>
1. 생성된 모델이 훈련 데이터에 너무 최적화되어 학습하여 테스트 데이터의 작은 변화에 민감하게 반응하는 경우는 발생하지 않는다. <br/>
: 과대적합은 모델이 훈련 데이터에 너무 최적화되어 테스트 데이터의 작은 변화에도 민감하게 반응하는 현상입니다. 따라서 선지 1의 설명은 과대적합의 특성을 잘못 설명하고 있습니다. 과대적합이 발생하면 테스트 데이터에 대한 일반화가 어려워져 작은 변화에도 성능이 크게 떨어질 수 있습니다.<br/>
<br/>
2. 학습 데이터가 모집단의 특성을 충분히 설명하지 못할 때 자주 발생한다. <br/>
: 학습 데이터가 모집단의 특성을 충분히 설명하지 못할 때 과대적합이 발생할 수 있습니다. 이는 모델이 학습 데이터의 노이즈를 학습하여 일반화 능력이 떨어지기 때문입니다. 따라서 선지 2는 과대적합의 발생 원인을 잘 설명하고 있습니다.<br/>
<br/>
3. 변수가 너무 많아 모형이 복잡할 때 생긴다. <br/>
: 과대적합은 변수가 너무 많아 모델이 복잡할 때 발생할 수 있습니다. 이는 모델이 학습 데이터에 과도하게 맞춰져 일반화 능력이 떨어지기 때문입니다. 따라서 선지 3은 과대적합의 발생 원인을 잘 설명하고 있습니다.<br/>
<br/>
4. 과대적합이 발생할 것으로 예상되면 학습을 종료하고 업데이트하는 과정을 반복해 과대적합을 방지할 수 있다. <br/>
: 과대적합이 예상되면 학습을 종료하고 업데이트하는 과정을 반복하는 것은 과대적합을 방지하는 방법 중 하나입니다. 이는 조기 종료(Early Stopping) 기법으로, 모델이 과대적합되기 전에 학습을 멈추는 방법입니다. 따라서 선지 4는 과대적합을 방지하는 방법을 잘 설명하고 있습니다.<br/>
<br/>
선지 1은 과대적합의 특성을 잘못 설명하고 있습니다. 과대적합은 모델이 훈련 데이터에 너무 최적화되어 테스트 데이터의 작은 변화에도 민감하게 반응하는 현상입니다. 나머지 선지들은 과대적합의 발생 원인이나 방지 방법을 잘 설명하고 있습니다.<br/>
따라서, 정답은 '1. 생성된 모델이 훈련 데이터에 너무 최적화되어 학습하여 테스트 데이터의 작은 변화에 민감하게 반응하는 경우는 발생하지 않는다.' 입니다.<br/>
</div>
<div class="t2">
									#과대적합									# 일반화									# 모델 복잡도									# 학습 데이터									# 테스트 데이터							</div>
</div>

</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
<div class="sg1">
<div class="w1">
<span class="g1">4과목</span>
<span class="g1">앙상블 기법</span>
<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
</div>
</div>
<div class="tg1">
<strong class="tt1">
<span class="tt1n">8.</span>
<span class="tt1t1">
				모형의 평가를 위해 관측치를 한번 이상 훈련용 자료로 사용하는 복원 추출법(Sampling with Replacement)에 기반하는 붓스트랩(Bootstrap) 기법에서 일반적으로 훈련용 자료의 선정을 d번 반복할 때 하나의 관측치가 선정되지 않을 확률은 <mjx-container class="MathJax CtxtMenu_Attached_0" ctxtmenu_counter="0" jax="CHTML" style="font-size: 107.5%; position: relative;" tabindex="0"><mjx-math aria-hidden="true" class="MJX-TEX"><mjx-mo class="mjx-n"><mjx-c class="mjx-c28"></mjx-c></mjx-mo><mjx-mn class="mjx-n"><mjx-c class="mjx-c31"></mjx-c></mjx-mn><mjx-mo class="mjx-n" space="3"><mjx-c class="mjx-c2212"></mjx-c></mjx-mo><mjx-mn class="mjx-n" space="3"><mjx-c class="mjx-c31"></mjx-c></mjx-mn><mjx-texatom texclass="ORD"><mjx-mo class="mjx-n"><mjx-c class="mjx-c2F"></mjx-c></mjx-mo></mjx-texatom><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D451 TEX-I"></mjx-c></mjx-mi><mjx-msup><mjx-mo class="mjx-n"><mjx-c class="mjx-c29"></mjx-c></mjx-mo><mjx-script style="vertical-align: 0.363em;"><mjx-mi class="mjx-i" size="s"><mjx-c class="mjx-c1D451 TEX-I"></mjx-c></mjx-mi></mjx-script></mjx-msup></mjx-math><mjx-assistive-mml display="inline" unselectable="on"><math xmlns="http://www.w3.org/1998/Math/MathML"><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><mn>1</mn><mrow data-mjx-texclass="ORD"><mo>/</mo></mrow><mi>d</mi><msup><mo stretchy="false">)</mo><mi>d</mi></msup></math></mjx-assistive-mml></mjx-container>이다. d가 충분히 크다고 가정 할 때 훈련용 집합으로 선정되지 않아 검증용 자료로 사용되는 관측치의 비율은?							</span>
</strong>
<span class="tt1t1">
</span>
</div>
<ol class="lst1">
<li class="li1"><a class="a1"><span class="t1">
			20.5%					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			28.8%					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			34.2%					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			36.8%					</span></a></li>
</ol>
<div class="eg1">
<a class="b2 help" href="#m-help1a8" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
<span class="t1">정답보기</span>
<i class="ic1"></i>
</a>
</div>
<div class="tg2 loaded" id="m-help1a8" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
<strong class="tt1">정답</strong>
<div class="t2">
<i class="t2n">4</i>
<span class="t2t1">
			36.8%			</span>
</div>
<br/>
<strong class="tt1">해설</strong>
<div class="t1">
		d가 충분히 크다고 가정할 때 훈련용 집합으로 선정되지 않아 검증용 자료로 사용되는 관측치의 비율은 <mjx-container class="MathJax CtxtMenu_Attached_0" ctxtmenu_counter="1" jax="CHTML" style="font-size: 113.1%; position: relative;" tabindex="0"><mjx-math aria-hidden="true" class="MJX-TEX"><mjx-texatom texclass="ORD"><mjx-mfrac><mjx-frac><mjx-num><mjx-nstrut></mjx-nstrut><mjx-mn class="mjx-n" size="s"><mjx-c class="mjx-c31"></mjx-c></mjx-mn></mjx-num><mjx-dbox><mjx-dtable><mjx-line></mjx-line><mjx-row><mjx-den><mjx-dstrut></mjx-dstrut><mjx-mi class="mjx-i" size="s"><mjx-c class="mjx-c1D452 TEX-I"></mjx-c></mjx-mi></mjx-den></mjx-row></mjx-dtable></mjx-dbox></mjx-frac></mjx-mfrac></mjx-texatom></mjx-math><mjx-assistive-mml display="inline" unselectable="on"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow data-mjx-texclass="ORD"><mfrac><mn>1</mn><mi>e</mi></mfrac></mrow></math></mjx-assistive-mml></mjx-container>=0.367879...이므로 36.8%이다.				</div>


<div class="more-c">
<strong class="tt1">비기봇 해설</strong>
<div class="t1">
				복원 추출법에서 한 관측치가 선정되지 않을 확률은 <mjx-container class="MathJax CtxtMenu_Attached_0" ctxtmenu_counter="2" jax="CHTML" style="font-size: 113.1%; position: relative;" tabindex="0"><mjx-math aria-hidden="true" class="MJX-TEX"><mjx-mo class="mjx-n"><mjx-c class="mjx-c28"></mjx-c></mjx-mo><mjx-mn class="mjx-n"><mjx-c class="mjx-c31"></mjx-c></mjx-mn><mjx-mo class="mjx-n" space="3"><mjx-c class="mjx-c2212"></mjx-c></mjx-mo><mjx-mn class="mjx-n" space="3"><mjx-c class="mjx-c31"></mjx-c></mjx-mn><mjx-texatom texclass="ORD"><mjx-mo class="mjx-n"><mjx-c class="mjx-c2F"></mjx-c></mjx-mo></mjx-texatom><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D451 TEX-I"></mjx-c></mjx-mi><mjx-msup><mjx-mo class="mjx-n"><mjx-c class="mjx-c29"></mjx-c></mjx-mo><mjx-script style="vertical-align: 0.363em;"><mjx-mi class="mjx-i" size="s"><mjx-c class="mjx-c1D451 TEX-I"></mjx-c></mjx-mi></mjx-script></mjx-msup></mjx-math><mjx-assistive-mml display="inline" unselectable="on"><math xmlns="http://www.w3.org/1998/Math/MathML"><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><mn>1</mn><mrow data-mjx-texclass="ORD"><mo>/</mo></mrow><mi>d</mi><msup><mo stretchy="false">)</mo><mi>d</mi></msup></math></mjx-assistive-mml></mjx-container>이다. d가 충분히 크다고 가정하면 이 식은 자연상수 e의 -1승, 즉 1/e로 수렴한다. 1/e는 약 0.368이므로, 훈련용 집합으로 선정되지 않아 검증용 자료로 사용되는 관측치의 비율은 약 36.80%이다.<br/>
<br/>
1. 20.50%: 이 값은 본 문제의 계산과 관련이 없습니다.<br/>
<br/>
2. 28.80%: 이 값은 본 문제의 계산과 관련이 없습니다.<br/>
<br/>
3. 34.20%: 이 값은 본 문제의 계산과 관련이 없습니다.<br/>
<br/>
4. 36.80%: 이 값은 <mjx-container class="MathJax CtxtMenu_Attached_0" ctxtmenu_counter="3" jax="CHTML" style="font-size: 113.1%; position: relative;" tabindex="0"><mjx-math aria-hidden="true" class="MJX-TEX"><mjx-mo class="mjx-n"><mjx-c class="mjx-c28"></mjx-c></mjx-mo><mjx-mn class="mjx-n"><mjx-c class="mjx-c31"></mjx-c></mjx-mn><mjx-mo class="mjx-n" space="3"><mjx-c class="mjx-c2212"></mjx-c></mjx-mo><mjx-mn class="mjx-n" space="3"><mjx-c class="mjx-c31"></mjx-c></mjx-mn><mjx-texatom texclass="ORD"><mjx-mo class="mjx-n"><mjx-c class="mjx-c2F"></mjx-c></mjx-mo></mjx-texatom><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D451 TEX-I"></mjx-c></mjx-mi><mjx-msup><mjx-mo class="mjx-n"><mjx-c class="mjx-c29"></mjx-c></mjx-mo><mjx-script style="vertical-align: 0.363em;"><mjx-mi class="mjx-i" size="s"><mjx-c class="mjx-c1D451 TEX-I"></mjx-c></mjx-mi></mjx-script></mjx-msup></mjx-math><mjx-assistive-mml display="inline" unselectable="on"><math xmlns="http://www.w3.org/1998/Math/MathML"><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><mn>1</mn><mrow data-mjx-texclass="ORD"><mo>/</mo></mrow><mi>d</mi><msup><mo stretchy="false">)</mo><mi>d</mi></msup></math></mjx-assistive-mml></mjx-container>이 1/e로 수렴하는 것을 통해 계산된 검증용 자료의 비율입니다.<br/>
</div>
<div class="t2">
									# 복원 추출법									# Sampling with Replacement									# 붓스트랩									# Bootstrap									# 훈련용 자료									# 검증용 자료									# 확률							</div>
</div>

</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
<div class="sg1">
<div class="w1">
<span class="g1">4과목</span>
<span class="g1">데이터 마이닝 개요</span>
<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
</div>
</div>
<div class="tg1">
<strong class="tt1">
<span class="tt1n">9.</span>
<span class="tt1t1">
				Hitters 데이터셋은 메이저리그에서 활약하는 322명의 선수에 대한 타자 기록으로 연봉을 비롯한 20개의 변수를 포함하고 있다. 아래는 모형적합에 앞서 데이터를 Train set과 Test set으로 분할하는 과정이다. 다음 중 아래에 대한 설명으로 가장 부적절한 것은?							</span>
</strong>
<span class="tt1t1">
<a class="p1" href="exam1view1img1.php?img=1575f58d-c4d2-d017-c029-6f3fa4c127e0.png" rel="noopener" target="_blank" title="새 창">
<img alt="문제에 포함된 이미지" src="https://www.dataedupt.kr/data/img/question/1575f58d-c4d2-d017-c029-6f3fa4c127e0.png"/>
</a>
</span>
</div>
<ol class="lst1">
<li class="li1"><a class="a1"><span class="t1">
			50:50으로 데이터를 분할하고 있다.					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			50%의 데이터(Train set)를 사용하여 모형을 학습하고 나머지 50%의 데이터(Test set)로 모형을 평가하기 위한 사전작업이다.					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			모형 학습과 평가를 동일한 데이터셋에 진행하면 모형이 과적합 될 수 있다.					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			일반적으로 Test set에 대한 모형평가 결과가 Train set에 대한 모형평가 결과보다 좋다.					</span></a></li>
</ol>
<div class="eg1">
<a class="b2 help" href="#m-help1a9" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
<span class="t1">정답보기</span>
<i class="ic1"></i>
</a>
</div>
<div class="tg2 loaded" id="m-help1a9" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
<strong class="tt1">정답</strong>
<div class="t2">
<i class="t2n">4</i>
<span class="t2t1">
			일반적으로 Test set에 대한 모형평가 결과가 Train set에 대한 모형평가 결과보다 좋다.			</span>
</div>
<br/>
<strong class="tt1">해설</strong>
<div class="t1">
		일반적으로 Test set에 대한 모형평가 결과가 Train set에 대한 모형평가 결과보다 좋게 나타나는지는 알 수 없다. 				</div>


<div class="more-c">
<strong class="tt1">비기봇 해설</strong>
<div class="t1">
				정답은 4번입니다.<br/>
<br/>
데이터를 Train set과 Test set으로 분할하는 것은 모델의 성능을 평가하기 위한 중요한 과정입니다. Train set은 모델을 학습시키는 데 사용되고, Test set은 학습된 모델의 일반화 성능을 평가하는 데 사용됩니다. 이 과정은 과적합을 방지하고 모델이 새로운 데이터에 대해 얼마나 잘 예측할 수 있는지를 확인하는 데 필수적입니다. 주어진 코드에서는 Hitters 데이터셋을 50:50으로 무작위로 분할하여 Train set과 Test set을 구성하고 있습니다.<br/>
<br/>
1. 50:50으로 데이터를 분할하고 있다. <br/>
: 데이터를 50:50으로 분할하는 것은 주어진 코드에서 명확히 나타나 있습니다. 'sample' 함수를 사용하여 데이터의 절반을 무작위로 선택하여 Train set으로 지정하고, 나머지를 Test set으로 지정합니다. 이는 데이터 분할의 일반적인 방법 중 하나입니다.<br/>
<br/>
2. 50%의 데이터(Train set)를 사용하여 모형을 학습하고 나머지 50%의 데이터(Test set)로 모형을 평가하기 위한 사전작업이다. <br/>
: Train set을 사용하여 모델을 학습하고, Test set을 사용하여 모델을 평가하는 것은 일반적인 머신러닝 워크플로우입니다. 이는 모델이 학습 데이터에 과적합되지 않고 새로운 데이터에 대해 잘 일반화할 수 있는지를 평가하는 데 필수적입니다.<br/>
<br/>
3. 모형 학습과 평가를 동일한 데이터셋에 진행하면 모형이 과적합 될 수 있다. <br/>
: 모델을 학습과 평가를 동일한 데이터셋에서 진행하면 과적합의 위험이 있습니다. 과적합은 모델이 학습 데이터에 너무 맞춰져서 새로운 데이터에 대한 예측 성능이 떨어지는 현상입니다. 따라서 Train set과 Test set을 분리하여 사용하는 것이 중요합니다.<br/>
<br/>
4. 일반적으로 Test set에 대한 모형평가 결과가 Train set에 대한 모형평가 결과보다 좋다. <br/>
: 일반적으로 Test set에 대한 모델 평가 결과가 Train set에 대한 결과보다 좋지 않습니다. 이는 모델이 학습 데이터에 최적화되어 있기 때문입니다. Test set은 모델이 보지 못한 데이터이므로, 일반적으로 성능이 떨어질 수 있습니다.<br/>
<br/>
선지 4는 일반적인 상황과 반대되는 설명을 하고 있습니다. 일반적으로 모델은 Train set에서 더 높은 성능을 보이며, Test set에서는 성능이 떨어질 수 있습니다. 이는 모델이 학습 데이터에 최적화되어 있기 때문입니다. 따라서 선지 4는 부적절한 설명입니다.<br/>
따라서, 정답은 '4. 일반적으로 Test set에 대한 모형평가 결과가 Train set에 대한 모형평가 결과보다 좋다.' 입니다.<br/>
</div>
<div class="t2">
									#데이터 분할									# Train set									# Test set									# 과적합									# 일반화 성능							</div>
</div>

</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
<div class="sg1">
<div class="w1">
<span class="g1">4과목</span>
<span class="g1">데이터 마이닝 개요</span>
<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
</div>
</div>
<div class="tg1">
<strong class="tt1">
<span class="tt1n">10.</span>
<span class="tt1t1">
				다음 중 기업이 보유하고 있는 거래 데이터, 고객 데이터 등과 기타 외부 데이터를 포함하는 모든 데이터를 기반으로 새로운 규칙 등을 발견하고 이를 실제 비즈니스 의사결정 등에 유용한 정보로 활용하고자 하는 일련의 작업을 무엇이라고 하는가?							</span>
</strong>
<span class="tt1t1">
</span>
</div>
<ol class="lst1">
<li class="li1"><a class="a1"><span class="t1">
			회귀분석					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			데이터마이닝					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			데이터웨어하우징					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			의사결정지원시스템					</span></a></li>
</ol>
<div class="eg1">
<a class="b2 help" href="#m-help1a10" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
<span class="t1">정답보기</span>
<i class="ic1"></i>
</a>
</div>
<div class="tg2 loaded" id="m-help1a10" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
<strong class="tt1">정답</strong>
<div class="t2">
<i class="t2n">2</i>
<span class="t2t1">
			데이터마이닝			</span>
</div>
<br/>
<strong class="tt1">해설</strong>
<div class="t1">
		데이터 마이닝은 대용량 데이터에서 의미있는 패턴을 파악하거나 예측하여 의사결정에 활용하는 방법이다.				</div>


<div class="more-c">
<strong class="tt1">비기봇 해설</strong>
<div class="t1">
				정답은 2번입니다.<br/>
<br/>
데이터마이닝은 기업이 보유한 다양한 데이터와 외부 데이터를 분석하여 새로운 패턴이나 규칙을 발견하고 이를 비즈니스 의사결정에 활용하는 과정입니다. 이는 대량의 데이터를 분석하여 '왜' 그러한 일이 발생하는지를 추적하고 문제를 도출하거나 재정의하는 상향식 접근법을 포함합니다. 데이터마이닝은 데이터 사이언스의 한 영역으로, 수학적 모델링, 머신러닝, 패턴 인식 등을 통해 데이터를 분석하고 유의미한 정보를 추출하는 것을 목표로 합니다.<br/>
<br/>
1. 회귀분석 <br/>
: 회귀분석은 주어진 데이터에서 변수들 간의 관계를 모델링하여 예측하는 통계적 방법입니다. 이는 주로 연속형 데이터의 예측에 사용되며, 데이터마이닝의 일부로 활용될 수 있지만, 문제에서 요구하는 모든 데이터를 기반으로 새로운 규칙을 발견하는 작업과는 다소 차이가 있습니다.<br/>
<br/>
2. 데이터마이닝 <br/>
: 데이터마이닝은 대량의 데이터에서 유의미한 패턴이나 규칙을 발견하는 과정으로, 기업의 비즈니스 의사결정에 활용할 수 있는 정보를 제공합니다. 이는 다양한 데이터 소스를 통합하여 분석하고, 새로운 인사이트를 도출하는 것을 목표로 하며, 문제에서 설명한 작업과 정확히 일치합니다.<br/>
<br/>
3. 데이터웨어하우징 <br/>
: 데이터웨어하우징은 대량의 데이터를 저장하고 관리하는 시스템으로, 데이터마이닝을 위한 기초 데이터를 제공하는 역할을 합니다. 그러나 데이터웨어하우징 자체가 새로운 규칙을 발견하거나 비즈니스 의사결정에 직접적으로 활용되는 것은 아닙니다.<br/>
<br/>
4. 의사결정지원시스템 <br/>
: 의사결정지원시스템(DSS)은 의사결정을 지원하기 위한 시스템으로, 데이터 분석 결과를 활용하여 의사결정을 돕습니다. 그러나 DSS는 데이터마이닝의 결과를 활용하는 시스템일 뿐, 직접적으로 데이터를 분석하여 새로운 규칙을 발견하는 과정은 아닙니다.<br/>
<br/>
정답은 '데이터마이닝'입니다. 데이터마이닝은 다양한 데이터 소스를 분석하여 새로운 규칙을 발견하고 이를 비즈니스 의사결정에 활용하는 과정으로, 문제에서 설명한 작업과 일치합니다. 회귀분석은 특정 변수 간의 관계를 모델링하는 방법이고, 데이터웨어하우징은 데이터를 저장하는 시스템이며, 의사결정지원시스템은 분석 결과를 활용하는 시스템으로, 직접적으로 데이터를 분석하여 규칙을 발견하는 과정은 아닙니다.<br/>
따라서, 정답은 '2. 데이터마이닝' 입니다.<br/>
</div>
<div class="t2">
									#데이터마이닝									# 비즈니스 의사결정									# 데이터 분석									# 패턴 발견									# 상향식 접근법							</div>
</div>

</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
<div class="sg1">
<div class="w1">
<span class="g1">4과목</span>
<span class="g1">분류분석</span>
<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
</div>
</div>
<div class="tg1">
<strong class="tt1">
<span class="tt1n">11.</span>
<span class="tt1t1">
				귀납적 추론을 기반으로 하는 의사결정나무모형은 실무적으로 가장 많이 사용되는 모델 중 하나이다. 다음 중 의사 결정나무모형에 대한 설명으로 부적절한 것은?  							</span>
</strong>
<span class="tt1t1">
</span>
</div>
<ol class="lst1">
<li class="li1"><a class="a1"><span class="t1">
			대표적인 적용 사례는 대출신용평가, 환자 증상 유추, 채무 불이행 가능성 예측 등이 있다. 					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			의사결정나무모형에는 ID3, C4.5, CA RT 등 여러 가지 알고리즘이 있는데, 핵심적인 공통 개념은 상향식 의사결정 흐름과 해시 탐색(Hash Search)기반의 구조를 가지고 있다는 것이다. 					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			과적합(Overfitting)의 문제를 해결하기 위해 가지치기 방법을 이용하여 트리를 조정하는 방법을 사용한다.					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			불순도 측도인 엔트로피 개념은 정보이론의 개념을 기반으로 하며, 그 의미는 여러 가지 임의의 사건이 모여있는 집합의 순수성(Purity) 또는 단일성(Homogeneity) 관점의 특성을 정량화해서 표현한 것이다.					</span></a></li>
</ol>
<div class="eg1">
<a class="b2 help" href="#m-help1a11" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
<span class="t1">정답보기</span>
<i class="ic1"></i>
</a>
</div>
<div class="tg2 loaded" id="m-help1a11" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
<strong class="tt1">정답</strong>
<div class="t2">
<i class="t2n">2</i>
<span class="t2t1">
			의사결정나무모형에는 ID3, C4.5, CA RT 등 여러 가지 알고리즘이 있는데, 핵심적인 공통 개념은 상향식 의사결정 흐름과 해시 탐색(Hash Search)기반의 구조를 가지고 있다는 것이다. 			</span>
</div>
<br/>
<strong class="tt1">해설</strong>
<div class="t1">
		의사결정나무모형에서 핵심적인 공통개념은 하향식 기법이 사용되며, 각 진행 단계에서는 주어진 데이터 집합을 가장 적합한 기준으로 분할하는 변수값이 선택된다.				</div>


<div class="more-c">
<strong class="tt1">비기봇 해설</strong>
<div class="t1">
				정답은 2번입니다.<br/>
<br/>
의사결정나무모형은 데이터의 특성을 기반으로 의사결정을 내리는 데 사용되는 모델로, 다양한 알고리즘을 통해 데이터를 분류하거나 예측하는 데 활용됩니다. 이 모델은 직관적이고 해석이 용이하여 실무에서 널리 사용됩니다.<br/>
<br/>
1. 대표적인 적용 사례는 대출신용평가, 환자 증상 유추, 채무 불이행 가능성 예측 등이 있다.<br/>
: 의사결정나무모형은 다양한 분야에서 활용되며, 특히 대출신용평가, 환자 증상 유추, 채무 불이행 가능성 예측 등에서 그 유용성이 입증되었습니다.<br/>
<br/>
2. 의사결정나무모형에는 ID3, C4.5, CA RT 등 여러 가지 알고리즘이 있는데, 핵심적인 공통 개념은 상향식 의사결정 흐름과 해시 탐색(Hash Search)기반의 구조를 가지고 있다는 것이다.<br/>
: 의사결정나무모형의 알고리즘에는 ID3, C4.5, CART 등이 있으며, 이들은 모두 상향식 의사결정 흐름을 따르지만 해시 탐색 기반의 구조를 가진다는 설명은 부적절합니다. 의사결정나무는 주로 분할 기준을 통해 데이터를 분류하는 방식입니다.<br/>
<br/>
3. 과적합(Overfitting)의 문제를 해결하기 위해 가지치기 방법을 이용하여 트리를 조정하는 방법을 사용한다.<br/>
: 과적합 문제를 해결하기 위해 가지치기 방법을 사용하여 트리의 복잡성을 줄이고 일반화 성능을 향상시킵니다.<br/>
<br/>
4. 불순도 측도인 엔트로피 개념은 정보이론의 개념을 기반으로 하며, 그 의미는 여러 가지 임의의 사건이 모여있는 집합의 순수성(Purity) 또는 단일성(Homogeneity) 관점의 특성을 정량화해서 표현한 것이다.<br/>
: 엔트로피는 정보이론에 기반한 개념으로, 데이터 집합의 불순도를 측정하여 의사결정나무의 분할 기준으로 사용됩니다.<br/>
<br/>
<br/>
의사결정나무모형의 알고리즘은 상향식 의사결정 흐름을 따르지만, 해시 탐색 기반의 구조를 가진다는 설명은 부적절합니다. 해시 탐색은 의사결정나무의 구조와 관련이 없습니다. 다른 선택지들은 의사결정나무모형의 특징과 활용에 대한 올바른 설명을 제공하고 있습니다.<br/>
<br/>
따라서, 정답은 '2. 의사결정나무모형에는 ID3, C4.5, CA RT 등 여러 가지 알고리즘이 있는데, 핵심적인 공통 개념은 상향식 의사결정 흐름과 해시 탐색(Hash Search)기반의 구조를 가지고 있다는 것이다.' 입니다.<br/>
</div>
<div class="t2">
									#의사결정나무									# 알고리즘									# 과적합									# 엔트로피							</div>
</div>

</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
<div class="sg1">
<div class="w1">
<span class="g1">4과목</span>
<span class="g1">분류분석</span>
<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
</div>
</div>
<div class="tg1">
<strong class="tt1">
<span class="tt1n">12.</span>
<span class="tt1t1">
				다음 중 의사결정 나무 모형에서 과대적합되어 현실 문제에 적용할 수 있는 적절한 규칙이 나오지 않는 현상을 방지하기 위해 사용되는 방법으로 가장 적절한 것은?							</span>
</strong>
<span class="tt1t1">
</span>
</div>
<ol class="lst1">
<li class="li1"><a class="a1"><span class="t1">
			가지치기(Pruning)					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			스테밍(Stemming)					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			정지규칙(Stopping rule) 					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			랜덤포레스트(Random forest)					</span></a></li>
</ol>
<div class="eg1">
<a class="b2 help" href="#m-help1a12" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
<span class="t1">정답보기</span>
<i class="ic1"></i>
</a>
</div>
<div class="tg2 loaded" id="m-help1a12" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
<strong class="tt1">정답</strong>
<div class="t2">
<i class="t2n">1</i>
<span class="t2t1">
			가지치기(Pruning)			</span>
</div>
<br/>
<strong class="tt1">해설</strong>
<div class="t1">
		의사결정나무 중 가지치기 단계는 오차를 크게 할 위험이 높거나 부적절한 추론 규칙을 가지고 있는 가지 또는 불필요한 가지를 제거하는 단계이다. 				</div>


<div class="more-c">
<strong class="tt1">비기봇 해설</strong>
<div class="t1">
				정답은 1번입니다.<br/>
<br/>
의사결정 나무 모형은 데이터를 기반으로 의사결정을 돕는 도구로, 주어진 데이터를 분할하여 예측을 수행합니다. 그러나 이 과정에서 과대적합이 발생할 수 있습니다. 과대적합이란 모델이 학습 데이터에 너무 맞춰져서 새로운 데이터에 대한 일반화 능력이 떨어지는 현상을 말합니다. 이를 방지하기 위해 가지치기(Pruning)와 같은 기법이 사용됩니다. 가지치기는 불필요한 가지를 제거하여 모델의 복잡성을 줄이고, 일반화 성능을 향상시키는 방법입니다.<br/>
<br/>
1. 가지치기(Pruning) <br/>
: 가지치기(Pruning)는 의사결정 나무에서 불필요하거나 부적절한 가지를 제거하여 모델의 복잡성을 줄이는 기법입니다. 이는 과대적합을 방지하고 모델의 일반화 성능을 향상시키는 데 중요한 역할을 합니다. 가지치기를 통해 모델은 더 간결해지고, 새로운 데이터에 대한 예측력이 향상됩니다.<br/>
<br/>
2. 스테밍(Stemming) <br/>
: 스테밍(Stemming)은 자연어 처리에서 단어의 어근을 추출하는 과정으로, 의사결정 나무의 과대적합 방지와는 관련이 없습니다. 이는 텍스트 데이터 전처리 과정에서 사용되며, 모델의 복잡성을 줄이는 데 직접적인 역할을 하지 않습니다.<br/>
<br/>
3. 정지규칙(Stopping rule) <br/>
: 정지규칙(Stopping rule)은 모델 학습을 중단하는 기준을 설정하는 방법입니다. 이는 과대적합을 방지하는 데 도움을 줄 수 있지만, 의사결정 나무에서 가지치기와 같은 직접적인 가지 제거 방법은 아닙니다.<br/>
<br/>
4. 랜덤포레스트(Random forest) <br/>
: 랜덤포레스트(Random forest)는 여러 개의 의사결정 나무를 결합하여 예측 성능을 향상시키는 앙상블 기법입니다. 이는 개별 나무의 과대적합을 줄이는 데 효과적이지만, 가지치기와 같은 개별 나무의 복잡성을 줄이는 방법은 아닙니다.<br/>
<br/>
가지치기(Pruning)는 의사결정 나무의 과대적합을 방지하기 위한 가장 직접적인 방법입니다. 이는 불필요한 가지를 제거하여 모델의 복잡성을 줄이고, 일반화 성능을 향상시킵니다. 반면, 스테밍은 자연어 처리 기법으로 관련이 없고, 정지규칙은 학습 중단 기준으로 가지치기와는 다릅니다. 랜덤포레스트는 앙상블 기법으로 개별 나무의 복잡성을 줄이는 방법이 아닙니다.<br/>
따라서, 정답은 '1. 가지치기(Pruning)' 입니다.<br/>
</div>
<div class="t2">
									#의사결정 나무									# 과대적합									# 가지치기									# 일반화									# 모델 복잡성							</div>
</div>

</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
<div class="sg1">
<div class="w1">
<span class="g1">4과목</span>
<span class="g1">데이터 마이닝 개요</span>
<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
</div>
</div>
<div class="tg1">
<strong class="tt1">
<span class="tt1n">13.</span>
<span class="tt1t1">
				다음 중 데이터를 무작위로 두 집단으로 분리하여 실험데이터와 평가데이터로 설정하고 검정을 실시하는 모형 평가방법으로 적절한 것은? 							</span>
</strong>
<span class="tt1t1">
</span>
</div>
<ol class="lst1">
<li class="li1"><a class="a1"><span class="t1">
			k-fold 교차 검정					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			ROC 그래프					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			홀드아웃 방법					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			이익도표					</span></a></li>
</ol>
<div class="eg1">
<a class="b2 help" href="#m-help1a13" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
<span class="t1">정답보기</span>
<i class="ic1"></i>
</a>
</div>
<div class="tg2 loaded" id="m-help1a13" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
<strong class="tt1">정답</strong>
<div class="t2">
<i class="t2n">3</i>
<span class="t2t1">
			홀드아웃 방법			</span>
</div>
<br/>
<strong class="tt1">해설</strong>
<div class="t1">
		홀드아웃 방법은 데이터의 양이 충분하지 않거나 입력 변수에 대한 설명이 충분한 경우에 사용하는 모형평가 방법으로 주어진 데이터를 랜덤하게 두 개의 데이터로 구분하여 사용하는 방법이다.				</div>


<div class="more-c">
<strong class="tt1">비기봇 해설</strong>
<div class="t1">
				정답은 3번입니다.<br/>
<br/>
데이터를 무작위로 두 집단으로 나누어 실험데이터와 평가데이터로 설정하는 방법은 모델의 성능을 평가하기 위한 기본적인 접근 방식입니다. 이 방법은 주로 모델이 새로운 데이터에 대해 얼마나 잘 일반화되는지를 평가하는 데 사용됩니다.<br/>
<br/>
1. k-fold 교차 검정<br/>
: k-fold 교차 검정은 데이터를 k개의 부분으로 나누어 각 부분을 한 번씩 테스트 데이터로 사용하고 나머지를 훈련 데이터로 사용하는 방법입니다. 이는 데이터의 모든 부분이 테스트 데이터로 사용되므로 모델의 일반화 성능을 더 잘 평가할 수 있습니다.<br/>
<br/>
2. ROC 그래프<br/>
: ROC 그래프는 이진 분류 문제에서 모델의 성능을 평가하기 위한 시각적 도구로, 민감도와 특이도의 관계를 나타냅니다. 이는 데이터 분할 방법과는 관련이 없습니다.<br/>
<br/>
3. 홀드아웃 방법<br/>
: 홀드아웃 방법은 데이터를 두 개의 집단으로 나누어 하나는 훈련에, 다른 하나는 평가에 사용하는 방법입니다. 이는 가장 기본적인 데이터 분할 방법으로, 모델의 초기 성능 평가에 사용됩니다.<br/>
<br/>
4. 이익도표<br/>
: 이익도표는 모델의 예측 결과에 따른 이익을 시각적으로 표현하는 도구로, 데이터 분할 방법과는 관련이 없습니다.<br/>
<br/>
<br/>
홀드아웃 방법은 데이터를 무작위로 두 집단으로 나누어 하나는 훈련에, 다른 하나는 평가에 사용하는 방법으로, 문제에서 요구하는 '무작위로 두 집단으로 분리하여 실험데이터와 평가데이터로 설정'하는 방법에 부합합니다. 다른 선택지들은 데이터 분할 방법과 직접적인 관련이 없거나, 다른 목적의 도구입니다.<br/>
<br/>
따라서, 정답은 '3. 홀드아웃 방법' 입니다.<br/>
</div>
<div class="t2">
									#홀드아웃									# 데이터 분할									# 모델 평가									# 일반화							</div>
</div>

</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
<div class="sg1">
<div class="w1">
<span class="g1">4과목</span>
<span class="g1">데이터 마이닝 개요</span>
<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
</div>
</div>
<div class="tg1">
<strong class="tt1">
<span class="tt1n">14.</span>
<span class="tt1t1">
				소매점에서 물건을 배열하거나 카탈로그 및 교차판매 등에 적용하기 적합한 데이터 마이닝 기법은 무엇인가? 							</span>
</strong>
<span class="tt1t1">
</span>
</div>
<ol class="lst1">
<li class="li1"><a class="a1"><span class="t1">
			분류(classification)					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			예측(prediction)					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			연관분석(association analysis)					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			군집(clustering)					</span></a></li>
</ol>
<div class="eg1">
<a class="b2 help" href="#m-help1a14" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
<span class="t1">정답보기</span>
<i class="ic1"></i>
</a>
</div>
<div class="tg2 loaded" id="m-help1a14" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
<strong class="tt1">정답</strong>
<div class="t2">
<i class="t2n">3</i>
<span class="t2t1">
			연관분석(association analysis)			</span>
</div>
<br/>
<strong class="tt1">해설</strong>
<div class="t1">
		연관분석은 기업의 데이터베이스에서 상품의 구매, 서비스 등 일련의 거래 또는 사건들 간의 규칙을 발견하기 위해 적용하는 분석으로 흔히 장바구니 분석 또는 서열분석이라고 불린다.				</div>


<div class="more-c">
<strong class="tt1">비기봇 해설</strong>
<div class="t1">
				정답은 3번입니다.<br/>
<br/>
데이터 마이닝 기법은 다양한 데이터 패턴을 발견하고 이를 활용하여 비즈니스 인사이트를 얻는 데 사용됩니다. 소매점에서 물건을 배열하거나 카탈로그 및 교차판매 등에 적합한 기법은 고객의 구매 패턴을 분석하여 관련 상품을 함께 추천하는 데 유용합니다.<br/>
<br/>
1. 분류(classification)<br/>
: 분류는 주어진 데이터의 속성을 기반으로 미리 정의된 카테고리로 데이터를 분류하는 기법입니다. 주로 고객 세분화나 스팸 메일 필터링 등에 사용됩니다.<br/>
<br/>
2. 예측(prediction)<br/>
: 예측은 과거 데이터를 기반으로 미래의 결과를 예측하는 기법입니다. 주로 매출 예측이나 수요 예측 등에 사용됩니다.<br/>
<br/>
3. 연관분석(association analysis)<br/>
: 연관분석은 데이터 내의 항목 간의 관계를 발견하는 기법으로, 주로 장바구니 분석에 사용됩니다. 이는 고객이 함께 구매하는 상품을 파악하여 교차판매 전략을 수립하는 데 유용합니다.<br/>
<br/>
4. 군집(clustering)<br/>
: 군집은 유사한 특성을 가진 데이터들을 그룹화하는 기법입니다. 주로 고객 세분화나 시장 세분화 등에 사용됩니다.<br/>
<br/>
<br/>
연관분석은 고객의 구매 패턴을 분석하여 관련 상품을 함께 추천하는 데 유용한 기법입니다. 이는 소매점에서 물건을 배열하거나 카탈로그 및 교차판매 전략을 수립하는 데 적합합니다. 다른 선택지들은 각각 다른 목적에 맞는 기법으로, 소매점의 교차판매와 직접적인 관련이 없습니다.<br/>
<br/>
따라서, 정답은 '3. 연관분석(association analysis)' 입니다.<br/>
</div>
<div class="t2">
									#데이터 마이닝									# 연관분석									# 교차판매									# 장바구니 분석							</div>
</div>

</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
<div class="sg1">
<div class="w1">
<span class="g1">4과목</span>
<span class="g1">분류분석</span>
<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
</div>
</div>
<div class="tg1">
<strong class="tt1">
<span class="tt1n">15.</span>
<span class="tt1t1">
				아래는 kyphosis라는 자료를 이용하여 의사결정나무 분석을 수행한 결과이다. 결과에 대한 해석으로 부적절한 것은?							</span>
</strong>
<span class="tt1t1">
<a class="p1" href="exam1view1img1.php?img=adb3c484-2e97-b435-36be-543c7573ef53.png" rel="noopener" target="_blank" title="새 창">
<img alt="문제에 포함된 이미지" src="https://www.dataedupt.kr/data/img/question/adb3c484-2e97-b435-36be-543c7573ef53.png"/>
</a>
</span>
</div>
<ol class="lst1">
<li class="li1"><a class="a1"><span class="t1">
			뿌리마디에서 아래로 내려갈수록 각 마디에서의 불순도는 점차 증가한다.					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			뿌리마디의 자료는 Start 변수를 이용하여 분리했을 때 present와 absent를 가장 잘 분리시킬 수 있다.					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			위 결과의 단계에서 멈추지 않고 추가로 가지를 생성한다면, 새로운 자료에 대한 예측력은 떨어질 수도 있다.					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			이 자료에서 Start 변수의 값이 14.5이상인 관찰치는 Kyphosis 변수의 값이 모두 absent 였을 것이다.					</span></a></li>
</ol>
<div class="eg1">
<a class="b2 help" href="#m-help1a15" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
<span class="t1">정답보기</span>
<i class="ic1"></i>
</a>
</div>
<div class="tg2 loaded" id="m-help1a15" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
<strong class="tt1">정답</strong>
<div class="t2">
<i class="t2n">1</i>
<span class="t2t1">
			뿌리마디에서 아래로 내려갈수록 각 마디에서의 불순도는 점차 증가한다.			</span>
</div>
<br/>
<strong class="tt1">해설</strong>
<div class="t1">
		뿌리마디에서 아래로 내려갈수록 각 마디에서의 불순도는 점차 감소한다.				</div>


<div class="more-c">
<strong class="tt1">비기봇 해설</strong>
<div class="t1">
				1. 의사결정나무 분석에서 뿌리마디에서 아래로 내려갈수록 각 마디에서의 불순도는 점차 감소한다. 불순도는 해당 마디에 속한 데이터의 클래스가 얼마나 잘 섞여 있는지를 나타내는 지표로, 한 마디에 속한 데이터가 모두 같은 클래스에 속하면 불순도는 0이 되고, 반대로 모든 클래스의 데이터가 균등하게 섞여 있으면 불순도는 최대가 된다. 따라서 분류가 잘 되어있는 마디일수록 불순도는 낮아진다.<br/>
<br/>
2. 뿌리마디의 자료는 Start 변수를 이용하여 분리했을 때 present와 absent를 가장 잘 분리시킬 수 있다. 이는 의사결정나무 분석에서 사용되는 변수 선택 기준에 따른 결과이다.<br/>
<br/>
3. 위 결과의 단계에서 멈추지 않고 추가로 가지를 생성한다면, 새로운 자료에 대한 예측력은 떨어질 수도 있다. 이는 과적합(overfitting) 문제를 의미한다. 과적합은 모델이 학습 데이터에 너무 잘 맞아서 새로운 데이터에 대한 예측력이 떨어지는 현상을 말한다.<br/>
<br/>
4. 이 자료에서 Start 변수의 값이 14.5이상인 관찰치는 Kyphosis 변수의 값이 모두 absent 였을 것이다. 이는 의사결정나무의 분류 결과를 해석한 것이다.<br/>
<br/>
</div>
<div class="t2">
									# 의사결정나무									# 불순도									# 분류									# 과적합									# 변수 선택 기준									# 분석 결과 해석							</div>
</div>

</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
<div class="sg1">
<div class="w1">
<span class="g1">4과목</span>
<span class="g1">분류분석</span>
<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
</div>
</div>
<div class="tg1">
<strong class="tt1">
<span class="tt1n">16.</span>
<span class="tt1t1">
				다음 중 의사결정나무 모형의 학습 방법에 대한 설명으로 부족한 것은 무엇인가? 							</span>
</strong>
<span class="tt1t1">
</span>
</div>
<ol class="lst1">
<li class="li1"><a class="a1"><span class="t1">
			이익도표 또는 검정용 자료에 의한 교차타당성 등을 이용해 의사결정나무를 평가한다. 					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			분리 변수의 P차원 공간에 대한 현재 분할은 이전 분할에 영향을 받지 않고 이루어지며, 공간을 분할하는 모든 직사각형들이 가능한 순수하게 되도록 만든다.					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			각 마디에서의 최적 분리규칙은 분리변수의 선택과 분리기준에 의해 결정된다.					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			가지치기는 분류 오류를 크게 할 위험이 높거나 부적절한 규칙을 가지고 있는 가지를 제거하는 작업이다.					</span></a></li>
</ol>
<div class="eg1">
<a class="b2 help" href="#m-help1a16" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
<span class="t1">정답보기</span>
<i class="ic1"></i>
</a>
</div>
<div class="tg2 loaded" id="m-help1a16" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
<strong class="tt1">정답</strong>
<div class="t2">
<i class="t2n">2</i>
<span class="t2t1">
			분리 변수의 P차원 공간에 대한 현재 분할은 이전 분할에 영향을 받지 않고 이루어지며, 공간을 분할하는 모든 직사각형들이 가능한 순수하게 되도록 만든다.			</span>
</div>
<br/>
<strong class="tt1">해설</strong>
<div class="t1">
		분리변수의 P차원 공간에 대한 현재 분할은 이전 분할에 영향을 받는다.				</div>


<div class="more-c">
<strong class="tt1">비기봇 해설</strong>
<div class="t1">
				정답은 2번입니다.<br/>
<br/>
의사결정나무 모형은 데이터를 분류하거나 회귀 분석을 수행하는 데 사용되는 기계 학습 모델입니다. 이 모형은 데이터를 여러 기준에 따라 분할하여 의사결정 규칙을 생성합니다. 각 노드에서 최적의 분리 기준을 선택하고, 가지치기를 통해 불필요한 복잡성을 줄이는 것이 중요합니다.<br/>
<br/>
1. 이익도표 또는 검정용 자료에 의한 교차타당성 등을 이용해 의사결정나무를 평가한다.<br/>
: 의사결정나무의 성능을 평가하기 위해 교차타당성이나 이익도표를 사용할 수 있습니다. 이는 모델의 일반화 능력을 확인하는 데 유용합니다.<br/>
<br/>
2. 분리 변수의 P차원 공간에 대한 현재 분할은 이전 분할에 영향을 받지 않고 이루어지며, 공간을 분할하는 모든 직사각형들이 가능한 순수하게 되도록 만든다.<br/>
: 의사결정나무는 각 분할이 이전 분할에 영향을 받지 않으며, 가능한 한 순수한 분할을 목표로 합니다. 이는 각 노드에서 최적의 분리 기준을 선택하는 과정과 관련이 있습니다.<br/>
<br/>
3. 각 마디에서의 최적 분리규칙은 분리변수의 선택과 분리기준에 의해 결정된다.<br/>
: 각 마디에서의 최적 분리 규칙은 분리 변수의 선택과 분리 기준에 의해 결정됩니다. 이는 의사결정나무의 기본적인 학습 과정입니다.<br/>
<br/>
4. 가지치기는 분류 오류를 크게 할 위험이 높거나 부적절한 규칙을 가지고 있는 가지를 제거하는 작업이다.<br/>
: 가지치기는 모델의 복잡성을 줄이고 과적합을 방지하기 위해 불필요한 가지를 제거하는 과정입니다. 이는 모델의 일반화 능력을 향상시키는 데 기여합니다.<br/>
<br/>
<br/>
두 번째 선택지는 의사결정나무의 분할 과정에 대한 설명이 부족합니다. 의사결정나무는 각 분할이 이전 분할에 영향을 받지 않는 것이 아니라, 이전 분할의 결과에 따라 다음 분할이 이루어집니다. 따라서 이 설명은 부정확합니다. 다른 선택지들은 의사결정나무의 학습 과정과 평가 방법에 대한 적절한 설명을 제공하고 있습니다.<br/>
<br/>
따라서, 정답은 '2. 분리 변수의 P차원 공간에 대한 현재 분할은 이전 분할에 영향을 받지 않고 이루어지며, 공간을 분할하는 모든 직사각형들이 가능한 순수하게 되도록 만든다.' 입니다.<br/>
</div>
<div class="t2">
									#의사결정나무									# 교차타당성									# 분리 기준									# 가지치기							</div>
</div>

</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
<div class="sg1">
<div class="w1">
<span class="g1">4과목</span>
<span class="g1">분류분석</span>
<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
</div>
</div>
<div class="tg1">
<strong class="tt1">
<span class="tt1n">17.</span>
<span class="tt1t1">
				다음 중 아래 의사결정나무에서 B의 지니지수를 계산한 결과로 적절한 것은?							</span>
</strong>
<span class="tt1t1">
<a class="p1" href="exam1view1img1.php?img=66b45da4-3f2f-aca2-ccbf-43159eec8d92.jpg" rel="noopener" target="_blank" title="새 창">
<img alt="문제에 포함된 이미지" src="https://www.dataedupt.kr/data/img/question/66b45da4-3f2f-aca2-ccbf-43159eec8d92.jpg"/>
</a>
</span>
</div>
<ol class="lst1">
<li class="li1"><a class="a1"><span class="t1">
			0.5					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			0.48					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			0.38					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			0.32					</span></a></li>
</ol>
<div class="eg1">
<a class="b2 help" href="#m-help1a17" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
<span class="t1">정답보기</span>
<i class="ic1"></i>
</a>
</div>
<div class="tg2 loaded" id="m-help1a17" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
<strong class="tt1">정답</strong>
<div class="t2">
<i class="t2n">4</i>
<span class="t2t1">
			0.32			</span>
</div>
<br/>
<strong class="tt1">해설</strong>
<div class="t1">
		B의 지니지수를 계산하는 식은 (1-{left({10over 50}right)}^{2}-{left({40over 50}right)}^{2}=0.32)로 계산할 수 있다.				</div>


<div class="more-c">
<strong class="tt1">비기봇 해설</strong>
<div class="t1">
				주어진 의사결정나무에서 노드 B의 지니 지수를 계산하겠습니다. 지니 지수(Gini index)는 불순도를 측정하는 지표로, 다음과 같이 계산됩니다: Gini = 1- ∑<mjx-container class="MathJax CtxtMenu_Attached_0" ctxtmenu_counter="4" jax="CHTML" style="font-size: 113.1%; position: relative;" tabindex="0"><mjx-math aria-hidden="true" class="MJX-TEX"><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D460 TEX-I"></mjx-c></mjx-mi><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D462 TEX-I"></mjx-c></mjx-mi><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D45A TEX-I"></mjx-c></mjx-mi><mjx-mo class="mjx-n"><mjx-c class="mjx-c28"></mjx-c></mjx-mo><mjx-msubsup><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D45D TEX-I"></mjx-c></mjx-mi><mjx-script style="vertical-align: -0.284em; margin-left: 0px;"><mjx-mn class="mjx-n" size="s"><mjx-c class="mjx-c32"></mjx-c></mjx-mn><mjx-spacer style="margin-top: 0.18em;"></mjx-spacer><mjx-mi class="mjx-i" size="s"><mjx-c class="mjx-c1D456 TEX-I"></mjx-c></mjx-mi></mjx-script></mjx-msubsup><mjx-mo class="mjx-n"><mjx-c class="mjx-c29"></mjx-c></mjx-mo></mjx-math><mjx-assistive-mml display="inline" unselectable="on"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>s</mi><mi>u</mi><mi>m</mi><mo stretchy="false">(</mo><msubsup><mi>p</mi><mi>i</mi><mn>2</mn></msubsup><mo stretchy="false">)</mo></math></mjx-assistive-mml></mjx-container><br/>
<br/>
노드 P의 클래스 비율 계산 : <br/>
good : 10, bad : 40, 전체 : 50<br/>
P(good) = 10/50=0.2<br/>
P(bad) = 40/50=0.8<br/>
<br/>
지니지수 계산 :<br/>
Gini(B)=1-(0.2^2+0.8^2) = 1-0.65 = 0.32<br/>
<br/>
따라서 노드B의 지니 지수는 0.32입니다.<br/>
</div>
<div class="t2">
									#의사결정나무									# 지니지수									# 불순도 측정							</div>
</div>

</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
<div class="sg1">
<div class="w1">
<span class="g1">4과목</span>
<span class="g1">분류분석</span>
<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
</div>
</div>
<div class="tg1">
<strong class="tt1">
<span class="tt1n">18.</span>
<span class="tt1t1">
				이익도표(Lift)를 작성함에 있어 평가도구 중 %Captured Response를 표현한 계산식으로 올바른 것은? 							</span>
</strong>
<span class="tt1t1">
</span>
</div>
<ol class="lst1">
<li class="li1"><a class="a1"><span class="t1">
			해당집단에서 목표변수의 특정범주 빈도 / 전체 목표변수의 특정범주 빈도 x 100 					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			해당집단에서 목표변수의 특정범주 빈도 / 해당집단에서 전체 빈도 x 100 					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			전체에서 목표변수의 특정범주 빈도 / 전체 빈도 x 100 					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			해당집단의 %Response / BASE line Lift x 100					</span></a></li>
</ol>
<div class="eg1">
<a class="b2 help" href="#m-help1a18" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
<span class="t1">정답보기</span>
<i class="ic1"></i>
</a>
</div>
<div class="tg2 loaded" id="m-help1a18" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
<strong class="tt1">정답</strong>
<div class="t2">
<i class="t2n">1</i>
<span class="t2t1">
			해당집단에서 목표변수의 특정범주 빈도 / 전체 목표변수의 특정범주 빈도 x 100 			</span>
</div>
<br/>
<strong class="tt1">해설</strong>
<div class="t1">
		%Captured Response란 전체에서 해당집단을 분리해내는 비율을 의미하며 Score에 따라 고객을 10개의 집단으로 구분하고, 집단이 누적됨에 따라 전체 재구매 고객 대비 Percentile별 누적 구매 고객의 비율을 나타낸다. 특정 범주의 고객에게 Action을 수행할 경우, 실제 반응이 나타난 고객 중 몇 %의 고객을 확보할 수 있는지에 대한 수치로 해석할 수 있다.				</div>


<div class="more-c">
<strong class="tt1">비기봇 해설</strong>
<div class="t1">
				정답은 1번입니다.<br/>
<br/>
이익도표(Lift)는 모델의 성능을 평가하는 도구로, %Captured Response는 특정 집단이 전체 목표 변수의 특정 범주를 얼마나 잘 포착하는지를 나타내는 지표입니다. 이 지표는 모델의 예측력이 얼마나 우수한지를 평가하는 데 사용됩니다.<br/>
<br/>
1. 해당집단에서 목표변수의 특정범주 빈도 / 전체 목표변수의 특정범주 빈도 x 100<br/>
: 이 식은 특정 집단에서 목표 변수의 특정 범주 빈도를 전체 목표 변수의 특정 범주 빈도로 나누어 %로 표현한 것입니다. 이는 %Captured Response의 정의에 부합합니다.<br/>
<br/>
2. 해당집단에서 목표변수의 특정범주 빈도 / 해당집단에서 전체 빈도 x 100<br/>
: 이 식은 특정 집단에서 목표 변수의 특정 범주 빈도를 해당 집단의 전체 빈도로 나누어 %로 표현한 것입니다. 이는 %Response를 계산하는 방식입니다.<br/>
<br/>
3. 전체에서 목표변수의 특정범주 빈도 / 전체 빈도 x 100<br/>
: 이 식은 전체에서 목표 변수의 특정 범주 빈도를 전체 빈도로 나누어 %로 표현한 것입니다. 이는 전체 데이터에서의 비율을 나타내며, %Captured Response와는 다릅니다.<br/>
<br/>
4. 해당집단의 %Response / BASE line Lift x 100<br/>
: 이 식은 해당 집단의 %Response를 BASE line Lift로 나눈 후 %로 표현한 것입니다. 이는 Lift의 개념을 활용한 것이지만, %Captured Response와는 관련이 없습니다.<br/>
<br/>
<br/>
정답은 1번입니다. %Captured Response는 특정 집단에서 목표 변수의 특정 범주 빈도를 전체 목표 변수의 특정 범주 빈도로 나누어 %로 표현한 것입니다. 이는 모델이 특정 범주를 얼마나 잘 포착하는지를 나타내는 지표로, 1번 선지가 이를 정확히 설명하고 있습니다. 다른 선택지들은 %Captured Response의 정의와 맞지 않거나 다른 개념을 설명하고 있습니다.<br/>
<br/>
따라서, 정답은 '1. 해당집단에서 목표변수의 특정범주 빈도 / 전체 목표변수의 특정범주 빈도 x 100' 입니다.<br/>
</div>
<div class="t2">
									#이익도표									# Lift									# %Captured Response									# 모델 평가							</div>
</div>

</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
<div class="sg1">
<div class="w1">
<span class="g1">4과목</span>
<span class="g1">앙상블 기법</span>
<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
</div>
</div>
<div class="tg1">
<strong class="tt1">
<span class="tt1n">19.</span>
<span class="tt1t1">
				다음 중 배깅(Bagging)에 대한 설명으로 가장 적절한 것은?							</span>
</strong>
<span class="tt1t1">
</span>
</div>
<ol class="lst1">
<li class="li1"><a class="a1"><span class="t1">
			배깅은 데이터 간의 거리를 측정하여 군집화한다.					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			배깅은 트랜잭션 사이에 빈번하게 발행하는 규칙을 찾아낸다.					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			배깅은 고차원의 데이터를 이해하기 쉬운 저차원의 뉴런으로 정렬하여 지도의 형태로 형상화한다. 					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			배깅은 반복 추출 방법을 사용하기 때문에 같은 데이터가 한 표본에 여러 번 추출 될 수 있고, 어떤 데이터는 추출되지 않을 수도 있다.					</span></a></li>
</ol>
<div class="eg1">
<a class="b2 help" href="#m-help1a19" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
<span class="t1">정답보기</span>
<i class="ic1"></i>
</a>
</div>
<div class="tg2 loaded" id="m-help1a19" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
<strong class="tt1">정답</strong>
<div class="t2">
<i class="t2n">4</i>
<span class="t2t1">
			배깅은 반복 추출 방법을 사용하기 때문에 같은 데이터가 한 표본에 여러 번 추출 될 수 있고, 어떤 데이터는 추출되지 않을 수도 있다.			</span>
</div>
<br/>
<strong class="tt1">해설</strong>
<div class="t1">
		배깅은 주어진 자료에서 여러 개의 붓스트랩 자료를 생성하고, 각 붓스트랩 자료에 예측모형을 만든 후 결합하여 최종 예측모형을 만드는 방법이다. 				</div>


<div class="more-c">
<strong class="tt1">비기봇 해설</strong>
<div class="t1">
				정답은 4번입니다.<br/>
<br/>
배깅(Bagging)은 Bootstrap Aggregating의 줄임말로, 여러 개의 학습 데이터 세트를 생성하여 각각의 모델을 학습시키고, 그 결과를 결합하여 최종 예측을 수행하는 앙상블 학습 방법입니다. 이는 모델의 분산을 줄이고 예측 성능을 향상시키는 데 도움을 줍니다.<br/>
<br/>
1. 배깅은 데이터 간의 거리를 측정하여 군집화한다.<br/>
: 데이터 간의 거리를 측정하여 군집화하는 것은 클러스터링 기법에 해당합니다. 배깅과는 관련이 없습니다.<br/>
<br/>
2. 배깅은 트랜잭션 사이에 빈번하게 발행하는 규칙을 찾아낸다.<br/>
: 트랜잭션 사이에 빈번하게 발생하는 규칙을 찾는 것은 연관 규칙 학습, 특히 Apriori 알고리즘과 관련이 있습니다. 배깅과는 관련이 없습니다.<br/>
<br/>
3. 배깅은 고차원의 데이터를 이해하기 쉬운 저차원의 뉴런으로 정렬하여 지도의 형태로 형상화한다.<br/>
: 고차원의 데이터를 저차원의 뉴런으로 정렬하여 지도의 형태로 형상화하는 것은 주로 자기조직화 지도(SOM)와 관련이 있습니다. 배깅과는 관련이 없습니다.<br/>
<br/>
4. 배깅은 반복 추출 방법을 사용하기 때문에 같은 데이터가 한 표본에 여러 번 추출 될 수 있고, 어떤 데이터는 추출되지 않을 수도 있다.<br/>
: 반복 추출 방법을 사용하여 같은 데이터가 여러 번 추출될 수 있고, 어떤 데이터는 추출되지 않을 수 있는 것은 배깅의 특징입니다. 이는 부트스트랩 샘플링을 통해 이루어집니다.<br/>
<br/>
<br/>
배깅은 부트스트랩 샘플링을 사용하여 여러 개의 학습 데이터 세트를 생성합니다. 이 과정에서 같은 데이터가 여러 번 추출될 수 있으며, 어떤 데이터는 추출되지 않을 수도 있습니다. 이는 배깅의 핵심적인 특징으로, 모델의 분산을 줄이고 예측 성능을 향상시키는 데 기여합니다. 다른 선택지들은 배깅과 관련이 없는 다른 기계 학습 기법들에 대한 설명입니다.<br/>
<br/>
따라서, 정답은 '4. 배깅은 반복 추출 방법을 사용하기 때문에 같은 데이터가 한 표본에 여러 번 추출 될 수 있고, 어떤 데이터는 추출되지 않을 수도 있다.' 입니다.<br/>
</div>
<div class="t2">
									#배깅									# 부트스트랩 샘플링									# 앙상블 학습									# 모델의 분산							</div>
</div>

</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
<div class="sg1">
<div class="w1">
<span class="g1">4과목</span>
<span class="g1">앙상블 기법</span>
<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
</div>
</div>
<div class="tg1">
<strong class="tt1">
<span class="tt1n">20.</span>
<span class="tt1t1">
				다음 중 앙상블 기법이라고 할 수 없는 것은?							</span>
</strong>
<span class="tt1t1">
</span>
</div>
<ol class="lst1">
<li class="li1"><a class="a1"><span class="t1">
			시그모이드					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			부스팅					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			배깅					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			랜덤포레스트					</span></a></li>
</ol>
<div class="eg1">
<a class="b2 help" href="#m-help1a20" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
<span class="t1">정답보기</span>
<i class="ic1"></i>
</a>
</div>
<div class="tg2 loaded" id="m-help1a20" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
<strong class="tt1">정답</strong>
<div class="t2">
<i class="t2n">1</i>
<span class="t2t1">
			시그모이드			</span>
</div>
<br/>
<strong class="tt1">해설</strong>
<div class="t1">
		앙상블 기법은 배깅(Bagging), 부스팅(Boosting), 랜덤포레스트(Random Forest)가 포함된다. 시그모이드는 인공 신경망에서 활성화함수로 쓰인다.				</div>


<div class="more-c">
<strong class="tt1">비기봇 해설</strong>
<div class="t1">
				정답은 1번입니다.<br/>
<br/>
앙상블 기법은 여러 모델을 결합하여 예측 성능을 향상시키는 방법입니다. 주로 배깅, 부스팅, 랜덤포레스트와 같은 기법이 사용됩니다.<br/>
<br/>
1. 시그모이드<br/>
: 시그모이드는 주로 로지스틱 회귀나 신경망에서 활성화 함수로 사용되며, 앙상블 기법과는 관련이 없습니다.<br/>
<br/>
2. 부스팅<br/>
: 부스팅은 여러 약한 학습기를 순차적으로 학습시켜 강한 학습기를 만드는 앙상블 기법입니다.<br/>
<br/>
3. 배깅<br/>
: 배깅은 여러 학습기를 병렬로 학습시켜 예측을 결합하는 앙상블 기법입니다.<br/>
<br/>
4. 랜덤포레스트<br/>
: 랜덤포레스트는 배깅의 일종으로, 여러 결정 트리를 학습시켜 예측을 결합하는 앙상블 기법입니다.<br/>
<br/>
<br/>
시그모이드는 앙상블 기법이 아니라 활성화 함수입니다. 반면, 부스팅, 배깅, 랜덤포레스트는 모두 앙상블 기법에 해당합니다.<br/>
<br/>
따라서, 정답은 '1. 시그모이드' 입니다.<br/>
</div>
<div class="t2">
									#앙상블 기법									# 시그모이드									# 부스팅									# 배깅									# 랜덤포레스트							</div>
</div>

</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
<div class="sg1">
<div class="w1">
<span class="g1">4과목</span>
<span class="g1">앙상블 기법</span>
<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
</div>
</div>
<div class="tg1">
<strong class="tt1">
<span class="tt1n">21.</span>
<span class="tt1t1">
				앙상블모형(Ensemble)이란 주어진 자료로부터 여러 개의 예측모형을 만든 후 이러한 예측모형들을 결합하여 하나의 최종 예측모형을 만드는 방법을 말한다. 다음 중 앙상블모형에 대한 설명으로 적절하지 않은 것은?							</span>
</strong>
<span class="tt1t1">
</span>
</div>
<ol class="lst1">
<li class="li1"><a class="a1"><span class="t1">
			배깅은 주어진 자료에서 여러 개의 붓스트랩(Bootstrap) 자료를 생성하고 각 붓스트랩 자료에 예측모형을 만든 후 결합하여 최종 모형을 만드는 방법이다.					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			부스팅은 배깅의 과정과 유사하여 재표본 과정에서 각 자료에 동일한 확률을 부여하여 여러 모형을 만들어 결합하는 방법이다.					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			랜덤 포레스트(Random Forest)는 의사결정나무모형의 특징인 분산이 크다는 점을 고려하여 배깅보다 더 많은 무작위성을 추가한 방법으로 약한 학습기들을 생성하고 이를 선형결합해 최종 학습기를 만드는 방법이다.					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			앙상블모형은 훈련을 한 뒤 예측을 하는데 사용하므로 교사학습법(Supervised Learning)이다.					</span></a></li>
</ol>
<div class="eg1">
<a class="b2 help" href="#m-help1a21" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
<span class="t1">정답보기</span>
<i class="ic1"></i>
</a>
</div>
<div class="tg2 loaded" id="m-help1a21" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
<strong class="tt1">정답</strong>
<div class="t2">
<i class="t2n">2</i>
<span class="t2t1">
			부스팅은 배깅의 과정과 유사하여 재표본 과정에서 각 자료에 동일한 확률을 부여하여 여러 모형을 만들어 결합하는 방법이다.			</span>
</div>
<br/>
<strong class="tt1">해설</strong>
<div class="t1">
		부스팅은 예측력이 약한 모형들을 결합하여 강한 예측모형을 만드는 방법이다.				</div>


<div class="more-c">
<strong class="tt1">비기봇 해설</strong>
<div class="t1">
				정답은 2번입니다.<br/>
<br/>
앙상블 모형은 여러 개의 예측 모형을 결합하여 하나의 최종 예측 모형을 만드는 기법입니다. 이는 개별 모형의 약점을 보완하고 예측 성능을 향상시키기 위해 사용됩니다. 대표적인 앙상블 기법으로는 배깅(Bagging), 부스팅(Boosting), 랜덤 포레스트(Random Forest)가 있습니다. 배깅은 여러 개의 붓스트랩 자료를 생성하여 각각의 자료에 예측 모형을 만든 후 결합하는 방법입니다. 부스팅은 예측력이 약한 모형들을 결합하여 강한 예측 모형을 만드는 방법으로, 오분류 데이터에 가중치를 부여하여 학습을 진행합니다. 랜덤 포레스트는 배깅의 개념에 변수의 임의 선택을 결합하여 더 많은 무작위성을 추가한 방법입니다.<br/>
<br/>
1. 배깅은 주어진 자료에서 여러 개의 붓스트랩(Bootstrap) 자료를 생성하고 각 붓스트랩 자료에 예측모형을 만든 후 결합하여 최종 모형을 만드는 방법이다. <br/>
: 배깅은 주어진 자료에서 여러 개의 붓스트랩 자료를 생성하고, 각 붓스트랩 자료에 예측 모형을 만든 후 결합하여 최종 모형을 만드는 방법입니다. 이는 개별 모형의 예측 결과를 결합하여 안정성을 높이고 과적합을 방지하는 데 효과적입니다.<br/>
<br/>
2. 부스팅은 배깅의 과정과 유사하여 재표본 과정에서 각 자료에 동일한 확률을 부여하여 여러 모형을 만들어 결합하는 방법이다. <br/>
: 부스팅은 배깅과 달리 각 자료에 동일한 확률을 부여하지 않습니다. 대신, 부스팅은 오분류된 데이터에 가중치를 부여하여 학습을 진행하며, 각 단계에서 이전 단계의 오류를 보완하는 방식으로 예측력을 강화합니다. 따라서 부스팅은 배깅과 유사한 과정이 아닙니다.<br/>
<br/>
3. 랜덤 포레스트(Random Forest)는 의사결정나무모형의 특징인 분산이 크다는 점을 고려하여 배깅보다 더 많은 무작위성을 추가한 방법으로 약한 학습기들을 생성하고 이를 선형결합해 최종 학습기를 만드는 방법이다. <br/>
: 랜덤 포레스트는 배깅의 개념에 변수의 임의 선택을 결합하여 더 많은 무작위성을 추가한 방법입니다. 이는 의사결정나무의 분산을 줄이고 예측 성능을 향상시키기 위해 약한 학습기들을 생성하고 이를 결합하여 최종 학습기를 만듭니다.<br/>
<br/>
4. 앙상블모형은 훈련을 한 뒤 예측을 하는데 사용하므로 교사학습법(Supervised Learning)이다. <br/>
: 앙상블 모형은 여러 개의 예측 모형을 결합하여 최종 예측을 수행하는 기법으로, 주어진 데이터를 기반으로 학습을 진행하므로 교사학습법(Supervised Learning)에 해당합니다.<br/>
<br/>
선지 2는 부스팅에 대한 설명이 잘못되었습니다. 부스팅은 배깅과 달리 각 자료에 동일한 확률을 부여하지 않고, 오분류된 데이터에 가중치를 부여하여 학습을 진행합니다. 따라서 부스팅은 배깅과 유사한 과정이 아닙니다. 나머지 선지들은 각각의 앙상블 기법에 대한 설명이 정확합니다.<br/>
따라서, 정답은 '2. 부스팅은 배깅의 과정과 유사하여 재표본 과정에서 각 자료에 동일한 확률을 부여하여 여러 모형을 만들어 결합하는 방법이다.' 입니다.<br/>
</div>
<div class="t2">
									#앙상블									# 배깅									# 부스팅									# 랜덤 포레스트									# 교사학습법							</div>
</div>

</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
<div class="sg1">
<div class="w1">
<span class="g1">4과목</span>
<span class="g1">인공신경망분석</span>
<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
</div>
</div>
<div class="tg1">
<strong class="tt1">
<span class="tt1n">22.</span>
<span class="tt1t1">
				오분류표 중 실제 값이 True인 관측치 중에 예측치가 맞는 정도를 나타내어 모형의 완전성(completeness)을 평가하는 지표를 무엇이라고 하는가?							</span>
</strong>
<span class="tt1t1">
</span>
</div>
<ol class="lst1">
<li class="li1"><a class="a1"><span class="t1">
			재현율					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			오분류율					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			정확도					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			특이도					</span></a></li>
</ol>
<div class="eg1">
<a class="b2 help" href="#m-help1a22" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
<span class="t1">정답보기</span>
<i class="ic1"></i>
</a>
</div>
<div class="tg2 loaded" id="m-help1a22" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
<strong class="tt1">정답</strong>
<div class="t2">
<i class="t2n">1</i>
<span class="t2t1">
			재현율			</span>
</div>
<br/>
<strong class="tt1">해설</strong>
<div class="t1">
		재현율이란 실제 True인 관측치 중에서 True로 예측한 것의 비율이다.				</div>


<div class="more-c">
<strong class="tt1">비기봇 해설</strong>
<div class="t1">
				정답은 1번입니다.<br/>
<br/>
오분류표는 모델의 예측 성능을 평가하는 데 사용되는 도구로, 실제 값과 예측 값의 관계를 나타냅니다. 이 표를 통해 우리는 모델이 얼마나 정확하게 예측했는지를 알 수 있습니다. 오분류표에서 중요한 지표 중 하나는 재현율(Recall)로, 이는 실제 값이 True인 경우 중에서 모델이 True로 예측한 비율을 나타냅니다. 이는 민감도(Sensitivity)와 동일한 개념으로, 모델이 실제로 긍정인 사례를 얼마나 잘 잡아내는지를 평가합니다. 재현율은 TP/(TP+FN)으로 계산되며, 이는 True Positive와 False Negative의 합에서 True Positive의 비율을 의미합니다. 이 외에도 정확도(Accuracy), 특이도(Specificity) 등의 지표가 있으며, 각각의 지표는 모델의 다른 측면을 평가하는 데 사용됩니다.<br/>
<br/>
1. 재현율 <br/>
: 재현율은 모델이 실제로 긍정인 사례를 얼마나 잘 예측하는지를 나타내는 지표입니다. 이는 민감도와 동일한 개념으로, TP/(TP+FN)로 계산됩니다. 재현율이 높다는 것은 모델이 실제 긍정 사례를 잘 잡아낸다는 것을 의미합니다. 따라서, 재현율은 모형의 완전성을 평가하는 데 중요한 지표입니다.<br/>
<br/>
2. 오분류율 <br/>
: 오분류율은 모델이 잘못 예측한 비율을 나타내는 지표로, 1-정확도로 계산됩니다. 이는 FN과 FP의 합을 전체 사례 수로 나눈 값입니다. 오분류율은 모델의 오류를 평가하는 데 사용되며, 모형의 완전성을 직접적으로 평가하는 지표는 아닙니다.<br/>
<br/>
3. 정확도 <br/>
: 정확도는 모델이 전체 사례 중에서 얼마나 정확하게 예측했는지를 나타내는 지표로, (TP+TN)/(TP+TN+FP+FN)으로 계산됩니다. 정확도는 모델의 전반적인 성능을 평가하는 데 유용하지만, 불균형한 데이터셋에서는 오해를 불러일으킬 수 있습니다. 따라서, 모형의 완전성을 평가하는 데는 적합하지 않습니다.<br/>
<br/>
4. 특이도 <br/>
: 특이도는 실제 값이 False인 경우 중에서 모델이 False로 예측한 비율을 나타내는 지표로, TN/(TN+FP)로 계산됩니다. 이는 모델이 실제 부정 사례를 얼마나 잘 예측하는지를 평가합니다. 특이도는 모형의 완전성을 평가하는 지표로 사용되기보다는, 모델의 특정 측면을 평가하는 데 사용됩니다.<br/>
<br/>
재현율은 실제 값이 True인 경우 중에서 모델이 True로 예측한 비율을 나타내며, 이는 모형의 완전성을 평가하는 데 중요한 지표입니다. 다른 지표들인 오분류율, 정확도, 특이도는 각각 모델의 다른 측면을 평가하는 데 사용되며, 모형의 완전성을 직접적으로 평가하지는 않습니다.<br/>
따라서, 정답은 '1. 재현율' 입니다.<br/>
</div>
<div class="t2">
									#오분류표									# 재현율									# 민감도									# 정확도									# 특이도									# 모형의 완전성							</div>
</div>

</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
<div class="sg1">
<div class="w1">
<span class="g1">4과목</span>
<span class="g1">인공신경망분석</span>
<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
</div>
</div>
<div class="tg1">
<strong class="tt1">
<span class="tt1n">23.</span>
<span class="tt1t1">
				오분류표를 사용한 평가 지표 중 아래 설명이 나타내는 지표는 무엇인가?					
					<span class="tt1t1">
						정밀도(precision)와 재현율(recall)은 한 지표의 값이 높아지면 다른 지표의 값이 낮아질 가능성이 높은 관계를 지니고 있어 이러한 효과를 보정하여 하나의 지표로 만들어 낸 지표					</span>
</span>
</strong>
<span class="tt1t1">
</span>
</div>
<ol class="lst1">
<li class="li1"><a class="a1"><span class="t1">
			F1					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			민감도					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			특이도					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			오즈비					</span></a></li>
</ol>
<div class="eg1">
<a class="b2 help" href="#m-help1a23" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
<span class="t1">정답보기</span>
<i class="ic1"></i>
</a>
</div>
<div class="tg2 loaded" id="m-help1a23" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
<strong class="tt1">정답</strong>
<div class="t2">
<i class="t2n">1</i>
<span class="t2t1">
			F1			</span>
</div>
<br/>
<strong class="tt1">해설</strong>
<div class="t1">
		F1은 정확도(Precision)와 재현율(Recall)은 한 지표의 값이 높아지면 다른 지표의 값이 낮아질 가능성이 높은 관계를 지니고 있어 이러한 효과를 보정하여 하나의 지표로 만들어 낸 지표이다.				</div>


<div class="more-c">
<strong class="tt1">비기봇 해설</strong>
<div class="t1">
				정답은 1번입니다.<br/>
<br/>
문제에서 설명하는 지표는 정밀도와 재현율의 조화를 이루는 F1 점수입니다. F1 점수는 정밀도와 재현율의 조화평균으로, 두 지표 간의 균형을 평가하는 데 사용됩니다. 정밀도는 모델이 예측한 긍정 사례 중 실제로 긍정인 비율을 나타내고, 재현율은 실제 긍정 사례 중 모델이 올바르게 예측한 비율을 나타냅니다. 이 두 지표는 상호 보완적이지만, 한쪽이 높아지면 다른 쪽이 낮아질 수 있는 경향이 있습니다. 따라서 F1 점수는 이러한 상충 관계를 보정하여 하나의 지표로 나타냅니다.<br/>
<br/>
1. F1<br/>
: F1 점수는 정밀도와 재현율의 조화평균으로, 두 지표 간의 균형을 평가하는 데 사용됩니다. 정밀도와 재현율이 상충 관계에 있을 때, F1 점수는 이 둘을 하나의 지표로 통합하여 평가합니다.<br/>
<br/>
2. 민감도<br/>
: 민감도는 재현율과 동일한 개념으로, 실제 긍정 사례 중 모델이 올바르게 예측한 비율을 나타냅니다. 정밀도와의 상충 관계를 보정하는 지표는 아닙니다.<br/>
<br/>
3. 특이도<br/>
: 특이도는 실제 부정 사례 중 모델이 올바르게 부정으로 예측한 비율을 나타내며, 정밀도와 재현율의 상충 관계를 보정하는 지표와는 관련이 없습니다.<br/>
<br/>
4. 오즈비<br/>
: 오즈비는 두 사건의 비율을 비교하는 통계적 지표로, 정밀도와 재현율의 상충 관계를 보정하는 지표와는 관련이 없습니다.<br/>
<br/>
<br/>
F1 점수는 정밀도와 재현율의 조화평균으로, 두 지표 간의 상충 관계를 보정하여 하나의 지표로 나타냅니다. 다른 선택지들은 정밀도와 재현율의 상충 관계를 보정하는 지표가 아니므로 정답이 아닙니다.<br/>
<br/>
따라서, 정답은 '1. F1' 입니다.<br/>
</div>
<div class="t2">
									#F1 점수									# 정밀도									# 재현율									# 조화평균							</div>
</div>

</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
<div class="sg1">
<div class="w1">
<span class="g1">4과목</span>
<span class="g1">인공신경망분석</span>
<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
</div>
</div>
<div class="tg1">
<strong class="tt1">
<span class="tt1n">24.</span>
<span class="tt1t1">
				오분류표(Confusion Matrix)를 사용하여 계산할 수 있는 평가 지표 중 민감도와 동일하며 모형의 완전성(Completeness)을 평가하는 지표는?							</span>
</strong>
<span class="tt1t1">
</span>
</div>
<ol class="lst1">
<li class="li1"><a class="a1"><span class="t1">
			F-1 지표					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			정밀도(Precision) 					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			특이도(Specificity)					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			재현율(Recall)					</span></a></li>
</ol>
<div class="eg1">
<a class="b2 help" href="#m-help1a24" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
<span class="t1">정답보기</span>
<i class="ic1"></i>
</a>
</div>
<div class="tg2 loaded" id="m-help1a24" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
<strong class="tt1">정답</strong>
<div class="t2">
<i class="t2n">4</i>
<span class="t2t1">
			재현율(Recall)			</span>
</div>
<br/>
<strong class="tt1">해설</strong>
<div class="t1">
		재현율이란 실제 True인 것 중에서 모델이 True라고 예측한 것의 비율이며 TP/(TP+FN)로 구할 수 있다.				</div>


<div class="more-c">
<strong class="tt1">비기봇 해설</strong>
<div class="t1">
				1. F-1 지표는 정밀도와 재현율의 조화 평균으로, 두 지표가 어느 한 쪽으로 치우치지 않을 때 높은 값을 가집니다. 따라서 완전성을 직접적으로 평가하는 지표는 아닙니다.<br/>
<br/>
2. 정밀도(Precision)는 모델이 True라고 분류한 것 중 실제로 True인 것의 비율로, 모델의 정확성을 평가하는 지표입니다. 따라서 완전성을 직접적으로 평가하는 지표는 아닙니다.<br/>
<br/>
3. 특이도(Specificity)는 실제로 False인 것 중 모델이 False라고 예측한 것의 비율로, 모델의 False 예측 능력을 평가하는 지표입니다. 따라서 완전성을 직접적으로 평가하는 지표는 아닙니다.<br/>
<br/>
4. 재현율(Recall)은 실제로 True인 것 중 모델이 True라고 예측한 것의 비율로, 모델의 완전성을 평가하는 지표입니다. 민감도(Sensitivity)라고도 불리며, 이는 모델이 실제 Positive를 얼마나 잘 찾아내는지를 나타냅니다.<br/>
</div>
<div class="t2">
									# 오분류표									# 민감도									# 완전성									# F-1 지표									# 정밀도									# 특이도									# 재현율							</div>
</div>

</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
<div class="sg1">
<div class="w1">
<span class="g1">4과목</span>
<span class="g1">인공신경망분석</span>
<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
</div>
</div>
<div class="tg1">
<strong class="tt1">
<span class="tt1n">25.</span>
<span class="tt1t1">
				다음 중 아래 오분류표를 이용하여 구한 F1 값은 얼마인가?							</span>
</strong>
<span class="tt1t1">
<a class="p1" href="exam1view1img1.php?img=77f4907a-fa56-a59b-4aa5-ad59424a9bba.png" rel="noopener" target="_blank" title="새 창">
<img alt="문제에 포함된 이미지" src="https://www.dataedupt.kr/data/img/question/77f4907a-fa56-a59b-4aa5-ad59424a9bba.png"/>
</a>
</span>
</div>
<ol class="lst1">
<li class="li1"><a class="a1"><span class="t1">
			0.15					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			0.3					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			0.4					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			0.55					</span></a></li>
</ol>
<div class="eg1">
<a class="b2 help" href="#m-help1a25" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
<span class="t1">정답보기</span>
<i class="ic1"></i>
</a>
</div>
<div class="tg2 loaded" id="m-help1a25" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
<strong class="tt1">정답</strong>
<div class="t2">
<i class="t2n">3</i>
<span class="t2t1">
			0.4			</span>
</div>
<br/>
<strong class="tt1">해설</strong>
<div class="t1">
		F1의 정의는 ({2 over {1 over Recall} + {1 over Precision}})이다. Recall과 Precision을 대입하면 ({2 over {100 over 40} + {100 over 40}}={40 over 100})이 나오므로 0.4이다.				</div>


<div class="more-c">
<strong class="tt1">비기봇 해설</strong>
<div class="t1">
				F1 점수는 정밀도(Precision)와 재현율(Recall)의 조화 평균입니다. 이를 계산하기 위해 먼저 정밀도와 재현율을 구해야 합니다.<br/>
<br/>
- 정밀도(Precision) = TP / (TP + FP)<br/>
- 재현율(Recall) = TP / (TP + FN)<br/>
<br/>
여기서,<br/>
<br/>
- TP (True Positive) = 40<br/>
- FP (False Positive) = 60<br/>
- FN (False Negative) = 60<br/>
<br/>
정밀도(Precision) = 40 / (40 + 60) = 40 / 100 = 0.4<br/>
재현율(Recall) = 40 / (40 + 60) = 40 / 100 = 0.4<br/>
<br/>
F1 점수 = 2 * (정밀도 * 재현율) / (정밀도 + 재현율)<br/>
          = 2 * (0.4 * 0.4) / (0.4 + 0.4)<br/>
          = 2 * 0.16 / 0.8<br/>
          = 0.32 / 0.8<br/>
          = 0.4<br/>
<br/>
따라서, F1 점수는 0.4입니다.<br/>
</div>
<div class="t2">
									# F1 점수									# 정밀도									# 재현율									# 혼동 행렬									# True Positive									# False Positive									# False Negative									# 오분류표							</div>
</div>

</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
<div class="sg1">
<div class="w1">
<span class="g1">4과목</span>
<span class="g1">인공신경망분석</span>
<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
</div>
</div>
<div class="tg1">
<strong class="tt1">
<span class="tt1n">26.</span>
<span class="tt1t1">
				분류모형의 성과 분석 중 ROC Curve는 x축에 FP Ratio, y축에는 민감도를 나타낸다. 아래와 같은 오분류표가 있을 때 민감도를 계산하는 방식으로 가장 적절한 것은?							</span>
</strong>
<span class="tt1t1">
<a class="p1" href="exam1view1img1.php?img=092eac42-b6a9-d02d-cfe2-ccdf6c043d16.png" rel="noopener" target="_blank" title="새 창">
<img alt="문제에 포함된 이미지" src="https://www.dataedupt.kr/data/img/question/092eac42-b6a9-d02d-cfe2-ccdf6c043d16.png"/>
</a>
</span>
</div>
<ol class="lst1">
<li class="li1"><a class="a1"><span class="t1">
			(TP+TN)÷(P+N) 					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			TN÷N					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			TP÷(TP+FP) 					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			TP÷P					</span></a></li>
</ol>
<div class="eg1">
<a class="b2 help" href="#m-help1a26" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
<span class="t1">정답보기</span>
<i class="ic1"></i>
</a>
</div>
<div class="tg2 loaded" id="m-help1a26" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
<strong class="tt1">정답</strong>
<div class="t2">
<i class="t2n">4</i>
<span class="t2t1">
			TP÷P			</span>
</div>
<br/>
<strong class="tt1">해설</strong>
<div class="t1">
		민감도=TP/(TP + FN)이므로 여기서 TP + FN은 P이다. 즉, 민감도 =TP÷P 이다.				</div>


<div class="more-c">
<strong class="tt1">비기봇 해설</strong>
<div class="t1">
				정답은 4번입니다.<br/>
<br/>
민감도(Sensitivity)는 실제 양성 중에서 모델이 양성으로 예측한 비율을 나타냅니다. 이는 TP(참 양성)를 전체 실제 양성(P)으로 나눈 값으로 계산됩니다. 주어진 오분류표에서 TP와 P의 관계를 이해하는 것이 중요합니다.<br/>
<br/>
1. (TP+TN)÷(P+N)<br/>
: 이 식은 정확도를 계산하는 방식으로, 전체 데이터에서 올바르게 예측한 비율을 나타냅니다. 민감도를 계산하는 방식과는 다릅니다.<br/>
<br/>
2. TN÷N<br/>
: 이 식은 특이도를 계산하는 방식으로, 실제 음성 중에서 모델이 음성으로 예측한 비율을 나타냅니다. 민감도와는 관련이 없습니다.<br/>
<br/>
3. TP÷(TP+FP)<br/>
: 이 식은 양성 예측도(Precision)를 계산하는 방식으로, 양성으로 예측한 것 중 실제 양성의 비율을 나타냅니다. 민감도와는 다른 개념입니다.<br/>
<br/>
4. TP÷P<br/>
: 이 식은 민감도를 계산하는 방식으로, 실제 양성 중에서 모델이 양성으로 예측한 비율을 나타냅니다.<br/>
<br/>
<br/>
민감도는 TP를 전체 실제 양성(P)으로 나눈 값으로 계산됩니다. 따라서 정답은 TP÷P입니다. 다른 선택지들은 각각 정확도, 특이도, 양성 예측도를 계산하는 방식으로, 민감도를 계산하는 방식과는 다릅니다.<br/>
<br/>
따라서, 정답은 '4. TP÷P' 입니다.<br/>
</div>
<div class="t2">
									#민감도									# TP									# P									# 오분류표							</div>
</div>

</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
<div class="sg1">
<div class="w1">
<span class="g1">4과목</span>
<span class="g1">인공신경망분석</span>
<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
</div>
</div>
<div class="tg1">
<strong class="tt1">
<span class="tt1n">27.</span>
<span class="tt1t1">
				ROC 커브는 민감도와 1-특이도로 그려지는 커브이다. 아래 오분류표에서 민감도와 특이도는? 							</span>
</strong>
<span class="tt1t1">
<a class="p1" href="exam1view1img1.php?img=68f43b12-6a2d-7df4-a91f-534d9d6ca01a.png" rel="noopener" target="_blank" title="새 창">
<img alt="문제에 포함된 이미지" src="https://www.dataedupt.kr/data/img/question/68f43b12-6a2d-7df4-a91f-534d9d6ca01a.png"/>
</a>
</span>
</div>
<ol class="lst1">
<li class="li1"><a class="a1"><span class="t1">
			민감도 = <mjx-container class="MathJax CtxtMenu_Attached_0" ctxtmenu_counter="5" jax="CHTML" style="font-size: 107.5%; position: relative;" tabindex="0"><mjx-math aria-hidden="true" class="MJX-TEX"><mjx-texatom texclass="ORD"><mjx-mfrac><mjx-frac><mjx-num><mjx-nstrut></mjx-nstrut><mjx-mn class="mjx-n" size="s"><mjx-c class="mjx-c33"></mjx-c></mjx-mn></mjx-num><mjx-dbox><mjx-dtable><mjx-line></mjx-line><mjx-row><mjx-den><mjx-dstrut></mjx-dstrut><mjx-mn class="mjx-n" size="s"><mjx-c class="mjx-c37"></mjx-c></mjx-mn></mjx-den></mjx-row></mjx-dtable></mjx-dbox></mjx-frac></mjx-mfrac></mjx-texatom></mjx-math><mjx-assistive-mml display="inline" unselectable="on"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow data-mjx-texclass="ORD"><mfrac><mn>3</mn><mn>7</mn></mfrac></mrow></math></mjx-assistive-mml></mjx-container> 특이도 = <mjx-container class="MathJax CtxtMenu_Attached_0" ctxtmenu_counter="6" jax="CHTML" style="font-size: 107.5%; position: relative;" tabindex="0"><mjx-math aria-hidden="true" class="MJX-TEX"><mjx-texatom texclass="ORD"><mjx-mfrac><mjx-frac><mjx-num><mjx-nstrut></mjx-nstrut><mjx-mn class="mjx-n" size="s"><mjx-c class="mjx-c31"></mjx-c></mjx-mn></mjx-num><mjx-dbox><mjx-dtable><mjx-line></mjx-line><mjx-row><mjx-den><mjx-dstrut></mjx-dstrut><mjx-mn class="mjx-n" size="s"><mjx-c class="mjx-c33"></mjx-c></mjx-mn></mjx-den></mjx-row></mjx-dtable></mjx-dbox></mjx-frac></mjx-mfrac></mjx-texatom></mjx-math><mjx-assistive-mml display="inline" unselectable="on"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow data-mjx-texclass="ORD"><mfrac><mn>1</mn><mn>3</mn></mfrac></mrow></math></mjx-assistive-mml></mjx-container> </span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			민감도 = <mjx-container class="MathJax CtxtMenu_Attached_0" ctxtmenu_counter="7" jax="CHTML" style="font-size: 107.5%; position: relative;" tabindex="0"><mjx-math aria-hidden="true" class="MJX-TEX"><mjx-texatom texclass="ORD"><mjx-mfrac><mjx-frac><mjx-num><mjx-nstrut></mjx-nstrut><mjx-mn class="mjx-n" size="s"><mjx-c class="mjx-c33"></mjx-c></mjx-mn></mjx-num><mjx-dbox><mjx-dtable><mjx-line></mjx-line><mjx-row><mjx-den><mjx-dstrut></mjx-dstrut><mjx-mn class="mjx-n" size="s"><mjx-c class="mjx-c35"></mjx-c></mjx-mn></mjx-den></mjx-row></mjx-dtable></mjx-dbox></mjx-frac></mjx-mfrac></mjx-texatom></mjx-math><mjx-assistive-mml display="inline" unselectable="on"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow data-mjx-texclass="ORD"><mfrac><mn>3</mn><mn>5</mn></mfrac></mrow></math></mjx-assistive-mml></mjx-container> 특이도 = <mjx-container class="MathJax CtxtMenu_Attached_0" ctxtmenu_counter="8" jax="CHTML" style="font-size: 107.5%; position: relative;" tabindex="0"><mjx-math aria-hidden="true" class="MJX-TEX"><mjx-texatom texclass="ORD"><mjx-mfrac><mjx-frac><mjx-num><mjx-nstrut></mjx-nstrut><mjx-mn class="mjx-n" size="s"><mjx-c class="mjx-c31"></mjx-c></mjx-mn></mjx-num><mjx-dbox><mjx-dtable><mjx-line></mjx-line><mjx-row><mjx-den><mjx-dstrut></mjx-dstrut><mjx-mn class="mjx-n" size="s"><mjx-c class="mjx-c33"></mjx-c></mjx-mn></mjx-den></mjx-row></mjx-dtable></mjx-dbox></mjx-frac></mjx-mfrac></mjx-texatom></mjx-math><mjx-assistive-mml display="inline" unselectable="on"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow data-mjx-texclass="ORD"><mfrac><mn>1</mn><mn>3</mn></mfrac></mrow></math></mjx-assistive-mml></mjx-container> </span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			민감도 = <mjx-container class="MathJax CtxtMenu_Attached_0" ctxtmenu_counter="9" jax="CHTML" style="font-size: 107.5%; position: relative;" tabindex="0"><mjx-math aria-hidden="true" class="MJX-TEX"><mjx-texatom texclass="ORD"><mjx-mfrac><mjx-frac><mjx-num><mjx-nstrut></mjx-nstrut><mjx-mn class="mjx-n" size="s"><mjx-c class="mjx-c34"></mjx-c></mjx-mn></mjx-num><mjx-dbox><mjx-dtable><mjx-line></mjx-line><mjx-row><mjx-den><mjx-dstrut></mjx-dstrut><mjx-mn class="mjx-n" size="s"><mjx-c class="mjx-c37"></mjx-c></mjx-mn></mjx-den></mjx-row></mjx-dtable></mjx-dbox></mjx-frac></mjx-mfrac></mjx-texatom></mjx-math><mjx-assistive-mml display="inline" unselectable="on"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow data-mjx-texclass="ORD"><mfrac><mn>4</mn><mn>7</mn></mfrac></mrow></math></mjx-assistive-mml></mjx-container> 특이도 = <mjx-container class="MathJax CtxtMenu_Attached_0" ctxtmenu_counter="10" jax="CHTML" style="font-size: 107.5%; position: relative;" tabindex="0"><mjx-math aria-hidden="true" class="MJX-TEX"><mjx-texatom texclass="ORD"><mjx-mfrac><mjx-frac><mjx-num><mjx-nstrut></mjx-nstrut><mjx-mn class="mjx-n" size="s"><mjx-c class="mjx-c32"></mjx-c></mjx-mn></mjx-num><mjx-dbox><mjx-dtable><mjx-line></mjx-line><mjx-row><mjx-den><mjx-dstrut></mjx-dstrut><mjx-mn class="mjx-n" size="s"><mjx-c class="mjx-c33"></mjx-c></mjx-mn></mjx-den></mjx-row></mjx-dtable></mjx-dbox></mjx-frac></mjx-mfrac></mjx-texatom></mjx-math><mjx-assistive-mml display="inline" unselectable="on"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow data-mjx-texclass="ORD"><mfrac><mn>2</mn><mn>3</mn></mfrac></mrow></math></mjx-assistive-mml></mjx-container> </span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			민감도 = <mjx-container class="MathJax CtxtMenu_Attached_0" ctxtmenu_counter="11" jax="CHTML" style="font-size: 107.5%; position: relative;" tabindex="0"><mjx-math aria-hidden="true" class="MJX-TEX"><mjx-texatom texclass="ORD"><mjx-mfrac><mjx-frac><mjx-num><mjx-nstrut></mjx-nstrut><mjx-mn class="mjx-n" size="s"><mjx-c class="mjx-c32"></mjx-c></mjx-mn></mjx-num><mjx-dbox><mjx-dtable><mjx-line></mjx-line><mjx-row><mjx-den><mjx-dstrut></mjx-dstrut><mjx-mn class="mjx-n" size="s"><mjx-c class="mjx-c35"></mjx-c></mjx-mn></mjx-den></mjx-row></mjx-dtable></mjx-dbox></mjx-frac></mjx-mfrac></mjx-texatom></mjx-math><mjx-assistive-mml display="inline" unselectable="on"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow data-mjx-texclass="ORD"><mfrac><mn>2</mn><mn>5</mn></mfrac></mrow></math></mjx-assistive-mml></mjx-container> 특이도 = <mjx-container class="MathJax CtxtMenu_Attached_0" ctxtmenu_counter="12" jax="CHTML" style="font-size: 107.5%; position: relative;" tabindex="0"><mjx-math aria-hidden="true" class="MJX-TEX"><mjx-texatom texclass="ORD"><mjx-mfrac><mjx-frac><mjx-num><mjx-nstrut></mjx-nstrut><mjx-mn class="mjx-n" size="s"><mjx-c class="mjx-c34"></mjx-c></mjx-mn></mjx-num><mjx-dbox><mjx-dtable><mjx-line></mjx-line><mjx-row><mjx-den><mjx-dstrut></mjx-dstrut><mjx-mn class="mjx-n" size="s"><mjx-c class="mjx-c35"></mjx-c></mjx-mn></mjx-den></mjx-row></mjx-dtable></mjx-dbox></mjx-frac></mjx-mfrac></mjx-texatom></mjx-math><mjx-assistive-mml display="inline" unselectable="on"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow data-mjx-texclass="ORD"><mfrac><mn>4</mn><mn>5</mn></mfrac></mrow></math></mjx-assistive-mml></mjx-container> </span></a></li>
</ol>
<div class="eg1">
<a class="b2 help" href="#m-help1a27" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
<span class="t1">정답보기</span>
<i class="ic1"></i>
</a>
</div>
<div class="tg2 loaded" id="m-help1a27" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
<strong class="tt1">정답</strong>
<div class="t2">
<i class="t2n">1</i>
<span class="t2t1">
			민감도 = <mjx-container class="MathJax CtxtMenu_Attached_0" ctxtmenu_counter="13" jax="CHTML" style="font-size: 113.1%; position: relative;" tabindex="0"><mjx-math aria-hidden="true" class="MJX-TEX"><mjx-texatom texclass="ORD"><mjx-mfrac><mjx-frac><mjx-num><mjx-nstrut></mjx-nstrut><mjx-mn class="mjx-n" size="s"><mjx-c class="mjx-c33"></mjx-c></mjx-mn></mjx-num><mjx-dbox><mjx-dtable><mjx-line></mjx-line><mjx-row><mjx-den><mjx-dstrut></mjx-dstrut><mjx-mn class="mjx-n" size="s"><mjx-c class="mjx-c37"></mjx-c></mjx-mn></mjx-den></mjx-row></mjx-dtable></mjx-dbox></mjx-frac></mjx-mfrac></mjx-texatom></mjx-math><mjx-assistive-mml display="inline" unselectable="on"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow data-mjx-texclass="ORD"><mfrac><mn>3</mn><mn>7</mn></mfrac></mrow></math></mjx-assistive-mml></mjx-container> 특이도 = <mjx-container class="MathJax CtxtMenu_Attached_0" ctxtmenu_counter="14" jax="CHTML" style="font-size: 113.1%; position: relative;" tabindex="0"><mjx-math aria-hidden="true" class="MJX-TEX"><mjx-texatom texclass="ORD"><mjx-mfrac><mjx-frac><mjx-num><mjx-nstrut></mjx-nstrut><mjx-mn class="mjx-n" size="s"><mjx-c class="mjx-c31"></mjx-c></mjx-mn></mjx-num><mjx-dbox><mjx-dtable><mjx-line></mjx-line><mjx-row><mjx-den><mjx-dstrut></mjx-dstrut><mjx-mn class="mjx-n" size="s"><mjx-c class="mjx-c33"></mjx-c></mjx-mn></mjx-den></mjx-row></mjx-dtable></mjx-dbox></mjx-frac></mjx-mfrac></mjx-texatom></mjx-math><mjx-assistive-mml display="inline" unselectable="on"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow data-mjx-texclass="ORD"><mfrac><mn>1</mn><mn>3</mn></mfrac></mrow></math></mjx-assistive-mml></mjx-container> </span>
</div>
<br/>
<strong class="tt1">해설</strong>
<div class="t1">
		민감도와 특이도를 구하면<br/>
민감도=<mjx-container class="MathJax CtxtMenu_Attached_0" ctxtmenu_counter="15" jax="CHTML" style="font-size: 113.1%; position: relative;" tabindex="0"><mjx-math aria-hidden="true" class="MJX-TEX"><mjx-texatom texclass="ORD"><mjx-mfrac><mjx-frac><mjx-num><mjx-nstrut></mjx-nstrut><mjx-mn class="mjx-n" size="s"><mjx-c class="mjx-c33"></mjx-c><mjx-c class="mjx-c30"></mjx-c></mjx-mn></mjx-num><mjx-dbox><mjx-dtable><mjx-line></mjx-line><mjx-row><mjx-den><mjx-dstrut></mjx-dstrut><mjx-mrow size="s"><mjx-mn class="mjx-n"><mjx-c class="mjx-c33"></mjx-c><mjx-c class="mjx-c30"></mjx-c></mjx-mn><mjx-mo class="mjx-n"><mjx-c class="mjx-c2B"></mjx-c></mjx-mo><mjx-mn class="mjx-n"><mjx-c class="mjx-c34"></mjx-c><mjx-c class="mjx-c30"></mjx-c></mjx-mn></mjx-mrow></mjx-den></mjx-row></mjx-dtable></mjx-dbox></mjx-frac></mjx-mfrac></mjx-texatom><mjx-mo class="mjx-n" space="4"><mjx-c class="mjx-c3D"></mjx-c></mjx-mo><mjx-texatom space="4" texclass="ORD"><mjx-mfrac><mjx-frac><mjx-num><mjx-nstrut></mjx-nstrut><mjx-mn class="mjx-n" size="s"><mjx-c class="mjx-c33"></mjx-c></mjx-mn></mjx-num><mjx-dbox><mjx-dtable><mjx-line></mjx-line><mjx-row><mjx-den><mjx-dstrut></mjx-dstrut><mjx-mn class="mjx-n" size="s"><mjx-c class="mjx-c37"></mjx-c></mjx-mn></mjx-den></mjx-row></mjx-dtable></mjx-dbox></mjx-frac></mjx-mfrac></mjx-texatom></mjx-math><mjx-assistive-mml display="inline" unselectable="on"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow data-mjx-texclass="ORD"><mfrac><mn>30</mn><mrow><mn>30</mn><mo>+</mo><mn>40</mn></mrow></mfrac></mrow><mo>=</mo><mrow data-mjx-texclass="ORD"><mfrac><mn>3</mn><mn>7</mn></mfrac></mrow></math></mjx-assistive-mml></mjx-container>, 특이도=<mjx-container class="MathJax CtxtMenu_Attached_0" ctxtmenu_counter="16" jax="CHTML" style="font-size: 113.1%; position: relative;" tabindex="0"><mjx-math aria-hidden="true" class="MJX-TEX"><mjx-texatom texclass="ORD"><mjx-mfrac><mjx-frac><mjx-num><mjx-nstrut></mjx-nstrut><mjx-mn class="mjx-n" size="s"><mjx-c class="mjx-c31"></mjx-c><mjx-c class="mjx-c30"></mjx-c></mjx-mn></mjx-num><mjx-dbox><mjx-dtable><mjx-line></mjx-line><mjx-row><mjx-den><mjx-dstrut></mjx-dstrut><mjx-mrow size="s"><mjx-mn class="mjx-n"><mjx-c class="mjx-c31"></mjx-c><mjx-c class="mjx-c30"></mjx-c></mjx-mn><mjx-mo class="mjx-n"><mjx-c class="mjx-c2B"></mjx-c></mjx-mo><mjx-mn class="mjx-n"><mjx-c class="mjx-c32"></mjx-c><mjx-c class="mjx-c30"></mjx-c></mjx-mn></mjx-mrow></mjx-den></mjx-row></mjx-dtable></mjx-dbox></mjx-frac></mjx-mfrac></mjx-texatom><mjx-mo class="mjx-n" space="4"><mjx-c class="mjx-c3D"></mjx-c></mjx-mo><mjx-texatom space="4" texclass="ORD"><mjx-mfrac><mjx-frac><mjx-num><mjx-nstrut></mjx-nstrut><mjx-mn class="mjx-n" size="s"><mjx-c class="mjx-c31"></mjx-c></mjx-mn></mjx-num><mjx-dbox><mjx-dtable><mjx-line></mjx-line><mjx-row><mjx-den><mjx-dstrut></mjx-dstrut><mjx-mn class="mjx-n" size="s"><mjx-c class="mjx-c33"></mjx-c></mjx-mn></mjx-den></mjx-row></mjx-dtable></mjx-dbox></mjx-frac></mjx-mfrac></mjx-texatom></mjx-math><mjx-assistive-mml display="inline" unselectable="on"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow data-mjx-texclass="ORD"><mfrac><mn>10</mn><mrow><mn>10</mn><mo>+</mo><mn>20</mn></mrow></mfrac></mrow><mo>=</mo><mrow data-mjx-texclass="ORD"><mfrac><mn>1</mn><mn>3</mn></mfrac></mrow></math></mjx-assistive-mml></mjx-container>과 같다.				</div>


<div class="more-c">
<strong class="tt1">비기봇 해설</strong>
<div class="t1">
				민감도(Sensitivity)와 특이도(Specificity)는 각각 진짜 양성 비율(TPR)과 진짜 음성 비율(TNR)을 나타내는 통계적 지표입니다. <br/>
<br/>
민감도는 실제로 질병이 있는 사람들 중에서 얼마나 많은 사람들이 양성으로 판정되었는지를 나타내며, 특이도는 실제로 질병이 없는 사람들 중에서 얼마나 많은 사람들이 음성으로 판정되었는지를 나타냅니다.<br/>
<br/>
이 문제에서 민감도는 실제 질병이 있는 사람들(확진결과 질병 유) 중 양성으로 판정된 사람들의 비율을 나타내므로, 30/(30+40) = 3/7이 됩니다.<br/>
<br/>
특이도는 실제 질병이 없는 사람들(확진결과 질병 무) 중 음성으로 판정된 사람들의 비율을 나타내므로, 10/(10+20) = 1/3이 됩니다.<br/>
<br/>
따라서, 민감도 = 3/7, 특이도 = 1/3으로 1번이 정답입니다.<br/>
</div>
<div class="t2">
									# ROC 커브									# 민감도									# 특이도									# 오분류표							</div>
</div>

</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
<div class="sg1">
<div class="w1">
<span class="g1">4과목</span>
<span class="g1">군집분석</span>
<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
</div>
</div>
<div class="tg1">
<strong class="tt1">
<span class="tt1n">28.</span>
<span class="tt1t1">
				R에서 인공신경망의 학습 및 추론을 위해 대표적으로 사용되는 함수는 neuralnet()이다. 다음 중 neuralnet 함수의 실행 결과로 도출되는 일반화 가중치(Generalized Weight)에 대한 설명으로 가장 적절한 것은?							</span>
</strong>
<span class="tt1t1">
</span>
</div>
<ol class="lst1">
<li class="li1"><a class="a1"><span class="t1">
			각 자료점의 분산이 로그-오즈(Log-Odds)에 미치는 기여도를 나타낸다. 					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			로지스틱 회귀모형에서의 회귀 계수와 유사하게 해석된다.					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			로지스틱 회귀와 달리 일반화 가중치는 전역적인 기여도를 나타낸다.					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			모든 자료에 대한 일반화 가중치의 분포는 가중치(Weight)에 대한 신뢰구간을 나타낸다.					</span></a></li>
</ol>
<div class="eg1">
<a class="b2 help" href="#m-help1a28" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
<span class="t1">정답보기</span>
<i class="ic1"></i>
</a>
</div>
<div class="tg2 loaded" id="m-help1a28" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
<strong class="tt1">정답</strong>
<div class="t2">
<i class="t2n">2</i>
<span class="t2t1">
			로지스틱 회귀모형에서의 회귀 계수와 유사하게 해석된다.			</span>
</div>
<br/>
<strong class="tt1">해설</strong>
<div class="t1">
		일반화 가중치(Generalized Weight)는 각 공변량의 영향을 표현하기 때문에 회귀모델에서 I번째 회귀 변수의 유사한 해석을 가진다.				</div>


<div class="more-c">
<strong class="tt1">비기봇 해설</strong>
<div class="t1">
				정답은 2번입니다.<br/>
<br/>
neuralnet 함수는 R에서 인공신경망을 구현할 때 사용되는 함수로, 학습된 모델의 가중치를 통해 입력 변수와 출력 변수 간의 관계를 설명합니다. 일반화 가중치(Generalized Weight)는 이러한 관계를 해석하는 데 중요한 역할을 합니다.<br/>
<br/>
1. 각 자료점의 분산이 로그-오즈(Log-Odds)에 미치는 기여도를 나타낸다.<br/>
: 일반화 가중치는 각 자료점의 분산이 아닌, 입력 변수의 변화가 출력에 미치는 영향을 나타냅니다. 따라서 분산과는 직접적인 관련이 없습니다.<br/>
<br/>
2. 로지스틱 회귀모형에서의 회귀 계수와 유사하게 해석된다.<br/>
: 일반화 가중치는 로지스틱 회귀모형의 회귀 계수와 유사하게 해석될 수 있습니다. 이는 입력 변수의 변화가 출력에 미치는 영향을 정량적으로 나타내기 때문입니다.<br/>
<br/>
3. 로지스틱 회귀와 달리 일반화 가중치는 전역적인 기여도를 나타낸다.<br/>
: 일반화 가중치는 특정 자료점에 대한 기여도를 나타내며, 전역적인 기여도를 나타내지는 않습니다. 이는 각 자료점마다 다르게 계산될 수 있습니다.<br/>
<br/>
4. 모든 자료에 대한 일반화 가중치의 분포는 가중치(Weight)에 대한 신뢰구간을 나타낸다.<br/>
: 일반화 가중치의 분포는 신뢰구간을 나타내지 않습니다. 신뢰구간은 통계적 추정의 불확실성을 나타내는 반면, 일반화 가중치는 모델의 학습 결과로 도출된 값입니다.<br/>
<br/>
<br/>
일반화 가중치는 로지스틱 회귀모형의 회귀 계수와 유사하게 해석됩니다. 이는 입력 변수의 변화가 출력에 미치는 영향을 정량적으로 나타내기 때문입니다. 다른 선택지들은 일반화 가중치의 정의나 역할과 맞지 않습니다.<br/>
<br/>
따라서, 정답은 '2. 로지스틱 회귀모형에서의 회귀 계수와 유사하게 해석된다.' 입니다.<br/>
</div>
<div class="t2">
									#neuralnet									# 일반화 가중치									# 로지스틱 회귀									# R							</div>
</div>

</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
<div class="sg1">
<div class="w1">
<span class="g1">4과목</span>
<span class="g1">군집분석</span>
<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
</div>
</div>
<div class="tg1">
<strong class="tt1">
<span class="tt1n">29.</span>
<span class="tt1t1">
				단층신경망인 퍼셉트론(perceptron)에서 최종 목표값(Target value)은 활성함수에 의해 결정되는데 다양한 활성함수 중 출력값이 여러 개로 주어지고, 목표치가 다범주인 경우 각 범주에 속할 사후확률을 제공하는 함수는 무엇인가?							</span>
</strong>
<span class="tt1t1">
</span>
</div>
<ol class="lst1">
<li class="li1"><a class="a1"><span class="t1">
			Tanh 함수					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			Gauss 함수					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			Sigmoid 함수					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			Softmax 함수					</span></a></li>
</ol>
<div class="eg1">
<a class="b2 help" href="#m-help1a29" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
<span class="t1">정답보기</span>
<i class="ic1"></i>
</a>
</div>
<div class="tg2 loaded" id="m-help1a29" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
<strong class="tt1">정답</strong>
<div class="t2">
<i class="t2n">4</i>
<span class="t2t1">
			Softmax 함수			</span>
</div>
<br/>
<strong class="tt1">해설</strong>
<div class="t1">
		활성함수는 Step, Sign, Sigmoid, Linear 등이 있고, 그 중 Softmax는 출력값이 여러 개로 주어지고 다범주의 사후확률을 제공한다.				</div>


<div class="more-c">
<strong class="tt1">비기봇 해설</strong>
<div class="t1">
				정답은 4번입니다.<br/>
<br/>
퍼셉트론은 인공신경망의 기본 단위로, 입력 신호의 가중치 합을 계산하여 활성화 함수를 통해 출력을 결정합니다. 활성화 함수는 입력 신호를 처리하여 출력 신호를 생성하는 역할을 하며, 다양한 유형이 존재합니다. 이 중 Softmax 함수는 출력값이 여러 개로 주어지고 목표치가 다범주인 경우 각 범주에 속할 사후확률을 제공하는 함수로, 다중 클래스 분류 문제에서 주로 사용됩니다. Softmax 함수는 각 클래스의 지수화된 점수를 전체 점수의 합으로 나누어 확률을 계산합니다.<br/>
<br/>
1. Tanh 함수 <br/>
: Tanh 함수는 하이퍼볼릭 탄젠트 함수로, 입력값을 -1에서 1 사이로 변환합니다. 이는 주로 이진 분류 문제에서 사용되며, 다범주 분류 문제에서 각 범주에 대한 확률을 제공하지 않습니다. 따라서 다범주 분류 문제에 적합하지 않습니다.<br/>
<br/>
2. Gauss 함수 <br/>
: Gauss 함수는 주로 가우시안 분포를 기반으로 한 함수로, 확률 밀도 함수의 형태를 가집니다. 이는 주로 데이터의 분포를 모델링하는 데 사용되며, 다범주 분류 문제에서 각 범주에 대한 확률을 제공하는 데 적합하지 않습니다.<br/>
<br/>
3. Sigmoid 함수 <br/>
: Sigmoid 함수는 입력값을 0과 1 사이의 값으로 변환하여 확률을 제공하는 함수입니다. 이는 이진 분류 문제에 적합하며, 다범주 분류 문제에서는 각 범주에 대한 개별 확률을 제공하지 못합니다.<br/>
<br/>
4. Softmax 함수 <br/>
: Softmax 함수는 다범주 분류 문제에서 각 범주에 속할 사후확률을 제공하는 함수입니다. 입력값을 지수화하여 전체 합으로 나누어 각 범주에 대한 확률을 계산합니다. 이는 다중 클래스 분류 문제에 적합한 활성화 함수입니다.<br/>
<br/>
Softmax 함수는 다범주 분류 문제에서 각 범주에 대한 확률을 제공하는 유일한 함수입니다. Tanh, Gauss, Sigmoid 함수는 각각 이진 분류나 특정 분포 모델링에 적합하며, 다범주 분류 문제에서 각 범주에 대한 확률을 제공하지 못합니다. 따라서 다범주 분류 문제에 적합한 함수는 Softmax입니다.<br/>
따라서, 정답은 '4. Softmax 함수' 입니다.<br/>
</div>
<div class="t2">
									#퍼셉트론									# 활성화 함수									# Softmax									# 다범주 분류									# 사후확률							</div>
</div>

</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
<div class="sg1">
<div class="w1">
<span class="g1">4과목</span>
<span class="g1">군집분석</span>
<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
</div>
</div>
<div class="tg1">
<strong class="tt1">
<span class="tt1n">30.</span>
<span class="tt1t1">
				신경망 모형은 자신이 가진 데이터로부터 반복적인 학습과정을 거처 패턴을 찾아내고 이를 일반화하는 예측방법이다. 다음 중 신경망 모형에 대한 설명을 부적절한 것은 무엇인가? 							</span>
</strong>
<span class="tt1t1">
</span>
</div>
<ol class="lst1">
<li class="li1"><a class="a1"><span class="t1">
			피드 포워드 신경망은 정보가 전방으로 전달되는 것으로 생물학적 신경계에서 나타나는 형태이며 딥러닝에서 가장 핵심적인 구조 개념이다.					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			은닉층의 뉴런 수와 개수는 신경망 모형에서 자동으로 설정된다. 					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			일반적으로 인공신경망은 다층 퍼셉트론을 의미한다. 다층 퍼셉트론에서 정보의 흐름은 입력층에서 시작하여 은닉층을 거쳐 출력층으로 진행된다.					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			역전파 알고리즘은 연결강도를 갱신하기 위해 예측된 결과와 실제값의 차이인 에러의 역전파를 통해  가중치를 구하는데서 시작되었다.					</span></a></li>
</ol>
<div class="eg1">
<a class="b2 help" href="#m-help1a30" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
<span class="t1">정답보기</span>
<i class="ic1"></i>
</a>
</div>
<div class="tg2 loaded" id="m-help1a30" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
<strong class="tt1">정답</strong>
<div class="t2">
<i class="t2n">2</i>
<span class="t2t1">
			은닉층의 뉴런 수와 개수는 신경망 모형에서 자동으로 설정된다. 			</span>
</div>
<br/>
<strong class="tt1">해설</strong>
<div class="t1">
		은닉층의 뉴런수와 개수는 신경망 모형에서 자동으로 설정되지 않으므로 직접 설정해야 한다.				</div>


<div class="more-c">
<strong class="tt1">비기봇 해설</strong>
<div class="t1">
				정답은 2번입니다.<br/>
<br/>
신경망 모형은 인공지능의 한 분야로, 데이터로부터 학습하여 패턴을 인식하고 예측하는 방법입니다. 신경망은 여러 층으로 구성되며, 각 층은 뉴런으로 이루어져 있습니다. 학습 과정에서 가중치가 조정되며, 이를 통해 모델이 데이터를 일반화할 수 있습니다.<br/>
<br/>
1. 피드 포워드 신경망은 정보가 전방으로 전달되는 것으로 생물학적 신경계에서 나타나는 형태이며 딥러닝에서 가장 핵심적인 구조 개념이다.<br/>
: 피드 포워드 신경망은 정보가 한 방향으로만 전달되는 구조로, 입력층에서 시작하여 은닉층을 거쳐 출력층으로 진행됩니다. 이는 생물학적 신경계의 정보 전달 방식과 유사하며, 딥러닝의 기본 구조입니다.<br/>
<br/>
2. 은닉층의 뉴런 수와 개수는 신경망 모형에서 자동으로 설정된다.<br/>
: 은닉층의 뉴런 수와 개수는 사용자가 설정하는 하이퍼파라미터입니다. 자동으로 설정되지 않으며, 모델의 성능에 큰 영향을 미치기 때문에 신중하게 선택해야 합니다.<br/>
<br/>
3. 일반적으로 인공신경망은 다층 퍼셉트론을 의미한다. 다층 퍼셉트론에서 정보의 흐름은 입력층에서 시작하여 은닉층을 거쳐 출력층으로 진행된다.<br/>
: 다층 퍼셉트론은 인공신경망의 한 형태로, 여러 개의 은닉층을 통해 입력 데이터를 처리합니다. 정보는 입력층에서 시작하여 은닉층을 거쳐 출력층으로 전달됩니다.<br/>
<br/>
4. 역전파 알고리즘은 연결강도를 갱신하기 위해 예측된 결과와 실제값의 차이인 에러의 역전파를 통해  가중치를 구하는데서 시작되었다.<br/>
: 역전파 알고리즘은 신경망의 학습 과정에서 사용되는 방법으로, 예측값과 실제값의 차이를 기반으로 가중치를 조정합니다. 이를 통해 모델의 예측 성능을 향상시킵니다.<br/>
<br/>
<br/>
은닉층의 뉴런 수와 개수는 자동으로 설정되지 않으며, 사용자가 직접 설정해야 하는 하이퍼파라미터입니다. 따라서 2번 선지가 부적절한 설명입니다. 다른 선택지들은 신경망 모형에 대한 올바른 설명을 제공하고 있습니다.<br/>
<br/>
따라서, 정답은 '2. 은닉층의 뉴런 수와 개수는 신경망 모형에서 자동으로 설정된다.' 입니다.<br/>
</div>
<div class="t2">
									#신경망									# 피드 포워드									# 은닉층									# 역전파							</div>
</div>

</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
<div class="sg1">
<div class="w1">
<span class="g1">4과목</span>
<span class="g1">군집분석</span>
<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
</div>
</div>
<div class="tg1">
<strong class="tt1">
<span class="tt1n">31.</span>
<span class="tt1t1">
				신경망 모형은 동물의 뇌신경계를 모방하여 분류를 위해 만들어진 모형이다. 신경망의 학습 및 기억 특성들은 인간의 학습과 기억 특성을 닮았고 특정 사건으로부터 일반화하는 능력도 갖고 있다. 다음 중 신경망 모형에 대한 설명으로 부적절한 것은?							</span>
</strong>
<span class="tt1t1">
</span>
</div>
<ol class="lst1">
<li class="li1"><a class="a1"><span class="t1">
			은닉층(Hidden Layer)의 뉴런 수와 개수를 정하는 것은 신경망을 설계하는 사람의 직관과 경험에 의존한다. 뉴런수가 너무 많으면 과적합(Overfitting)이 발생하고 뉴런 수가 너무 적으면 입력 데이터를 충분히 표현하지 못하는 경우가 발생한다.					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			신경망 모형에서 뉴런의 주요 기능은 입력과 입력 강도의 가중합을 구한 다음 활성화 함수에 의해 출력을 내보내는 것이다. 따라서 입력 변수의 속성에 따라 활성화 함수를 선택하는 방법이 달라지게 된다.					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			역전파(Back Propagation) 알고리즘은 신경망 모형의 목적함수를 최적화하기 위해 사용된다. 연결강도를 갱신하기 위해서 예측된 결과와 실제값의 차이인 에러(Error)를 통해 가중치를 조정하는 방법이다.					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			신경망 모형은 변수의 수가 많거나 입출력 변수 간에 복잡한 비선형관계가 존재할 때 유용하며, 잡음에 대해서도 민감하게 반응하지 않는다는 장점을 가지고 있다.					</span></a></li>
</ol>
<div class="eg1">
<a class="b2 help" href="#m-help1a31" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
<span class="t1">정답보기</span>
<i class="ic1"></i>
</a>
</div>
<div class="tg2 loaded" id="m-help1a31" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
<strong class="tt1">정답</strong>
<div class="t2">
<i class="t2n">2</i>
<span class="t2t1">
			신경망 모형에서 뉴런의 주요 기능은 입력과 입력 강도의 가중합을 구한 다음 활성화 함수에 의해 출력을 내보내는 것이다. 따라서 입력 변수의 속성에 따라 활성화 함수를 선택하는 방법이 달라지게 된다.			</span>
</div>
<br/>
<strong class="tt1">해설</strong>
<div class="t1">
		뉴런은 활성화 함수를 이용해 출력을 결정하며 입력신호의 가중치 합을 계산하여 임계값과 비교한다. 입력변수의 속성에 따라 활성화 함수를 선택하지 않는다.				</div>


<div class="more-c">
<strong class="tt1">비기봇 해설</strong>
<div class="t1">
				1. 은닉층(Hidden Layer)의 뉴런 수와 개수를 정하는 것은 신경망을 설계하는 사람의 직관과 경험에 의존합니다. 뉴런 수가 너무 많으면 과적합(Overfitting)이 발생하고, 뉴런 수가 너무 적으면 입력 데이터를 충분히 표현하지 못하는 경우가 발생할 수 있습니다.<br/>
<br/>
2. 신경망 모형에서 뉴런의 주요 기능은 입력과 입력 강도의 가중합을 구한 다음 활성화 함수에 의해 출력을 내보내는 것이 맞습니다. 하지만 활성화 함수의 선택은 입력 변수의 속성에 따라 달라지는 것이 아니라, 신경망 모형의 성능을 최적화하기 위해 선택되는 것입니다.<br/>
<br/>
3. 역전파(Back Propagation) 알고리즘은 신경망 모형의 목적함수를 최적화하기 위해 사용됩니다. 연결강도를 갱신하기 위해서 예측된 결과와 실제값의 차이인 에러(Error)를 통해 가중치를 조정하는 방법입니다.<br/>
<br/>
4. 신경망 모형은 변수의 수가 많거나 입출력 변수 간에 복잡한 비선형관계가 존재할 때 유용하며, 잡음에 대해서도 민감하게 반응하지 않는다는 장점을 가지고 있습니다.<br/>
</div>
<div class="t2">
									#신경망 모형									# 은닝층									# 역전파 알고리즘									# 복잡한 비선형 관계							</div>
</div>

</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
<div class="sg1">
<div class="w1">
<span class="g1">4과목</span>
<span class="g1">고급회귀분석</span>
<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
</div>
</div>
<div class="tg1">
<strong class="tt1">
<span class="tt1n">32.</span>
<span class="tt1t1">
				다음 중 로지스틱 회귀모형에서 설명 변수가 한 개인 경우 해당 회귀 계수의 부호가 0보다 작을 때 표현되는 그래프의 형태로 적절한 것은?							</span>
</strong>
<span class="tt1t1">
</span>
</div>
<ol class="lst1">
<li class="li1"><a class="a1"><span class="t1">
			S자 그래프					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			양의 선형 그래프					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			역 S자 그래프					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			음의 선형 그래프					</span></a></li>
</ol>
<div class="eg1">
<a class="b2 help" href="#m-help1a32" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
<span class="t1">정답보기</span>
<i class="ic1"></i>
</a>
</div>
<div class="tg2 loaded" id="m-help1a32" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
<strong class="tt1">정답</strong>
<div class="t2">
<i class="t2n">3</i>
<span class="t2t1">
			역 S자 그래프			</span>
</div>
<br/>
<strong class="tt1">해설</strong>
<div class="t1">
		로지스틱 회귀모형에서 설명 변수가 한 개인 경우 해당 회귀 계수의 부호가 0보다 작을 때는 역 S자 그래프가 그려진다.				</div>


<div class="more-c">
<strong class="tt1">비기봇 해설</strong>
<div class="t1">
				정답은 3번입니다.<br/>
<br/>
로지스틱 회귀모형에서 설명 변수의 회귀 계수는 그래프의 형태에 영향을 미칩니다. 회귀 계수가 0보다 작으면 그래프는 특정한 형태를 띠게 됩니다.<br/>
<br/>
1. S자 그래프<br/>
: 로지스틱 회귀모형의 기본 형태는 S자 곡선입니다. 이는 회귀 계수가 양수일 때 나타나는 형태입니다.<br/>
<br/>
2. 양의 선형 그래프<br/>
: 양의 선형 그래프는 회귀 계수가 양수인 경우에 나타나며, 이는 로지스틱 회귀의 특성과는 맞지 않습니다.<br/>
<br/>
3. 역 S자 그래프<br/>
: 역 S자 그래프는 회귀 계수가 음수일 때 나타나는 형태로, 로지스틱 회귀모형에서 설명 변수가 한 개인 경우에 해당합니다.<br/>
<br/>
4. 음의 선형 그래프<br/>
: 음의 선형 그래프는 회귀 계수가 음수인 경우에 나타날 수 있지만, 이는 로지스틱 회귀의 비선형 특성과는 맞지 않습니다.<br/>
<br/>
<br/>
로지스틱 회귀모형에서 설명 변수의 회귀 계수가 음수일 경우, 그래프는 역 S자 형태를 띠게 됩니다. 이는 로지스틱 함수의 특성상, 회귀 계수가 음수일 때 그래프가 반전되어 나타나기 때문입니다. 다른 선택지들은 로지스틱 회귀의 특성과 맞지 않거나, 회귀 계수가 양수일 때 나타나는 형태입니다.<br/>
<br/>
따라서, 정답은 '3. 역 S자 그래프' 입니다.<br/>
</div>
<div class="t2">
									#로지스틱 회귀									# 회귀 계수									# 그래프 형태									# 역 S자							</div>
</div>

</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
<div class="sg1">
<div class="w1">
<span class="g1">4과목</span>
<span class="g1">고급회귀분석</span>
<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
</div>
</div>
<div class="tg1">
<strong class="tt1">
<span class="tt1n">33.</span>
<span class="tt1t1">
				로지스틱 회귀모형은 독립변수(x)와 종속변수(y) 사이의 관계를 설명하는 모형으로서 종속변수가 범주형(y=0 또는 y=1)값을 갖는 경우에 사용하는 방법이다. 다음 중 로지스틱 회귀모형에 대한 설명으로 가장 부적절한 것은?							</span>
</strong>
<span class="tt1t1">
</span>
</div>
<ol class="lst1">
<li class="li1"><a class="a1"><span class="t1">
			이러한 데이터에 대해 선형회귀모형을 적용하는 것이 기술적으로 가능하지만, 선형회귀의 문제점은 0 이하의 값이나 1 이상의 값을 예측값으로 줄 수 있다는 것이며 따라서 이를 확률값으로 직접 해석할 수 없다.					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			로지스틱 회귀모형은 클래스가 알려진 데이터의 설명변수들 관점에서 각 클래스 내의 관측치들에 대한 유사성을 찾는데 사용할 수 있다.					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			종속변수 y 대신 로짓(Logit)이라 불리는 상수를 사용하여 로짓을 설명변수들의 선형함수로 모형화하기 때문에 이 모형을 로지스틱 회귀모형이라고 한다.					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			Odds(오즈)란 클래스 0에 속할 확률(1-p)이 클래스 1에 속할 확률 p의 비로 나타낸다. 즉, Odds = p/(1-p)로 나타낸다.					</span></a></li>
</ol>
<div class="eg1">
<a class="b2 help" href="#m-help1a33" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
<span class="t1">정답보기</span>
<i class="ic1"></i>
</a>
</div>
<div class="tg2 loaded" id="m-help1a33" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
<strong class="tt1">정답</strong>
<div class="t2">
<i class="t2n">3</i>
<span class="t2t1">
			종속변수 y 대신 로짓(Logit)이라 불리는 상수를 사용하여 로짓을 설명변수들의 선형함수로 모형화하기 때문에 이 모형을 로지스틱 회귀모형이라고 한다.			</span>
</div>
<br/>
<strong class="tt1">해설</strong>
<div class="t1">
		종속변수 y 대신 로짓(Logit)이라 불리는 상수를 사용하는 것이 아니라 y의 값 범위를 [0, 1]로 조정하기 위하여 로짓(Logit)변환을 사용한다.				</div>


<div class="more-c">
<strong class="tt1">비기봇 해설</strong>
<div class="t1">
				로지스틱 회귀모형은 종속변수 y 대신 로짓(Logit)이라 불리는 상수를 사용하는 것이 아니라, 종속변수 y의 로짓 변환을 설명변수들의 선형함수로 모형화한다. 따라서 3번 설명이 부적절하다.<br/>
<br/>
1번: 선형회귀모형은 0 이하나 1 이상의 값을 예측값으로 줄 수 있기 때문에 범주형 데이터에 적합하지 않다. 이에 반해 로지스틱 회귀모형은 0과 1 사이의 확률값을 예측하므로 범주형 데이터에 적합하다.<br/>
<br/>
2번: 로지스틱 회귀모형은 클래스가 알려진 데이터의 설명변수들 관점에서 각 클래스 내의 관측치들에 대한 유사성을 찾는데 사용할 수 있다. 이는 로지스틱 회귀모형의 주요한 사용 방법 중 하나이다.<br/>
<br/>
4번: 로지스틱 회귀모형에서는 오즈(Odds)를 사용하여 클래스 0에 속할 확률과 클래스 1에 속할 확률의 비를 나타낸다. 이는 로지스틱 회귀모형의 핵심 개념 중 하나이다.<br/>
</div>
<div class="t2">
									# 로지스틱 회귀모형									# 선형회귀모형									# 범주형 데이터									# 로짓(Logit)									# 오즈(Odds)							</div>
</div>

</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
<div class="sg1">
<div class="w1">
<span class="g1">4과목</span>
<span class="g1">고급회귀분석</span>
<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
</div>
</div>
<div class="tg1">
<strong class="tt1">
<span class="tt1n">34.</span>
<span class="tt1t1">
				College 데이터는 777개의 미국 대학의 각종 통계치를 포함한다. 각 대학에 재학하는 비용이 졸업률(grade Rate)에 미치는 영향을 알아보기 위해 사립학교 여부(Private), 고교성적 상위 10% 학생비율(Top10perc), 등록금(Outstate), 기타지출(Expend)을 활용하기로 했다. 다음 중 아래의 결과물에 대한 설명으로 적절하지 않은 것은 무엇인가?							</span>
</strong>
<span class="tt1t1">
<a class="p1" href="exam1view1img1.php?img=42957c72-a1fe-5061-d4b3-a02e6ca4294a.png" rel="noopener" target="_blank" title="새 창">
<img alt="문제에 포함된 이미지" src="https://www.dataedupt.kr/data/img/question/42957c72-a1fe-5061-d4b3-a02e6ca4294a.png"/>
</a>
</span>
</div>
<ol class="lst1">
<li class="li1"><a class="a1"><span class="t1">
			Outstates 변수는 졸업률에 유의한 영향을 미치는 변수이다. 					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			고교성적 상위 10% 학생의 비율이 높을수록 졸업률이 높다.					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			다른 설명변수의 조건이 동일할 때 사립학교(Private Yes)의 경우 공립학교(Private No)에 비해 졸업률이 낮다.					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			위의 모형은 유의수준 5% 하에서 유의하다.					</span></a></li>
</ol>
<div class="eg1">
<a class="b2 help" href="#m-help1a34" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
<span class="t1">정답보기</span>
<i class="ic1"></i>
</a>
</div>
<div class="tg2 loaded" id="m-help1a34" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
<strong class="tt1">정답</strong>
<div class="t2">
<i class="t2n">3</i>
<span class="t2t1">
			다른 설명변수의 조건이 동일할 때 사립학교(Private Yes)의 경우 공립학교(Private No)에 비해 졸업률이 낮다.			</span>
</div>
<br/>
<strong class="tt1">해설</strong>
<div class="t1">
		회귀분석 결과에서 PrivateYes 변수의 회귀계수가 2.913으로 높게 나타나므로 PrivateYes일 경우 졸업률이 높게 나타날 것이다.				</div>


<div class="more-c">
<strong class="tt1">비기봇 해설</strong>
<div class="t1">
				1. Outstate 변수는 졸업률에 유의한 영향을 미치는 변수이다. <br/>
- 이 설명은 맞습니다. Outstate의 p-value가 2e-16으로 0에 가깝기 때문에, 이 변수는 졸업률에 유의한 영향을 미칩니다. <br/>
<br/>
2. 고교성적 상위 10% 학생의 비율이 높을수록 졸업률이 높다.<br/>
- 이 설명도 맞습니다. Top10perc의 계수가 0.3209807로 양수이므로, 고교성적 상위 10% 학생의 비율이 높을수록 졸업률이 높습니다.<br/>
<br/>
3. 다른 설명변수의 조건이 동일할 때 사립학교(Private Yes)의 경우 공립학교(Private No)에 비해 졸업률이 낮다.<br/>
- 이 설명은 틀립니다. PrivateYes의 계수가 2.9131163으로 양수이므로, 다른 변수들이 동일할 때 사립학교의 졸업률이 공립학교보다 높습니다.<br/>
<br/>
4. 위의 모형은 유의수준 5% 하에서 유의하다.<br/>
- 이 설명도 맞습니다. 모델의 F-statistic의 p-value가 2.2e-16으로 0에 가깝기 때문에, 이 모델은 유의수준 5% 하에서 유의합니다.<br/>
</div>
<div class="t2">
									# 회귀분석									# R프로그램 결과 해석							</div>
</div>

</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
<div class="sg1">
<div class="w1">
<span class="g1">4과목</span>
<span class="g1">고급회귀분석</span>
<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
</div>
</div>
<div class="tg1">
<strong class="tt1">
<span class="tt1n">35.</span>
<span class="tt1t1">
				Default 데이터셋은 10000명의 신용카드 고객에 대한 카드대금 연체여부(default=Yes/No), 카드 대금납입 후 남은 평균 카드잔고(Balance), 연봉(Income), 학생여부(student=Yes/No)를 포함한다. 아래는 연체 가능성을 모형화하기 위한 로지스틱 회귀분석 결과이다. 다음 중 유의수준 0.05하에서 아래에 대한 설명으로 가장 부적절한 것은?							</span>
</strong>
<span class="tt1t1">
<a class="p1" href="exam1view1img1.php?img=e9ea910c-fb3a-fcc2-3a89-222cd916950f.png" rel="noopener" target="_blank" title="새 창">
<img alt="문제에 포함된 이미지" src="https://www.dataedupt.kr/data/img/question/e9ea910c-fb3a-fcc2-3a89-222cd916950f.png"/>
</a>
</span>
</div>
<ol class="lst1">
<li class="li1"><a class="a1"><span class="t1">
			balance는 default를 설명하는 데 통계적으로 유의하다.					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			income는 default를 설명하는 데 통계적으로 유의하다.					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			student는 default를 설명하는 데 통계적으로 유의하다.					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			balance는 income이 동일할 때 학생일수록 default 가능성이 낮다.					</span></a></li>
</ol>
<div class="eg1">
<a class="b2 help" href="#m-help1a35" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
<span class="t1">정답보기</span>
<i class="ic1"></i>
</a>
</div>
<div class="tg2 loaded" id="m-help1a35" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
<strong class="tt1">정답</strong>
<div class="t2">
<i class="t2n">2</i>
<span class="t2t1">
			income는 default를 설명하는 데 통계적으로 유의하다.			</span>
</div>
<br/>
<strong class="tt1">해설</strong>
<div class="t1">
		income은 p-value 값이 0.71152로 나타나 default를 설명하는데 통계적으로 유의하지 않게 나타나고 있다. 				</div>


<div class="more-c">
<strong class="tt1">비기봇 해설</strong>
<div class="t1">
				1번 문항: balance의 p-value는 &lt; 2e-16으로, 유의수준 0.05보다 작으므로 balance는 default를 설명하는 데 통계적으로 유의합니다.<br/>
<br/>
2번 문항: income의 p-value는 0.71152로, 유의수준 0.05보다 크므로 income은 default를 설명하는 데 통계적으로 유의하지 않습니다.<br/>
<br/>
3번 문항: student의 p-value는 0.00619로, 유의수준 0.05보다 작으므로 student는 default를 설명하는 데 통계적으로 유의합니다.<br/>
<br/>
4번 문항: balance의 계수는 양수(5.737e-03)이고, studentYes의 계수는 음수(-6.468e-01)입니다. 이는 balance가 증가할수록 default 가능성이 높아지고, 학생일 경우 default 가능성이 낮아짐을 의미합니다. 따라서 balance가 동일할 때(고정되어있을 때) 학생일수록 default 가능성이 낮다는 설명은 적절합니다.<br/>
</div>
<div class="t2">
									# 로지스틱 회귀분석									# 유의수준									# p-value									# 통계적 유의성									# r프로그램 결과해석							</div>
</div>

</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
<div class="sg1">
<div class="w1">
<span class="g1">4과목</span>
<span class="g1">연관분석</span>
<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
</div>
</div>
<div class="tg1">
<strong class="tt1">
<span class="tt1n">36.</span>
<span class="tt1t1">
				계층적 군집분석을 위해 거리 계산을 수행할 때 사용하는 dist 함수에서 지원하는 거리 측도로 부적절한 것은?							</span>
</strong>
<span class="tt1t1">
</span>
</div>
<ol class="lst1">
<li class="li1"><a class="a1"><span class="t1">
			minkowski					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			cosine					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			binary					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			canberra					</span></a></li>
</ol>
<div class="eg1">
<a class="b2 help" href="#m-help1a36" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
<span class="t1">정답보기</span>
<i class="ic1"></i>
</a>
</div>
<div class="tg2 loaded" id="m-help1a36" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
<strong class="tt1">정답</strong>
<div class="t2">
<i class="t2n">2</i>
<span class="t2t1">
			cosine			</span>
</div>
<br/>
<strong class="tt1">해설</strong>
<div class="t1">
		군집분석에서 거리계산을 수행할 때 사용하는 dist 함수에서 지원하는 거리 측도에는 유클리디안 거리, 표준화 거리, 마할라노비스 거리, 체비셰프 거리, 맨하탄 거리, 캔버라 거리, 민코우스키 거리가 있다.				</div>


<div class="more-c">
<strong class="tt1">비기봇 해설</strong>
<div class="t1">
				정답은 2번입니다.<br/>
<br/>
계층적 군집분석에서 거리 계산은 데이터 간의 유사성을 측정하여 군집을 형성하는 데 중요한 역할을 합니다. 이를 위해 다양한 거리 측도가 사용되며, 각 거리 측도는 데이터의 특성과 분석 목적에 따라 선택됩니다. 유클리디안 거리, 맨하탄 거리, 캔버라 거리, 민코우스키 거리 등은 일반적으로 사용되는 거리 측도입니다. 이들은 각각의 수학적 정의와 특성에 따라 데이터 간의 차이를 측정합니다. 예를 들어, 유클리디안 거리는 두 점 사이의 직선 거리를 측정하며, 맨하탄 거리는 격자형 도시에서의 이동 거리처럼 축을 따라 이동하는 거리를 측정합니다. 캔버라 거리는 두 벡터의 차이를 각 벡터의 합으로 나누어 계산하며, 민코우스키 거리는 유클리디안 거리와 맨하탄 거리의 일반화된 형태로, 다양한 차원에서의 거리를 측정할 수 있습니다.<br/>
<br/>
1. minkowski <br/>
: 민코우스키 거리는 유클리디안 거리와 맨하탄 거리의 일반화된 형태로, p-노름을 사용하여 다양한 차원에서의 거리를 측정할 수 있습니다. 이는 다양한 거리 계산에 유연하게 적용될 수 있어 군집분석에서 자주 사용됩니다.<br/>
<br/>
2. cosine <br/>
: 코사인 유사도는 두 벡터 간의 각도를 측정하여 유사성을 평가하는 방법으로, 주로 텍스트 데이터의 유사성을 측정하는 데 사용됩니다. 이는 거리 측도라기보다는 유사도 측정 방법에 가깝기 때문에, 거리 계산을 위한 dist 함수에서는 일반적으로 지원되지 않습니다.<br/>
<br/>
3. binary <br/>
: 바이너리 거리는 이진 데이터 간의 유사성을 측정하는 방법으로, 두 벡터 간의 일치 여부를 기반으로 거리를 계산합니다. 이는 이진 데이터의 특성을 반영하여 군집분석에 사용될 수 있습니다.<br/>
<br/>
4. canberra <br/>
: 캔버라 거리는 두 벡터의 차이를 각 벡터의 합으로 나누어 계산하는 방식으로, 데이터의 크기 차이를 반영하여 거리 계산을 수행합니다. 이는 데이터의 상대적 차이를 강조하는 데 유용합니다.<br/>
<br/>
코사인 유사도는 거리 측도가 아니라 유사도 측정 방법으로, 두 벡터 간의 각도를 기반으로 유사성을 평가합니다. 따라서 거리 계산을 위한 dist 함수에서는 일반적으로 지원되지 않습니다. 반면, 민코우스키, 바이너리, 캔버라 거리는 모두 거리 측도로서 dist 함수에서 지원됩니다.<br/>
따라서, 정답은 '2. cosine' 입니다.<br/>
</div>
<div class="t2">
									#계층적 군집분석									# 거리 계산									# 민코우스키 거리									# 코사인 유사도									# 바이너리 거리									# 캔버라 거리							</div>
</div>

</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
<div class="sg1">
<div class="w1">
<span class="g1">4과목</span>
<span class="g1">연관분석</span>
<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
</div>
</div>
<div class="tg1">
<strong class="tt1">
<span class="tt1n">37.</span>
<span class="tt1t1">
				계층적 군집 방법은 n개의 군집으로 시작해 점차 군집의 개수를 줄여나가는 방법이다. 다음 중 계층적 군집 분석 결과를 나타내는 도표로 가장 적절한 것은?							</span>
</strong>
<span class="tt1t1">
</span>
</div>
<ol class="lst1">
<li class="li1"><a class="a1"><span class="t1">
			향상도 곡선 					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			ROC 그래프 					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			덴드로그램 					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			산점도					</span></a></li>
</ol>
<div class="eg1">
<a class="b2 help" href="#m-help1a37" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
<span class="t1">정답보기</span>
<i class="ic1"></i>
</a>
</div>
<div class="tg2 loaded" id="m-help1a37" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
<strong class="tt1">정답</strong>
<div class="t2">
<i class="t2n">3</i>
<span class="t2t1">
			덴드로그램 			</span>
</div>
<br/>
<strong class="tt1">해설</strong>
<div class="t1">
		덴드로그램은 ‘무슨 군집과 무슨 군집이 서로 묶였는지’, ‘어떤 순서와 차례대로 묶여갔는지’, ‘군집 간 거리는 얼마나 되는지’를 알 수 있는 그래프이다.				</div>


<div class="more-c">
<strong class="tt1">비기봇 해설</strong>
<div class="t1">
				정답은 3번입니다.<br/>
<br/>
계층적 군집 방법은 데이터 포인트를 군집으로 묶는 방법 중 하나로, 처음에는 각 데이터 포인트를 개별 군집으로 시작하여 점차적으로 군집을 합쳐나가는 방식입니다. 이 과정은 덴드로그램이라는 도표로 시각화할 수 있습니다. 덴드로그램은 군집 간의 유사성을 시각적으로 표현하여, 군집의 형성과정을 쉽게 이해할 수 있도록 돕습니다.<br/>
<br/>
1. 향상도 곡선<br/>
: 향상도 곡선은 모델의 성능을 평가하는 데 사용되는 도구로, 군집 분석과는 관련이 없습니다.<br/>
<br/>
2. ROC 그래프<br/>
: ROC 그래프는 이진 분류 문제에서 모델의 성능을 평가하는 데 사용되며, 군집 분석의 결과를 나타내는 도표가 아닙니다.<br/>
<br/>
3. 덴드로그램<br/>
: 덴드로그램은 계층적 군집 분석의 결과를 시각적으로 표현하는 도표로, 군집 간의 유사성을 나타내는 데 사용됩니다.<br/>
<br/>
4. 산점도<br/>
: 산점도는 데이터의 분포를 시각화하는 데 사용되며, 군집 분석의 결과를 나타내는 도표가 아닙니다.<br/>
<br/>
<br/>
덴드로그램은 계층적 군집 분석의 결과를 나타내는 도표로, 군집 간의 유사성을 시각적으로 표현합니다. 다른 선택지들은 군집 분석의 결과를 나타내는 도표가 아니므로 정답이 될 수 없습니다.<br/>
<br/>
따라서, 정답은 '3. 덴드로그램' 입니다.<br/>
</div>
<div class="t2">
									#계층적 군집									# 덴드로그램									# 군집 분석									# 시각화							</div>
</div>

</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
<div class="sg1">
<div class="w1">
<span class="g1">4과목</span>
<span class="g1">연관분석</span>
<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
</div>
</div>
<div class="tg1">
<strong class="tt1">
<span class="tt1n">38.</span>
<span class="tt1t1">
				150개의 식물 개체를 4개의 변수(꽃받침 길이, 꽃받침 폭, 꽃잎 길이, 꽃잎 폭)로 측정한 데이터를 사용하여 3개의 식물 군으로 구분하려 한다. 이 때 사용 가능한 분석 방법으로 적절한 것은 무엇인가?							</span>
</strong>
<span class="tt1t1">
</span>
</div>
<ol class="lst1">
<li class="li1"><a class="a1"><span class="t1">
			회귀분석(Regression)					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			시계열분석(Time series Analysis)					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			군집분석(Cluster Analysis) 					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			연관분석(Association Analysis)					</span></a></li>
</ol>
<div class="eg1">
<a class="b2 help" href="#m-help1a38" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
<span class="t1">정답보기</span>
<i class="ic1"></i>
</a>
</div>
<div class="tg2 loaded" id="m-help1a38" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
<strong class="tt1">정답</strong>
<div class="t2">
<i class="t2n">3</i>
<span class="t2t1">
			군집분석(Cluster Analysis) 			</span>
</div>
<br/>
<strong class="tt1">해설</strong>
<div class="t1">
		군집분석이란 각 객체의 유사성을 측정하여 유사성이 높은 대상 집단을 분류하는 분석 방법이다.				</div>


<div class="more-c">
<strong class="tt1">비기봇 해설</strong>
<div class="t1">
				정답은 3번입니다.<br/>
<br/>
이 문제는 주어진 데이터를 기반으로 여러 개체를 그룹으로 나누는 방법을 찾는 것입니다. 주어진 변수들을 사용하여 데이터를 군집화하는 것이 목표입니다.<br/>
<br/>
1. 회귀분석(Regression)<br/>
: 회귀분석은 종속 변수와 하나 이상의 독립 변수 간의 관계를 모델링하는 데 사용됩니다. 이는 데이터를 그룹으로 나누는 데 적합하지 않습니다.<br/>
<br/>
2. 시계열분석(Time series Analysis)<br/>
: 시계열분석은 시간에 따른 데이터의 변화를 분석하는 방법으로, 시간의 흐름에 따른 패턴을 찾는 데 사용됩니다. 이는 군집화와는 관련이 없습니다.<br/>
<br/>
3. 군집분석(Cluster Analysis)<br/>
: 군집분석은 데이터를 유사한 특성을 가진 그룹으로 나누는 방법입니다. 이는 주어진 문제에서 요구하는 데이터의 군집화에 적합한 방법입니다.<br/>
<br/>
4. 연관분석(Association Analysis)<br/>
: 연관분석은 주로 데이터베이스에서 항목 간의 연관성을 찾는 데 사용됩니다. 이는 데이터를 그룹으로 나누는 데 적합하지 않습니다.<br/>
<br/>
<br/>
군집분석은 데이터를 유사한 특성을 가진 그룹으로 나누는 데 사용되므로, 주어진 문제에서 요구하는 3개의 식물 군으로 데이터를 구분하는 데 적합합니다. 다른 선택지들은 각각 회귀, 시계열, 연관성을 분석하는 방법으로, 군집화와는 관련이 없습니다.<br/>
<br/>
따라서, 정답은 '3. 군집분석(Cluster Analysis)' 입니다.<br/>
</div>
<div class="t2">
									#군집분석									# 데이터 군집화									# 변수									# 식물 군							</div>
</div>

</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
<div class="sg1">
<div class="w1">
<span class="g1">4과목</span>
<span class="g1">연관분석</span>
<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
</div>
</div>
<div class="tg1">
<strong class="tt1">
<span class="tt1n">39.</span>
<span class="tt1t1">
				계층적 군집분석 수행 시 두 군집을 병합하는 방법 가운데 병합된 군집의 오차제곱합이 병합 이전 군집의 오차제곱합의 합에 비해 증가한 정도가 작아지는 방향으로 군집을 형성하는 방법은?							</span>
</strong>
<span class="tt1t1">
</span>
</div>
<ol class="lst1">
<li class="li1"><a class="a1"><span class="t1">
			단일연결법					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			중심연결법					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			와드연결법					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			완전연결법					</span></a></li>
</ol>
<div class="eg1">
<a class="b2 help" href="#m-help1a39" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
<span class="t1">정답보기</span>
<i class="ic1"></i>
</a>
</div>
<div class="tg2 loaded" id="m-help1a39" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
<strong class="tt1">정답</strong>
<div class="t2">
<i class="t2n">3</i>
<span class="t2t1">
			와드연결법			</span>
</div>
<br/>
<strong class="tt1">해설</strong>
<div class="t1">
		계층적 군집분석 수행 시 군집 내 편차 들의 제곱합을 고려하여 군집 간 정보의 손실을 최소화하는 방향으로 군집을 형성하는 방법이다.				</div>


<div class="more-c">
<strong class="tt1">비기봇 해설</strong>
<div class="t1">
				정답은 3번입니다.<br/>
<br/>
계층적 군집분석은 데이터 객체들을 유사성에 따라 계층적으로 묶어가는 방법입니다. 이 과정에서 군집 간의 유사성을 측정하여 가장 유사한 군집을 병합해 나갑니다. 군집을 병합하는 방법에는 여러 가지가 있으며, 그 중 와드연결법은 군집 내 편차들의 제곱합을 고려하여 군집 간 정보의 손실을 최소화하는 방향으로 군집을 형성합니다. 이는 병합된 군집의 오차제곱합이 병합 이전 군집의 오차제곱합의 합에 비해 증가한 정도가 작아지는 방향으로 군집을 형성하는 방법입니다.<br/>
<br/>
1. 단일연결법 <br/>
: 단일연결법은 두 군집 간의 가장 가까운 두 점 사이의 거리를 기준으로 군집을 병합하는 방법입니다. 이는 군집 간의 최소 거리를 기준으로 하여 군집을 형성하기 때문에, 군집의 형태가 길고 가늘어질 수 있습니다. 이 방법은 군집 내의 오차제곱합을 최소화하는 데 중점을 두지 않기 때문에, 문제에서 요구하는 조건과는 맞지 않습니다.<br/>
<br/>
2. 중심연결법 <br/>
: 중심연결법은 각 군집의 중심 간의 거리를 기준으로 군집을 병합하는 방법입니다. 이는 군집의 중심을 기준으로 하여 군집을 형성하기 때문에, 군집의 형태가 구형에 가까워질 수 있습니다. 그러나 이 방법 역시 군집 내의 오차제곱합을 최소화하는 데 중점을 두지 않기 때문에, 문제의 조건과는 부합하지 않습니다.<br/>
<br/>
3. 와드연결법 <br/>
: 와드연결법은 군집 내 편차들의 제곱합을 고려하여 군집 간 정보의 손실을 최소화하는 방향으로 군집을 형성하는 방법입니다. 이는 병합된 군집의 오차제곱합이 병합 이전 군집의 오차제곱합의 합에 비해 증가한 정도가 작아지는 방향으로 군집을 형성합니다. 따라서 문제에서 요구하는 조건에 가장 부합하는 방법입니다.<br/>
<br/>
4. 완전연결법 <br/>
: 완전연결법은 두 군집 간의 가장 먼 두 점 사이의 거리를 기준으로 군집을 병합하는 방법입니다. 이는 군집 간의 최대 거리를 기준으로 하여 군집을 형성하기 때문에, 군집의 형태가 조밀해질 수 있습니다. 그러나 이 방법은 군집 내의 오차제곱합을 최소화하는 데 중점을 두지 않기 때문에, 문제의 조건과는 맞지 않습니다.<br/>
<br/>
와드연결법은 군집 내 편차들의 제곱합을 최소화하는 방향으로 군집을 형성하는 방법으로, 병합된 군집의 오차제곱합이 병합 이전 군집의 오차제곱합의 합에 비해 증가한 정도가 작아지는 방향으로 군집을 형성합니다. 이는 문제에서 요구하는 조건에 정확히 부합합니다. 반면, 단일연결법, 중심연결법, 완전연결법은 각각 군집 간의 최소 거리, 중심 거리, 최대 거리를 기준으로 군집을 형성하기 때문에, 군집 내의 오차제곱합을 최소화하는 데 중점을 두지 않습니다.<br/>
따라서, 정답은 '3. 와드연결법' 입니다.<br/>
</div>
<div class="t2">
									#계층적 군집분석									# 와드연결법									# 오차제곱합									# 군집 병합									# 유사성 측정							</div>
</div>

</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
<div class="sg1">
<div class="w1">
<span class="g1">4과목</span>
<span class="g1">연관분석</span>
<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
</div>
</div>
<div class="tg1">
<strong class="tt1">
<span class="tt1n">40.</span>
<span class="tt1t1">
				아래 데이터 셋에서 A, B의 유클리드 거리(Euclidean distance)를 계산하시오.							</span>
</strong>
<span class="tt1t1">
<a class="p1" href="exam1view1img1.php?img=52c3dfd3-4b4d-21c9-d165-a23e17c430ce.png" rel="noopener" target="_blank" title="새 창">
<img alt="문제에 포함된 이미지" src="https://www.dataedupt.kr/data/img/question/52c3dfd3-4b4d-21c9-d165-a23e17c430ce.png"/>
</a>
</span>
</div>
<ol class="lst1">
<li class="li1"><a class="a1"><span class="t1">
			0					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
<mjx-container class="MathJax CtxtMenu_Attached_0" ctxtmenu_counter="17" jax="CHTML" style="font-size: 107.5%; position: relative;" tabindex="0"><mjx-math aria-hidden="true" class="MJX-TEX"><mjx-msqrt><mjx-sqrt><mjx-surd><mjx-mo class="mjx-n"><mjx-c class="mjx-c221A"></mjx-c></mjx-mo></mjx-surd><mjx-box style="padding-top: 0.163em;"><mjx-mn class="mjx-n"><mjx-c class="mjx-c31"></mjx-c><mjx-c class="mjx-c30"></mjx-c></mjx-mn></mjx-box></mjx-sqrt></mjx-msqrt></mjx-math><mjx-assistive-mml display="inline" unselectable="on"><math xmlns="http://www.w3.org/1998/Math/MathML"><msqrt><mn>10</mn></msqrt></math></mjx-assistive-mml></mjx-container> </span></a></li>
<li class="li1"><a class="a1"><span class="t1">
<mjx-container class="MathJax CtxtMenu_Attached_0" ctxtmenu_counter="18" jax="CHTML" style="font-size: 107.5%; position: relative;" tabindex="0"><mjx-math aria-hidden="true" class="MJX-TEX"><mjx-msqrt><mjx-sqrt><mjx-surd><mjx-mo class="mjx-n"><mjx-c class="mjx-c221A"></mjx-c></mjx-mo></mjx-surd><mjx-box style="padding-top: 0.163em;"><mjx-mn class="mjx-n"><mjx-c class="mjx-c32"></mjx-c><mjx-c class="mjx-c35"></mjx-c></mjx-mn></mjx-box></mjx-sqrt></mjx-msqrt></mjx-math><mjx-assistive-mml display="inline" unselectable="on"><math xmlns="http://www.w3.org/1998/Math/MathML"><msqrt><mn>25</mn></msqrt></math></mjx-assistive-mml></mjx-container> </span></a></li>
<li class="li1"><a class="a1"><span class="t1">
<mjx-container class="MathJax CtxtMenu_Attached_0" ctxtmenu_counter="19" jax="CHTML" style="font-size: 107.5%; position: relative;" tabindex="0"><mjx-math aria-hidden="true" class="MJX-TEX"><mjx-msqrt><mjx-sqrt><mjx-surd><mjx-mo class="mjx-n"><mjx-c class="mjx-c221A"></mjx-c></mjx-mo></mjx-surd><mjx-box style="padding-top: 0.163em;"><mjx-mn class="mjx-n"><mjx-c class="mjx-c35"></mjx-c><mjx-c class="mjx-c30"></mjx-c></mjx-mn></mjx-box></mjx-sqrt></mjx-msqrt></mjx-math><mjx-assistive-mml display="inline" unselectable="on"><math xmlns="http://www.w3.org/1998/Math/MathML"><msqrt><mn>50</mn></msqrt></math></mjx-assistive-mml></mjx-container> </span></a></li>
</ol>
<div class="eg1">
<a class="b2 help" href="#m-help1a40" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
<span class="t1">정답보기</span>
<i class="ic1"></i>
</a>
</div>
<div class="tg2 loaded" id="m-help1a40" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
<strong class="tt1">정답</strong>
<div class="t2">
<i class="t2n">4</i>
<span class="t2t1">
<mjx-container class="MathJax CtxtMenu_Attached_0" ctxtmenu_counter="20" jax="CHTML" style="font-size: 113.1%; position: relative;" tabindex="0"><mjx-math aria-hidden="true" class="MJX-TEX"><mjx-msqrt><mjx-sqrt><mjx-surd><mjx-mo class="mjx-n"><mjx-c class="mjx-c221A"></mjx-c></mjx-mo></mjx-surd><mjx-box style="padding-top: 0.163em;"><mjx-mn class="mjx-n"><mjx-c class="mjx-c35"></mjx-c><mjx-c class="mjx-c30"></mjx-c></mjx-mn></mjx-box></mjx-sqrt></mjx-msqrt></mjx-math><mjx-assistive-mml display="inline" unselectable="on"><math xmlns="http://www.w3.org/1998/Math/MathML"><msqrt><mn>50</mn></msqrt></math></mjx-assistive-mml></mjx-container> </span>
</div>
<br/>
<strong class="tt1">해설</strong>
<div class="t1">
		A, B의 유클리드 거리는 <mjx-container class="MathJax CtxtMenu_Attached_0" ctxtmenu_counter="21" jax="CHTML" style="font-size: 113.1%; position: relative;" tabindex="0"><mjx-math aria-hidden="true" class="MJX-TEX"><mjx-msqrt><mjx-sqrt><mjx-surd><mjx-mo class="mjx-sop"><mjx-c class="mjx-c221A TEX-S1"></mjx-c></mjx-mo></mjx-surd><mjx-box style="padding-top: 0.103em;"><mjx-mo class="mjx-n"><mjx-c class="mjx-c28"></mjx-c></mjx-mo><mjx-mn class="mjx-n"><mjx-c class="mjx-c31"></mjx-c><mjx-c class="mjx-c38"></mjx-c><mjx-c class="mjx-c35"></mjx-c></mjx-mn><mjx-mo class="mjx-n" space="3"><mjx-c class="mjx-c2212"></mjx-c></mjx-mo><mjx-mn class="mjx-n" space="3"><mjx-c class="mjx-c31"></mjx-c><mjx-c class="mjx-c38"></mjx-c><mjx-c class="mjx-c30"></mjx-c></mjx-mn><mjx-msup><mjx-mo class="mjx-n"><mjx-c class="mjx-c29"></mjx-c></mjx-mo><mjx-script style="vertical-align: 0.289em;"><mjx-mn class="mjx-n" size="s"><mjx-c class="mjx-c32"></mjx-c></mjx-mn></mjx-script></mjx-msup><mjx-mo class="mjx-n" space="3"><mjx-c class="mjx-c2B"></mjx-c></mjx-mo><mjx-mo class="mjx-n" space="3"><mjx-c class="mjx-c28"></mjx-c></mjx-mo><mjx-mn class="mjx-n"><mjx-c class="mjx-c37"></mjx-c><mjx-c class="mjx-c30"></mjx-c></mjx-mn><mjx-mo class="mjx-n" space="3"><mjx-c class="mjx-c2212"></mjx-c></mjx-mo><mjx-mn class="mjx-n" space="3"><mjx-c class="mjx-c37"></mjx-c><mjx-c class="mjx-c35"></mjx-c></mjx-mn><mjx-msup><mjx-mo class="mjx-n"><mjx-c class="mjx-c29"></mjx-c></mjx-mo><mjx-script style="vertical-align: 0.289em;"><mjx-mn class="mjx-n" size="s"><mjx-c class="mjx-c32"></mjx-c></mjx-mn></mjx-script></mjx-msup></mjx-box></mjx-sqrt></mjx-msqrt><mjx-mo class="mjx-n" space="4"><mjx-c class="mjx-c3D"></mjx-c></mjx-mo><mjx-msqrt space="4"><mjx-sqrt><mjx-surd><mjx-mo class="mjx-n"><mjx-c class="mjx-c221A"></mjx-c></mjx-mo></mjx-surd><mjx-box style="padding-top: 0.163em;"><mjx-mn class="mjx-n"><mjx-c class="mjx-c35"></mjx-c><mjx-c class="mjx-c30"></mjx-c></mjx-mn></mjx-box></mjx-sqrt></mjx-msqrt></mjx-math><mjx-assistive-mml display="inline" unselectable="on"><math xmlns="http://www.w3.org/1998/Math/MathML"><msqrt><mo stretchy="false">(</mo><mn>185</mn><mo>−</mo><mn>180</mn><msup><mo stretchy="false">)</mo><mn>2</mn></msup><mo>+</mo><mo stretchy="false">(</mo><mn>70</mn><mo>−</mo><mn>75</mn><msup><mo stretchy="false">)</mo><mn>2</mn></msup></msqrt><mo>=</mo><msqrt><mn>50</mn></msqrt></math></mjx-assistive-mml></mjx-container>이다.				</div>


<div class="more-c">
<strong class="tt1">비기봇 해설</strong>
<div class="t1">
				정답: 4. <mjx-container class="MathJax CtxtMenu_Attached_0" ctxtmenu_counter="22" jax="CHTML" style="font-size: 113.1%; position: relative;" tabindex="0"><mjx-math aria-hidden="true" class="MJX-TEX"><mjx-msqrt><mjx-sqrt><mjx-surd><mjx-mo class="mjx-sop"><mjx-c class="mjx-c221A TEX-S1"></mjx-c></mjx-mo></mjx-surd><mjx-box style="padding-top: 0.107em;"><mjx-mo class="mjx-n"><mjx-c class="mjx-c28"></mjx-c></mjx-mo></mjx-box></mjx-sqrt></mjx-msqrt><mjx-mn class="mjx-n"><mjx-c class="mjx-c35"></mjx-c><mjx-c class="mjx-c30"></mjx-c></mjx-mn><mjx-mo class="mjx-n"><mjx-c class="mjx-c29"></mjx-c></mjx-mo></mjx-math><mjx-assistive-mml display="inline" unselectable="on"><math xmlns="http://www.w3.org/1998/Math/MathML"><msqrt><mo stretchy="false">(</mo></msqrt><mn>50</mn><mo stretchy="false">)</mo></math></mjx-assistive-mml></mjx-container><br/>
<br/>
핵심 키워드: 유클리드 거리, 데이터 셋<br/>
<br/>
해설: <br/>
유클리드 거리는 두 점 사이의 최단 거리를 계산하는 방법입니다. 2차원 공간에서 두 점 (x1, y1)과 (x2, y2) 사이의 유클리드 거리는 <mjx-container class="MathJax CtxtMenu_Attached_0" ctxtmenu_counter="23" jax="CHTML" style="font-size: 113.1%; position: relative;" tabindex="0"><mjx-math aria-hidden="true" class="MJX-TEX"><mjx-msqrt><mjx-sqrt><mjx-surd><mjx-mo class="mjx-sop"><mjx-c class="mjx-c221A TEX-S1"></mjx-c></mjx-mo></mjx-surd><mjx-box style="padding-top: 0.103em;"><mjx-mo class="mjx-n"><mjx-c class="mjx-c28"></mjx-c></mjx-mo><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D465 TEX-I"></mjx-c></mjx-mi><mjx-mn class="mjx-n"><mjx-c class="mjx-c32"></mjx-c></mjx-mn><mjx-mo class="mjx-n" space="3"><mjx-c class="mjx-c2212"></mjx-c></mjx-mo><mjx-mi class="mjx-i" space="3"><mjx-c class="mjx-c1D465 TEX-I"></mjx-c></mjx-mi><mjx-mn class="mjx-n"><mjx-c class="mjx-c31"></mjx-c></mjx-mn><mjx-msup><mjx-mo class="mjx-n"><mjx-c class="mjx-c29"></mjx-c></mjx-mo><mjx-script style="vertical-align: 0.289em;"><mjx-mn class="mjx-n" size="s"><mjx-c class="mjx-c32"></mjx-c></mjx-mn></mjx-script></mjx-msup><mjx-mo class="mjx-n" space="3"><mjx-c class="mjx-c2B"></mjx-c></mjx-mo><mjx-mo class="mjx-n" space="3"><mjx-c class="mjx-c28"></mjx-c></mjx-mo><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D466 TEX-I"></mjx-c></mjx-mi><mjx-mn class="mjx-n"><mjx-c class="mjx-c32"></mjx-c></mjx-mn><mjx-mo class="mjx-n" space="3"><mjx-c class="mjx-c2212"></mjx-c></mjx-mo><mjx-mi class="mjx-i" space="3"><mjx-c class="mjx-c1D466 TEX-I"></mjx-c></mjx-mi><mjx-mn class="mjx-n"><mjx-c class="mjx-c31"></mjx-c></mjx-mn><mjx-msup><mjx-mo class="mjx-n"><mjx-c class="mjx-c29"></mjx-c></mjx-mo><mjx-script style="vertical-align: 0.289em;"><mjx-mn class="mjx-n" size="s"><mjx-c class="mjx-c32"></mjx-c></mjx-mn></mjx-script></mjx-msup></mjx-box></mjx-sqrt></mjx-msqrt></mjx-math><mjx-assistive-mml display="inline" unselectable="on"><math xmlns="http://www.w3.org/1998/Math/MathML"><msqrt><mo stretchy="false">(</mo><mi>x</mi><mn>2</mn><mo>−</mo><mi>x</mi><mn>1</mn><msup><mo stretchy="false">)</mo><mn>2</mn></msup><mo>+</mo><mo stretchy="false">(</mo><mi>y</mi><mn>2</mn><mo>−</mo><mi>y</mi><mn>1</mn><msup><mo stretchy="false">)</mo><mn>2</mn></msup></msqrt></math></mjx-assistive-mml></mjx-container>로 계산됩니다.<br/>
<br/>
1단계: 데이터 셋 A와 B의 키와 앉은 키의 차이를 계산합니다.<br/>
키의 차이: 185 - 180 = 5<br/>
앉은 키의 차이: 75 - 70 = 5<br/>
<br/>
2단계: 각 차이를 제곱합니다.<br/>
키의 차이의 제곱: 5^2 = 25<br/>
앉은 키의 차이의 제곱: 5^2 = 25<br/>
<br/>
3단계: 제곱된 차이를 더합니다.<br/>
25 + 25 = 50<br/>
<br/>
4단계: 더한 값을 제곱근으로 계산합니다.<br/>
<mjx-container class="MathJax CtxtMenu_Attached_0" ctxtmenu_counter="24" jax="CHTML" style="font-size: 113.1%; position: relative;" tabindex="0"><mjx-math aria-hidden="true" class="MJX-TEX"><mjx-msqrt><mjx-sqrt><mjx-surd><mjx-mo class="mjx-n"><mjx-c class="mjx-c221A"></mjx-c></mjx-mo></mjx-surd><mjx-box style="padding-top: 0.163em;"><mjx-mn class="mjx-n"><mjx-c class="mjx-c35"></mjx-c><mjx-c class="mjx-c30"></mjx-c></mjx-mn></mjx-box></mjx-sqrt></mjx-msqrt></mjx-math><mjx-assistive-mml display="inline" unselectable="on"><math xmlns="http://www.w3.org/1998/Math/MathML"><msqrt><mn>50</mn></msqrt></math></mjx-assistive-mml></mjx-container><br/>
<br/>
따라서, 데이터 셋 A와 B의 유클리드 거리는 <mjx-container class="MathJax CtxtMenu_Attached_0" ctxtmenu_counter="25" jax="CHTML" style="font-size: 113.1%; position: relative;" tabindex="0"><mjx-math aria-hidden="true" class="MJX-TEX"><mjx-msqrt><mjx-sqrt><mjx-surd><mjx-mo class="mjx-n"><mjx-c class="mjx-c221A"></mjx-c></mjx-mo></mjx-surd><mjx-box style="padding-top: 0.163em;"><mjx-mn class="mjx-n"><mjx-c class="mjx-c35"></mjx-c><mjx-c class="mjx-c30"></mjx-c></mjx-mn></mjx-box></mjx-sqrt></mjx-msqrt></mjx-math><mjx-assistive-mml display="inline" unselectable="on"><math xmlns="http://www.w3.org/1998/Math/MathML"><msqrt><mn>50</mn></msqrt></math></mjx-assistive-mml></mjx-container>입니다.<br/>
</div>
<div class="t2">
									#유사성 측정									# 유클리드 거리							</div>
</div>

</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
<div class="sg1">
<div class="w1">
<span class="g1">4과목</span>
<span class="g1">연관분석</span>
<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
</div>
</div>
<div class="tg1">
<strong class="tt1">
<span class="tt1n">41.</span>
<span class="tt1t1">
				아래는 학생들의 키와 몸무게를 정규화한 데이터이다. 최단연결법을 통해 학생들을 3개의 군집으로 나누고자 한다.(유클리디안 거리 사용) 다음 중 가장 적절한 것은?							</span>
</strong>
<span class="tt1t1">
<a class="p1" href="exam1view1img1.php?img=173baebc-6227-cc11-adf9-22661fb2b0a9.png" rel="noopener" target="_blank" title="새 창">
<img alt="문제에 포함된 이미지" src="https://www.dataedupt.kr/data/img/question/173baebc-6227-cc11-adf9-22661fb2b0a9.png"/>
</a>
</span>
</div>
<ol class="lst1">
<li class="li1"><a class="a1"><span class="t1">
			(A,C), (B), (D,E) 					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			(A,D), (B), (C,E) 					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			(A,E), (C), (B,D) 					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			(A,B), (C), (D,E) 					</span></a></li>
</ol>
<div class="eg1">
<a class="b2 help" href="#m-help1a41" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
<span class="t1">정답보기</span>
<i class="ic1"></i>
</a>
</div>
<div class="tg2 loaded" id="m-help1a41" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
<strong class="tt1">정답</strong>
<div class="t2">
<i class="t2n">4</i>
<span class="t2t1">
			(A,B), (C), (D,E) 			</span>
</div>
<br/>
<strong class="tt1">해설</strong>
<div class="t1">
		유클리디안 거리는 (d(x,y)=sqrt{(x_1-y_1)^2+...+(x_p-y_p)^2}=sqrt{(x-y)acute(x-y)})로 구할 수 있다.				</div>


<div class="more-c">
<strong class="tt1">비기봇 해설</strong>
<div class="t1">
				1. 우선, 유클리디안 거리를 계산하여 가장 가까운 두 데이터를 찾아야 합니다. <br/>
이 경우, A와 B의 거리는 sqrt((1-2)^2+(5-4)^2)=1.414, B와 D의 거리는 sqrt((2-4)^2+(4-3)^2)=2.236, D와 E의 거리는 sqrt((4-5)^2+(3-3)^2)=1.0 입니다. 따라서, 가장 가까운 두 데이터는 D와 E입니다.<br/>
<br/>
2. 다음으로, 나머지 데이터와 가장 가까운 데이터를 찾아야 합니다. <br/>
이 경우, A와 B의 거리는 1.414, B와 C의 거리는 sqrt((2-4)^2+(4-6)^2)=2.828, C와 D,E의 거리는 sqrt((4-4)^2+(6-3)^2)=3.0 입니다. 따라서, 가장 가까운 데이터는 A와 B입니다.<br/>
<br/>
3. 마지막으로, 나머지 데이터인 C를 별도의 군집으로 둡니다.<br/>
<br/>
따라서, 군집은 (A,B), (C), (D,E)로 나눌 수 있습니다.<br/>
</div>
<div class="t2">
									# 최단연결법									# 유클리디안 거리									# 군집화							</div>
</div>

</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
<div class="sg1">
<div class="w1">
<span class="g1">4과목</span>
<span class="g1">연관분석</span>
<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
</div>
</div>
<div class="tg1">
<strong class="tt1">
<span class="tt1n">42.</span>
<span class="tt1t1">
				아래 그림은 평균연결법을 통한 계층적 군집화 예제이다. 데이터 분석 목적 상 Height값을 1.5를 기준으로 하위 군집을 구성할 때 다음 중 생성된 하위 군집을 가장 잘 나타낸 것은?							</span>
</strong>
<span class="tt1t1">
<a class="p1" href="exam1view1img1.php?img=37e1f302-d48d-970b-4d0d-c7eec8909e10.jpg" rel="noopener" target="_blank" title="새 창">
<img alt="문제에 포함된 이미지" src="https://www.dataedupt.kr/data/img/question/37e1f302-d48d-970b-4d0d-c7eec8909e10.jpg"/>
</a>
</span>
</div>
<ol class="lst1">
<li class="li1"><a class="a1"><span class="t1">
			{h,a,f}, {b,d}, {e,j}, {c}, {g,i} 					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			{h,a,f}, {b,d}, {e,j}, {c,g,i} 					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			{h,a,f}, {b,d,e,j}, {c,g,i} 					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			{h,a,f}, {b,d,e,j}, {c}, {g,i}					</span></a></li>
</ol>
<div class="eg1">
<a class="b2 help" href="#m-help1a42" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
<span class="t1">정답보기</span>
<i class="ic1"></i>
</a>
</div>
<div class="tg2 loaded" id="m-help1a42" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
<strong class="tt1">정답</strong>
<div class="t2">
<i class="t2n">4</i>
<span class="t2t1">
			{h,a,f}, {b,d,e,j}, {c}, {g,i}			</span>
</div>
<br/>
<strong class="tt1">해설</strong>
<div class="t1">
		Height가 1.5를 기준으로 하위 군집을 형성하면 {h,a,f}, {b,d,e,j}, {c}, {g,i}가 나타난다.				</div>


<div class="more-c">
<strong class="tt1">비기봇 해설</strong>
<div class="t1">
				정답은 4번입니다.<br/>
<br/>
주어진 그림은 평균연결법(average linkage)을 사용한 계층적 군집화의 덴드로그램입니다. 계층적 군집화에서 군집의 개수를 결정하는 방법 중 하나는 덴드로그램의 Height 축에 특정 값을 기준으로 가로선을 긋는 것이며, 이 선과 교차하는 수직선(가지)의 개수가 군집의 개수가 됩니다.<br/>
<br/>
문제에서 Height 값을 1.5를 기준으로 하위 군집을 구성하라고 했으므로, 덴드로그램의 Height 축에서 1.5 지점에 수평선을 그어봅니다.<br/>
<br/>
수평선 (Height = 1.5)을 그었을 때, 이 선과 교차하는(또는 그 위로 연결되는) 가지들을 기준으로 군집을 나누어 보면 다음과 같습니다.<br/>
<br/>
1. 가장 왼쪽의 {h}와 {a,f}가 1.5보다 낮은 Height에서 합쳐져 하나의 큰 가지를 이루므로, {h,a,f}가 하나의 군집이 됩니다.<br/>
2. 다음으로 {b}와 {d}는 1.5보다 낮은 Height에서 합쳐져 {b,d} 군집을 이룹니다.<br/>
3. {e}와 {j}는 1.5보다 낮은 Height에서 합쳐져 {e,j} 군집을 이룹니다.<br/>
4. {c}는 1.5보다 높은 Height에서 다른 군집과 합쳐지므로, {c} 자체가 하나의 군집이 됩니다. (약 1.6 정도에서 {g,i}와 합쳐짐)<br/>
5. 마지막으로 {g}와 {i}는 1.5보다 낮은 Height에서 합쳐져 {g,i} 군집을 이룹니다.<br/>
<br/>
따라서 Height 1.5를 기준으로 생성된 하위 군집들은 {h,a,f}, {b,d}, {e,j}, {c}, {g,i} 입니다.<br/>
<br/>
따라서 정답은 '4.{h,a,f}, {b,d,e,j}, {c}, {g,i}'입니다.<br/>
</div>
<div class="t2">
									#군집분석									# 덴드로그램									# 평균연결법									# 계층적 군집화							</div>
</div>

</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
<div class="sg1">
<div class="w1">
<span class="g1">4과목</span>
<span class="g1">연관분석</span>
<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
</div>
</div>
<div class="tg1">
<strong class="tt1">
<span class="tt1n">43.</span>
<span class="tt1t1">
				계층적 군집방법은 두 개체(또는 군집) 간의 거리(또는 비유사성)에 기반하여 군집을 형성해 나가므로 거리에 대한 정의가 필요한데, 다음 중 변수의 표준화와 변수 간의 상관성을 동시에 고려한 통계적 거리로 적절한 것은?							</span>
</strong>
<span class="tt1t1">
</span>
</div>
<ol class="lst1">
<li class="li1"><a class="a1"><span class="t1">
			표준화 거리(Standardized distance) 					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			민코우스키 거리(Minkowski distance) 					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			마할라노비스 거리(Mahalanobis distance)  					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			자카드 계수(Jaccard coefficient)					</span></a></li>
</ol>
<div class="eg1">
<a class="b2 help" href="#m-help1a43" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
<span class="t1">정답보기</span>
<i class="ic1"></i>
</a>
</div>
<div class="tg2 loaded" id="m-help1a43" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
<strong class="tt1">정답</strong>
<div class="t2">
<i class="t2n">3</i>
<span class="t2t1">
			마할라노비스 거리(Mahalanobis distance)  			</span>
</div>
<br/>
<strong class="tt1">해설</strong>
<div class="t1">
		마할라노비스 거리는 변수의 표준편차와 더불어 변수 간 상관성까지 고려한 거리측도이다.				</div>


<div class="more-c">
<strong class="tt1">비기봇 해설</strong>
<div class="t1">
				정답은 3번입니다.<br/>
<br/>
계층적 군집방법은 데이터의 유사성을 기반으로 군집을 형성하는 방법으로, 데이터 간의 거리를 측정하여 군집을 형성합니다. 이때, 거리의 정의는 매우 중요합니다. 다양한 거리 측정 방법이 있지만, 변수의 표준화와 변수 간의 상관성을 동시에 고려하는 방법으로는 마할라노비스 거리가 있습니다. 마할라노비스 거리는 변수의 표준편차와 상관성을 고려하여, 데이터의 분포를 반영한 거리 측정 방법입니다. 이는 공분산 행렬을 사용하여 두 벡터 간의 거리를 계산하며, 데이터의 분포에 따라 거리 측정이 달라질 수 있습니다.<br/>
<br/>
1. 표준화 거리(Standardized distance) <br/>
: 표준화 거리는 각 변수의 단위를 표준화하여 거리 계산에 사용합니다. 이는 변수 간의 상관성을 고려하지 않기 때문에, 변수 간의 상관관계가 있는 경우에는 적절하지 않을 수 있습니다.<br/>
<br/>
2. 민코우스키 거리(Minkowski distance) <br/>
: 민코우스키 거리는 유클리디안 거리와 맨하탄 거리의 일반화된 형태로, 거리 계산 시 변수의 표준화나 상관성을 고려하지 않습니다. 이는 단순히 두 점 간의 거리만을 측정합니다.<br/>
<br/>
3. 마할라노비스 거리(Mahalanobis distance) <br/>
: 마할라노비스 거리는 변수의 표준편차와 상관성을 모두 고려하여 거리 측정을 수행합니다. 이는 공분산 행렬을 사용하여 데이터의 분포를 반영한 거리 측정 방법으로, 변수 간의 상관관계가 있는 경우에도 적절한 거리 측정이 가능합니다.<br/>
<br/>
4. 자카드 계수(Jaccard coefficient) <br/>
: 자카드 계수는 두 집합 간의 유사성을 측정하는 방법으로, 거리 측정보다는 유사성 측정에 가깝습니다. 이는 변수의 표준화나 상관성을 고려하지 않습니다.<br/>
<br/>
마할라노비스 거리는 변수의 표준화와 상관성을 모두 고려하여 거리 측정을 수행하기 때문에, 문제에서 요구하는 조건에 가장 적합합니다. 다른 거리 측정 방법들은 변수의 상관성을 고려하지 않거나, 거리 측정보다는 유사성 측정에 초점을 맞추고 있어 문제의 요구사항을 충족하지 못합니다.<br/>
따라서, 정답은 '3. 마할라노비스 거리(Mahalanobis distance)' 입니다.<br/>
</div>
<div class="t2">
									#계층적 군집									# 거리 측정									# 마할라노비스 거리									# 표준화									# 상관성							</div>
</div>

</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
<div class="sg1">
<div class="w1">
<span class="g1">4과목</span>
<span class="g1">연관분석</span>
<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
</div>
</div>
<div class="tg1">
<strong class="tt1">
<span class="tt1n">44.</span>
<span class="tt1t1">
				다음 중 k-means 군집의 단점으로 가장 부적절한 것은? 							</span>
</strong>
<span class="tt1t1">
</span>
</div>
<ol class="lst1">
<li class="li1"><a class="a1"><span class="t1">
			볼록한 형태가 아닌 군집이 존재하면 성능이 떨어진다. 					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			사전에 주어진 목적이 없으므로 결과 해석이 어렵다. 					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			잡음이나 이상값에 영향을 많이 받는다.					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			한번 군집이 형성되면 군집내 객체들은 다른 군집으로 이동할 수 없다.					</span></a></li>
</ol>
<div class="eg1">
<a class="b2 help" href="#m-help1a44" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
<span class="t1">정답보기</span>
<i class="ic1"></i>
</a>
</div>
<div class="tg2 loaded" id="m-help1a44" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
<strong class="tt1">정답</strong>
<div class="t2">
<i class="t2n">4</i>
<span class="t2t1">
			한번 군집이 형성되면 군집내 객체들은 다른 군집으로 이동할 수 없다.			</span>
</div>
<br/>
<strong class="tt1">해설</strong>
<div class="t1">
		k개의 초기 중심값은 임의로 선택이 가능하므로 한번 군집이 형성되어도 군집 내 객체들은 다른 군집으로 이동이 될 수 있다.				</div>


<div class="more-c">
<strong class="tt1">비기봇 해설</strong>
<div class="t1">
				정답은 4번입니다.<br/>
<br/>
k-means 군집화는 데이터 포인트를 k개의 군집으로 나누는 비지도 학습 알고리즘입니다. 이 알고리즘은 각 군집의 중심을 반복적으로 업데이트하여 데이터 포인트를 가장 가까운 중심에 할당합니다. 그러나 k-means는 몇 가지 단점이 있습니다.<br/>
<br/>
1. 볼록한 형태가 아닌 군집이 존재하면 성능이 떨어진다.<br/>
: k-means는 군집이 구형 또는 볼록한 형태일 때 잘 작동합니다. 비볼록한 형태의 군집이 존재할 경우, k-means는 군집을 제대로 구분하지 못할 수 있습니다.<br/>
<br/>
2. 사전에 주어진 목적이 없으므로 결과 해석이 어렵다.<br/>
: k-means는 비지도 학습 방법이기 때문에, 사전에 정의된 목적이 없으며, 결과를 해석하는 것이 어려울 수 있습니다. 이는 k-means의 일반적인 단점 중 하나입니다.<br/>
<br/>
3. 잡음이나 이상값에 영향을 많이 받는다.<br/>
: k-means는 잡음이나 이상값에 민감합니다. 이상값은 군집의 중심을 왜곡시켜 결과에 큰 영향을 미칠 수 있습니다.<br/>
<br/>
4. 한번 군집이 형성되면 군집내 객체들은 다른 군집으로 이동할 수 없다.<br/>
: k-means는 반복적인 업데이트를 통해 군집을 형성하며, 각 객체는 반복 과정에서 다른 군집으로 이동할 수 있습니다. 따라서 이 설명은 k-means의 특징과 맞지 않습니다.<br/>
<br/>
<br/>
k-means는 반복적인 군집 중심 업데이트를 통해 객체가 다른 군집으로 이동할 수 있는 알고리즘입니다. 따라서 '한번 군집이 형성되면 군집내 객체들은 다른 군집으로 이동할 수 없다'는 설명은 k-means의 특징과 맞지 않으며, 부적절한 설명입니다. 다른 선택지들은 k-means의 일반적인 단점을 잘 설명하고 있습니다.<br/>
<br/>
따라서, 정답은 '4. 한번 군집이 형성되면 군집내 객체들은 다른 군집으로 이동할 수 없다.' 입니다.<br/>
</div>
<div class="t2">
									#k-means									# 군집화									# 비지도 학습									# 이상값							</div>
</div>

</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
<div class="sg1">
<div class="w1">
<span class="g1">4과목</span>
<span class="g1">연관분석</span>
<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
</div>
</div>
<div class="tg1">
<strong class="tt1">
<span class="tt1n">45.</span>
<span class="tt1t1">
				거리를 이용하여 데이터 간 유사도를 측정할 수 있는 척도는 데이터의 속성과 구조에 따라 적합한 것을 사용해야 한다. 다음 중 유사도 측도에 대한 설명으로 부적절한 것은? 							</span>
</strong>
<span class="tt1t1">
</span>
</div>
<ol class="lst1">
<li class="li1"><a class="a1"><span class="t1">
			유클리드 거리는 두 점을 잇는 가장 짧은 직선거리이다. 공통으로 점수를 매긴 항목의 거리를 통해 판단하는 측도이다. 					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			맨하튼 거리는 각 방향 직각의 이동 거리 합으로 계산된다.					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			표준화 거리는 각 변수를 해당 변수의 표준편차로 변환한 후 유클리드 거리를 계산한 거리이다. 표준화를 하게 되면 척도의 차이, 분산의 차이로 인해 왜곡을 피할 수 있다.					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			마할라노비스 거리는 변수의 표준편차를 고려한 거리 측도이나 변수 간에 상관성이 있는 경우에는 표준화 거리 사용을 검토해야 한다.					</span></a></li>
</ol>
<div class="eg1">
<a class="b2 help" href="#m-help1a45" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
<span class="t1">정답보기</span>
<i class="ic1"></i>
</a>
</div>
<div class="tg2 loaded" id="m-help1a45" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
<strong class="tt1">정답</strong>
<div class="t2">
<i class="t2n">4</i>
<span class="t2t1">
			마할라노비스 거리는 변수의 표준편차를 고려한 거리 측도이나 변수 간에 상관성이 있는 경우에는 표준화 거리 사용을 검토해야 한다.			</span>
</div>
<br/>
<strong class="tt1">해설</strong>
<div class="t1">
		마할라노비스 거리는 통계적 개념이 포함된 거리이며 변수들의 산포를 고려하여 표준화한 거리이다. 두 벡터 사이의 거리를 산포를 의미하는 표본 공분산으로 나눠주어야 하며, 그룹에 대한 사전 지식 없이는 표본 공분산을 계산할 수 없으므로 사용하기 곤란하다.				</div>


<div class="more-c">
<strong class="tt1">비기봇 해설</strong>
<div class="t1">
				정답은 4번입니다.<br/>
<br/>
유사도 측도는 데이터 분석에서 데이터 간의 유사성을 측정하는 데 사용됩니다. 각 측도는 데이터의 특성과 분석 목적에 따라 적합하게 선택되어야 합니다. 유클리드 거리, 맨하튼 거리, 표준화 거리, 마할라노비스 거리 등은 다양한 상황에서 사용될 수 있는 대표적인 유사도 측도입니다.<br/>
<br/>
1. 유클리드 거리는 두 점을 잇는 가장 짧은 직선거리이다. 공통으로 점수를 매긴 항목의 거리를 통해 판단하는 측도이다.<br/>
: 유클리드 거리는 두 점 사이의 직선 거리를 측정하는 방법으로, 가장 일반적인 거리 측정 방법 중 하나입니다. 이 방법은 모든 차원에서 동일한 척도를 가정합니다.<br/>
<br/>
2. 맨하튼 거리는 각 방향 직각의 이동 거리 합으로 계산된다.<br/>
: 맨하튼 거리는 각 차원에서의 절대 거리의 합으로 계산되며, 격자형 도시의 거리 측정에 비유할 수 있습니다. 이는 각 차원의 이동을 독립적으로 고려합니다.<br/>
<br/>
3. 표준화 거리는 각 변수를 해당 변수의 표준편차로 변환한 후 유클리드 거리를 계산한 거리이다. 표준화를 하게 되면 척도의 차이, 분산의 차이로 인해 왜곡을 피할 수 있다.<br/>
: 표준화 거리는 각 변수를 표준편차로 나눈 후 유클리드 거리를 계산하는 방법으로, 변수 간의 척도 차이를 보정하여 왜곡을 줄입니다.<br/>
<br/>
4. 마할라노비스 거리는 변수의 표준편차를 고려한 거리 측도이나 변수 간에 상관성이 있는 경우에는 표준화 거리 사용을 검토해야 한다.<br/>
: 마할라노비스 거리는 변수 간의 상관성을 고려하여 거리 측정을 수행합니다. 이는 공분산 행렬을 사용하여 변수 간의 관계를 반영합니다. 표준화 거리와는 다른 개념입니다.<br/>
<br/>
<br/>
마할라노비스 거리는 변수 간의 상관성을 고려한 거리 측도로, 표준화 거리와는 다른 개념입니다. 표준화 거리는 단순히 각 변수를 표준편차로 나누어 척도 차이를 보정하는 반면, 마할라노비스 거리는 공분산 행렬을 사용하여 변수 간의 상관성을 반영합니다. 따라서 4번 선지의 설명은 부적절합니다.<br/>
<br/>
따라서, 정답은 '4. 마할라노비스 거리는 변수의 표준편차를 고려한 거리 측도이나 변수 간에 상관성이 있는 경우에는 표준화 거리 사용을 검토해야 한다.' 입니다.<br/>
</div>
<div class="t2">
									#유사도 측도									# 유클리드 거리									# 맨하튼 거리									# 표준화 거리									# 마할라노비스 거리							</div>
</div>

</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
<div class="sg1">
<div class="w1">
<span class="g1">4과목</span>
<span class="g1">연관분석</span>
<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
</div>
</div>
<div class="tg1">
<strong class="tt1">
<span class="tt1n">46.</span>
<span class="tt1t1">
				군집분석은 비지도학습 기법 중 하나로 사전 정보 없이 자료를 유사한 대상끼리 묶는 방법이다. 다음 중 군집분석에 대한 설명으로 부적절한 것은? 							</span>
</strong>
<span class="tt1t1">
</span>
</div>
<ol class="lst1">
<li class="li1"><a class="a1"><span class="t1">
			군집분석에서는 군집의 개수나 구조에 대한 가정없이 다변량 데이터로부터 거리 기준에 의한 자발적인 군집화를 유도하지 않는다.					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			군집 결과에 대한 안정성을 검토하는 방법은 교차타당성을 이용하는 방법을 생각할 수 있다. 데이터를 두 집단으로 나누어 각 집단에서 군집분석을 한 후 합쳐서 군집분석한 결과와 비교하여 비슷하면 결과에 대한 안전성이 있다고 할 수 있다.					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			군집의 분리가 논리적인가를 살펴보기 위해서는 군집 간 변동의 크기 차이를 검토한다. 					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			개체를 분류하기 위한 명확한 기준이 존재하지 않거나 기준이 밝혀지지 않은 상태에서 유용하게 이용할 수 있다.					</span></a></li>
</ol>
<div class="eg1">
<a class="b2 help" href="#m-help1a46" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
<span class="t1">정답보기</span>
<i class="ic1"></i>
</a>
</div>
<div class="tg2 loaded" id="m-help1a46" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
<strong class="tt1">정답</strong>
<div class="t2">
<i class="t2n">1</i>
<span class="t2t1">
			군집분석에서는 군집의 개수나 구조에 대한 가정없이 다변량 데이터로부터 거리 기준에 의한 자발적인 군집화를 유도하지 않는다.			</span>
</div>
<br/>
<strong class="tt1">해설</strong>
<div class="t1">
		군집분석에서는 군집의 개수나 구조에 대한 가정없이 데이터들 사이의 거리를 기준으로 군집화를 유도한다.				</div>


<div class="more-c">
<strong class="tt1">비기봇 해설</strong>
<div class="t1">
				정답은 1번입니다.<br/>
<br/>
군집분석은 비지도학습의 한 종류로, 데이터의 사전 정보 없이 유사한 특성을 가진 데이터들을 그룹화하는 기법입니다. 이는 데이터의 구조를 이해하고, 데이터 내의 패턴을 발견하는 데 유용합니다.<br/>
<br/>
1. 군집분석에서는 군집의 개수나 구조에 대한 가정없이 다변량 데이터로부터 거리 기준에 의한 자발적인 군집화를 유도하지 않는다.<br/>
: 군집분석은 데이터의 구조에 대한 사전 가정 없이 진행되며, 데이터 간의 거리를 기준으로 자연스럽게 군집을 형성합니다. 따라서 자발적인 군집화를 유도하지 않는다는 설명은 부적절합니다.<br/>
<br/>
2. 군집 결과에 대한 안정성을 검토하는 방법은 교차타당성을 이용하는 방법을 생각할 수 있다. 데이터를 두 집단으로 나누어 각 집단에서 군집분석을 한 후 합쳐서 군집분석한 결과와 비교하여 비슷하면 결과에 대한 안전성이 있다고 할 수 있다.<br/>
: 군집 결과의 안정성을 검토하기 위해 교차타당성을 사용할 수 있습니다. 이는 데이터를 두 집단으로 나누어 각각 군집분석을 수행한 후, 결과를 비교하여 안정성을 평가하는 방법입니다.<br/>
<br/>
3. 군집의 분리가 논리적인가를 살펴보기 위해서는 군집 간 변동의 크기 차이를 검토한다.<br/>
: 군집의 논리적 분리를 평가하기 위해 군집 간 변동의 크기 차이를 검토하는 것은 적절한 방법입니다. 이는 군집 간의 차이를 명확히 하는 데 도움이 됩니다.<br/>
<br/>
4. 개체를 분류하기 위한 명확한 기준이 존재하지 않거나 기준이 밝혀지지 않은 상태에서 유용하게 이용할 수 있다.<br/>
: 군집분석은 명확한 분류 기준이 없거나 기준이 밝혀지지 않은 상태에서 데이터를 분류하는 데 유용하게 사용됩니다.<br/>
<br/>
<br/>
선지 1은 군집분석의 본질을 잘못 설명하고 있습니다. 군집분석은 사전 가정 없이 데이터의 자연스러운 군집화를 유도하는 기법입니다. 다른 선택지들은 군집분석의 특성과 방법론을 적절히 설명하고 있습니다.<br/>
<br/>
따라서, 정답은 '1. 군집분석에서는 군집의 개수나 구조에 대한 가정없이 다변량 데이터로부터 거리 기준에 의한 자발적인 군집화를 유도하지 않는다.' 입니다.<br/>
</div>
<div class="t2">
									#군집분석									# 비지도학습									# 데이터 구조									# 교차타당성							</div>
</div>

</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
<div class="sg1">
<div class="w1">
<span class="g1">4과목</span>
<span class="g1">연관분석</span>
<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
</div>
</div>
<div class="tg1">
<strong class="tt1">
<span class="tt1n">47.</span>
<span class="tt1t1">
				K-means 군집분석에 대한 설명으로 틀린 것은?							</span>
</strong>
<span class="tt1t1">
</span>
</div>
<ol class="lst1">
<li class="li1"><a class="a1"><span class="t1">
			K-means 군집분석은 원하는 군집의 개수를 초기에 정하고 seed 중심으로 군집을 형성한다. 					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			K-means 군집분석은 각 개체를 가장 가까운 seed가 있는 군집으로 분류한다. 					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			군집으로 분류된 개체들의 정보를 활용하여 새로운 seed를 계산하면서 개체의 적용에 따른 seed의 변화를 관찰한다. 					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			95%이상의 개체가 seed에 할당 되면 seed의 조정을 멈춘다.					</span></a></li>
</ol>
<div class="eg1">
<a class="b2 help" href="#m-help1a47" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
<span class="t1">정답보기</span>
<i class="ic1"></i>
</a>
</div>
<div class="tg2 loaded" id="m-help1a47" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
<strong class="tt1">정답</strong>
<div class="t2">
<i class="t2n">4</i>
<span class="t2t1">
			95%이상의 개체가 seed에 할당 되면 seed의 조정을 멈춘다.			</span>
</div>
<br/>
<strong class="tt1">해설</strong>
<div class="t1">
		95% 이상의 개체가 아닌 모든 개체가 군집으로 할당될 때까지 위 과정들을 반복한다.				</div>


<div class="more-c">
<strong class="tt1">비기봇 해설</strong>
<div class="t1">
				정답은 4번입니다.<br/>
<br/>
K-means 군집분석은 비지도 학습의 한 방법으로, 데이터 포인트를 k개의 군집으로 나누는 알고리즘입니다. 초기에는 사용자가 원하는 군집의 개수를 설정하고, 각 군집의 중심(seed)을 무작위로 선택합니다. 이후 각 데이터 포인트를 가장 가까운 중심에 할당하고, 각 군집의 중심을 재계산하는 과정을 반복하여 군집을 형성합니다.<br/>
<br/>
1. K-means 군집분석은 원하는 군집의 개수를 초기에 정하고 seed 중심으로 군집을 형성한다.<br/>
: K-means 군집분석은 사용자가 원하는 군집의 개수를 초기에 설정하고, 초기 중심(seed)을 무작위로 선택하여 군집을 형성합니다.<br/>
<br/>
2. K-means 군집분석은 각 개체를 가장 가까운 seed가 있는 군집으로 분류한다.<br/>
: 각 데이터 포인트는 가장 가까운 중심(seed)이 있는 군집으로 할당됩니다. 이는 K-means 알고리즘의 핵심 과정 중 하나입니다.<br/>
<br/>
3. 군집으로 분류된 개체들의 정보를 활용하여 새로운 seed를 계산하면서 개체의 적용에 따른 seed의 변화를 관찰한다.<br/>
: 군집으로 분류된 데이터 포인트를 기반으로 새로운 중심을 계산하고, 이 과정을 반복하여 중심의 변화를 관찰합니다.<br/>
<br/>
4. 95%이상의 개체가 seed에 할당 되면 seed의 조정을 멈춘다.<br/>
: K-means 군집분석은 모든 데이터 포인트가 수렴할 때까지 중심을 조정합니다. 95% 이상의 개체가 할당되면 멈춘다는 조건은 없습니다.<br/>
<br/>
<br/>
K-means 군집분석은 모든 데이터 포인트가 수렴할 때까지 중심을 조정하는 것이 원칙입니다. 95% 이상의 개체가 할당되면 멈춘다는 조건은 존재하지 않으므로, 이 설명은 틀렸습니다. 다른 선택지들은 K-means 군집분석의 과정과 원리를 잘 설명하고 있습니다.<br/>
<br/>
따라서, 정답은 '4. 95%이상의 개체가 seed에 할당 되면 seed의 조정을 멈춘다.' 입니다.<br/>
</div>
<div class="t2">
									#K-means									# 군집분석									# 중심									# 수렴							</div>
</div>

</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
<div class="sg1">
<div class="w1">
<span class="g1">4과목</span>
<span class="g1">연관분석</span>
<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
</div>
</div>
<div class="tg1">
<strong class="tt1">
<span class="tt1n">48.</span>
<span class="tt1t1">
				다음 중 고차원의 데이터를 이해하기 쉬운 저차원의 뉴런으로 정렬화하여 지도의 형태로 형성화하는 클러스터링 방법으로 적절한 것은?							</span>
</strong>
<span class="tt1t1">
</span>
</div>
<ol class="lst1">
<li class="li1"><a class="a1"><span class="t1">
			의사결정나무(Decision Tree)					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			연관규칙(Association Rule)					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			랜덤포레스트(Random Forest)					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			자기조직화지도(Self-Organizing Map)					</span></a></li>
</ol>
<div class="eg1">
<a class="b2 help" href="#m-help1a48" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
<span class="t1">정답보기</span>
<i class="ic1"></i>
</a>
</div>
<div class="tg2 loaded" id="m-help1a48" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
<strong class="tt1">정답</strong>
<div class="t2">
<i class="t2n">4</i>
<span class="t2t1">
			자기조직화지도(Self-Organizing Map)			</span>
</div>
<br/>
<strong class="tt1">해설</strong>
<div class="t1">
		자기조직화지도(Self-Organizing Map)은 비지도 신경망으로 고차원의 데이터를 이해하기 쉬운 저차원의 뉴런으로 정렬하여 지도의 형태로 형상 화한다.				</div>


<div class="more-c">
<strong class="tt1">비기봇 해설</strong>
<div class="t1">
				정답은 4번입니다.<br/>
<br/>
문제는 고차원의 데이터를 저차원의 뉴런으로 정렬화하여 지도의 형태로 형성화하는 클러스터링 방법을 묻고 있습니다. 이는 데이터의 차원을 축소하여 시각적으로 이해하기 쉽게 만드는 방법을 찾는 것입니다.<br/>
<br/>
1. 의사결정나무(Decision Tree)<br/>
: 의사결정나무는 데이터를 분류하거나 회귀 분석을 수행하는 데 사용되는 트리 구조의 모델로, 데이터의 차원을 축소하거나 시각화하는 데 중점을 두지 않습니다.<br/>
<br/>
2. 연관규칙(Association Rule)<br/>
: 연관규칙은 데이터베이스에서 항목 간의 흥미로운 관계를 찾는 방법으로, 주로 장바구니 분석에 사용되며 차원 축소와는 관련이 없습니다.<br/>
<br/>
3. 랜덤포레스트(Random Forest)<br/>
: 랜덤포레스트는 여러 개의 의사결정나무를 사용하여 예측 성능을 향상시키는 앙상블 학습 방법으로, 차원 축소보다는 예측 정확도를 높이는 데 중점을 둡니다.<br/>
<br/>
4. 자기조직화지도(Self-Organizing Map)<br/>
: 자기조직화지도는 고차원의 데이터를 저차원의 격자 형태로 변환하여 시각화하는 데 사용되는 비지도 학습 방법으로, 문제에서 요구하는 차원 축소 및 시각화에 적합합니다.<br/>
<br/>
<br/>
자기조직화지도(Self-Organizing Map)는 고차원의 데이터를 저차원의 격자 형태로 변환하여 시각화하는 데 사용되는 방법으로, 문제에서 요구하는 차원 축소 및 시각화에 적합합니다. 다른 선택지들은 차원 축소와 시각화보다는 분류, 예측, 또는 연관성 발견에 중점을 두고 있어 문제의 요구와 맞지 않습니다.<br/>
<br/>
따라서, 정답은 '4. 자기조직화지도(Self-Organizing Map)' 입니다.<br/>
</div>
<div class="t2">
									#자기조직화지도									# 차원 축소									# 시각화									# 클러스터링							</div>
</div>

</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
<div class="sg1">
<div class="w1">
<span class="g1">4과목</span>
<span class="g1">연관분석</span>
<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
</div>
</div>
<div class="tg1">
<strong class="tt1">
<span class="tt1n">49.</span>
<span class="tt1t1">
				군집분석에서는 관측값들이 얼마나 유사한지 또는 유사하지 않은지를 측정할 수 있는 측도가 필요하다. 다음 중 유사도 측도에 대한 설명으로 가장 부적절한 것은?							</span>
</strong>
<span class="tt1t1">
</span>
</div>
<ol class="lst1">
<li class="li1"><a class="a1"><span class="t1">
			유클리드 거리는 공통으로 점수를 매긴 항목의 크기를 통해 판단하는 측도이다. 					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			코사인 거리는 두 단위 벡터의 내적을 이용하여, 단위 벡터의 내각의 크기로 유사도를 측정한다. 					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			자카드는 Boolean 속성으로 이루어진 두 객체 간의 유사도 측정에 사용된다.					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			피어슨 상관계수는 각 객체의 데이터 집합이 직선으로 표현되는 정도를 측정한다.					</span></a></li>
</ol>
<div class="eg1">
<a class="b2 help" href="#m-help1a49" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
<span class="t1">정답보기</span>
<i class="ic1"></i>
</a>
</div>
<div class="tg2 loaded" id="m-help1a49" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
<strong class="tt1">정답</strong>
<div class="t2">
<i class="t2n">4</i>
<span class="t2t1">
			피어슨 상관계수는 각 객체의 데이터 집합이 직선으로 표현되는 정도를 측정한다.			</span>
</div>
<br/>
<strong class="tt1">해설</strong>
<div class="t1">
		군집분석의 유사도 측도로 피어슨 상관계수는 사용하지 않는다.				</div>


<div class="more-c">
<strong class="tt1">비기봇 해설</strong>
<div class="t1">
				1번 "유클리드 거리는 공통으로 점수를 매긴 항목의 크기를 통해 판단하는 측도이다."는 적절하지 않습니다. 유클리드 거리는 두 데이터 포인트 간의 기하학적 거리를 측정하는 것입니다.<br/>
<br/>
2번 "코사인 거리는 두 단위 벡터의 내적을 이용하여, 단위 벡터의 내각의 크기로 유사도를 측정한다."는 적절한 설명입니다.<br/>
<br/>
3번 "자카드는 Boolean 속성으로 이루어진 두 객체 간의 유사도 측정에 사용된다."는 적절한 설명입니다.<br/>
<br/>
4번 "피어슨 상관계수는 각 객체의 데이터 집합이 직선으로 표현되는 정도를 측정한다."가 가장 부적절한 설명입니다.<br/>
<br/>
피어슨 상관계수는 두 변수 간의 선형 관계 정도를 측정하는 것이지, 각 객체의 데이터 집합이 직선으로 표현되는 정도를 측정하는 것은 아닙니다.<br/>
</div>
<div class="t2">
									# 군집분석									# 유사도 측도									# 유클리드 거리									# 코사인 거리									# 자카드 유사도									# 피어슨 상관계수							</div>
</div>

</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
<div class="sg1">
<div class="w1">
<span class="g1">4과목</span>
<span class="g1">연관분석</span>
<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
</div>
</div>
<div class="tg1">
<strong class="tt1">
<span class="tt1n">50.</span>
<span class="tt1t1">
				SOM은 비지도 신경망으로 고차원의 데이터를 이해하기 쉬운 저차원의 뉴런으로 정렬하여 지도 형태로 형상화하는 방법이다. 다음 중 SOM 방법에 대한 설명으로 부적절한 것은?							</span>
</strong>
<span class="tt1t1">
</span>
</div>
<ol class="lst1">
<li class="li1"><a class="a1"><span class="t1">
			SOM은 입력변수의 위치 관계를 그대로 보존한다는 특징이 있다. 이러한 SOM의 특징으로 인해 입력 변수의 정보와 그들의 관계가 지도상에 그대로 나타난다.					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			SOM을 이용한 군집분석은 인공신경망의 역전파 알고리즘을 사용함으로써 수행 속도가 빠르고 군집의 성능이 매우 우수하다.					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			SOM 알고리즘은 고차원의 데이터를 저차원의 지도 형태로 형상화하기 때문에 시각적으로 이해하기 쉬울 뿐 아니라 변수의 위치 관계를 그대로 보존하기 때문에 실제 데이터가 유사하면 지도상 가깝게 표현된다.					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			SOM은 경쟁 학습으로 각각의 뉴런이 입력 벡터와 얼마나 가까운가를 계산하여 연결강도를 반복적으로 재조정하여 학습한다. 이와 같은 과정을 거치면서 연결강도는 입력 패턴과 가장 유사한 경쟁층 뉴런이 승자가 된다.					</span></a></li>
</ol>
<div class="eg1">
<a class="b2 help" href="#m-help1a50" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
<span class="t1">정답보기</span>
<i class="ic1"></i>
</a>
</div>
<div class="tg2 loaded" id="m-help1a50" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
<strong class="tt1">정답</strong>
<div class="t2">
<i class="t2n">2</i>
<span class="t2t1">
			SOM을 이용한 군집분석은 인공신경망의 역전파 알고리즘을 사용함으로써 수행 속도가 빠르고 군집의 성능이 매우 우수하다.			</span>
</div>
<br/>
<strong class="tt1">해설</strong>
<div class="t1">
		SOM은 역전파 알고리즘 등을 이용하는 인공 신경망과 달리 단 하나의 전방패스를 사용함으로써 속도가 매우 빠르다. 따라서 실시간 학습처리를 할 수 있는 모형이다.				</div>


<div class="more-c">
<strong class="tt1">비기봇 해설</strong>
<div class="t1">
				정답은 2번입니다.<br/>
<br/>
SOM(Self-Organizing Map)은 비지도 학습의 일종으로, 고차원의 데이터를 저차원의 공간에 투영하여 시각적으로 이해하기 쉽게 만드는 방법입니다. 이 과정에서 데이터의 위치 관계를 보존하여 유사한 데이터는 지도상에서 가깝게 배치됩니다.<br/>
<br/>
1. SOM은 입력변수의 위치 관계를 그대로 보존한다는 특징이 있다. 이러한 SOM의 특징으로 인해 입력 변수의 정보와 그들의 관계가 지도상에 그대로 나타난다.<br/>
: SOM은 입력 데이터의 위치 관계를 보존하여 시각화하는 특징이 있습니다. 이는 데이터의 유사성을 지도상에서 쉽게 파악할 수 있게 해줍니다.<br/>
<br/>
2. SOM을 이용한 군집분석은 인공신경망의 역전파 알고리즘을 사용함으로써 수행 속도가 빠르고 군집의 성능이 매우 우수하다.<br/>
: SOM은 비지도 학습 방법으로, 역전파 알고리즘을 사용하지 않습니다. 역전파 알고리즘은 주로 지도 학습에서 사용됩니다.<br/>
<br/>
3. SOM 알고리즘은 고차원의 데이터를 저차원의 지도 형태로 형상화하기 때문에 시각적으로 이해하기 쉬울 뿐 아니라 변수의 위치 관계를 그대로 보존하기 때문에 실제 데이터가 유사하면 지도상 가깝게 표현된다.<br/>
: SOM은 고차원의 데이터를 저차원으로 변환하여 시각적으로 이해하기 쉽게 만들며, 데이터의 유사성을 지도상에서 가깝게 표현합니다.<br/>
<br/>
4. SOM은 경쟁 학습으로 각각의 뉴런이 입력 벡터와 얼마나 가까운가를 계산하여 연결강도를 반복적으로 재조정하여 학습한다. 이와 같은 과정을 거치면서 연결강도는 입력 패턴과 가장 유사한 경쟁층 뉴런이 승자가 된다.<br/>
: SOM은 경쟁 학습을 통해 입력 벡터와 가장 가까운 뉴런을 찾아내고, 그 뉴런의 연결 강도를 조정하여 학습을 진행합니다.<br/>
<br/>
<br/>
SOM은 비지도 학습 방법으로, 역전파 알고리즘을 사용하지 않습니다. 따라서 'SOM을 이용한 군집분석은 인공신경망의 역전파 알고리즘을 사용함으로써 수행 속도가 빠르고 군집의 성능이 매우 우수하다'는 설명은 부적절합니다. 다른 선택지들은 SOM의 특성을 잘 설명하고 있습니다.<br/>
<br/>
따라서, 정답은 '2. SOM을 이용한 군집분석은 인공신경망의 역전파 알고리즘을 사용함으로써 수행 속도가 빠르고 군집의 성능이 매우 우수하다.' 입니다.<br/>
</div>
<div class="t2">
									#SOM									# 비지도 학습									# 경쟁 학습									# 데이터 시각화							</div>
</div>

</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
<div class="sg1">
<div class="w1">
<span class="g1">4과목</span>
<span class="g1">연관분석</span>
<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
</div>
</div>
<div class="tg1">
<strong class="tt1">
<span class="tt1n">51.</span>
<span class="tt1t1">
				비계층적 군집 방법의 기법인 k-means Clustering의 경우 이상값(Outlier)에 민감하여 군집 경계의 설정이 어렵다는 단점이 존재한다. 이러한 단점을 극복하기 위해 등장한 비계층적 군집 방법으로 가장 적절한 것은?							</span>
</strong>
<span class="tt1t1">
</span>
</div>
<ol class="lst1">
<li class="li1"><a class="a1"><span class="t1">
			PAM(Partitioning Around Medoids)					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			혼합 분포 군집(Mixture Distribution Clustering) 					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			Density based Clustering					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			Fuzzy Clustering					</span></a></li>
</ol>
<div class="eg1">
<a class="b2 help" href="#m-help1a51" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
<span class="t1">정답보기</span>
<i class="ic1"></i>
</a>
</div>
<div class="tg2 loaded" id="m-help1a51" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
<strong class="tt1">정답</strong>
<div class="t2">
<i class="t2n">1</i>
<span class="t2t1">
			PAM(Partitioning Around Medoids)			</span>
</div>
<br/>
<strong class="tt1">해설</strong>
<div class="t1">
		k-means clustering의 단점을 극복하기 위해 k-median 군집의 함수 PAM(Partitioning Around Medoids)를 사용한다.				</div>


<div class="more-c">
<strong class="tt1">비기봇 해설</strong>
<div class="t1">
				1. PAM(Partitioning Around Medoids)<br/>
- PAM은 k-means Clustering과 유사한 비계층적 군집 방법이지만, 중심점을 평균 대신 실제 데이터 포인트인 medoid(중앙값)를 사용합니다. 이를 통해 이상값의 영향을 덜 받게 되어, k-means의 단점을 극복할 수 있습니다.<br/>
<br/>
2. 혼합 분포 군집(Mixture Distribution Clustering):<br/>
- 혼합 분포 군집은 데이터가 여러 개의 분포로 구성되어 있다고 가정하고, 각 분포의 모수를 추정하여 군집을 형성합니다.<br/>
이 방법은 이상값에 덜 민감하지만, 분포 가정이 충족되어야 하는 제한이 있습니다.<br/>
<br/>
3. Density based Clustering:<br/>
- Density based Clustering은 밀도 기반 알고리즘으로, 데이터 포인트 간의 밀도 차이를 이용하여 군집을 형성합니다.<br/>
이 방법은 이상값에 강건하며, 임의 모양의 군집도 탐지할 수 있습니다. 대표적인 알고리즘으로 DBSCAN이 있습니다.<br/>
<br/>
4. Fuzzy Clustering:<br/>
- Fuzzy Clustering은 데이터 포인트가 하나의 군집에만 속하지 않고 여러 군집에 부분적으로 속할 수 있다고 가정합니다.<br/>
이 방법은 이상값에 어느 정도 강건하지만, 복잡한 계산이 필요합니다.<br/>
<br/>
따라서 k-means Clustering의 단점인 이상값에 대한 민감성을 극복하기 위해 가장 적절한 비계층적 군집 방법은 1. PAM(Partitioning Around Medoids)입니다.<br/>
</div>
<div class="t2">
									# 비계층적 군집									# k-means Clustering									# 이상값									# PAM									# 혼합 분포 군집									# Density based Clustering									# Fuzzy Clustering							</div>
</div>

</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
<div class="sg1">
<div class="w1">
<span class="g1">4과목</span>
<span class="g1">연관분석</span>
<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
</div>
</div>
<div class="tg1">
<strong class="tt1">
<span class="tt1n">52.</span>
<span class="tt1t1">
				아래는 22개의 미국 전투기에 대한 4개의 변수 값을 사용한 군집분석의 결과이다. 이에 대한 설명 중 부적절한 것은?							</span>
</strong>
<span class="tt1t1">
<a class="p1" href="exam1view1img1.php?img=03e8d4f1-152e-cb0a-4ab0-cee41b35d116.png" rel="noopener" target="_blank" title="새 창">
<img alt="문제에 포함된 이미지" src="https://www.dataedupt.kr/data/img/question/03e8d4f1-152e-cb0a-4ab0-cee41b35d116.png"/>
</a>
</span>
</div>
<ol class="lst1">
<li class="li1"><a class="a1"><span class="t1">
			비계층적 군집분석의 결과이다.					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			위의 방법을 사용할 때 군집 개수를 사전에 결정해야 한다. 					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			각 군집은 7개, 9개, 6개의 전투기를 포함한다.					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			각 군집의 중심에 대한 정보가 포함되어 있지 않다.					</span></a></li>
</ol>
<div class="eg1">
<a class="b2 help" href="#m-help1a52" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
<span class="t1">정답보기</span>
<i class="ic1"></i>
</a>
</div>
<div class="tg2 loaded" id="m-help1a52" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
<strong class="tt1">정답</strong>
<div class="t2">
<i class="t2n">4</i>
<span class="t2t1">
			각 군집의 중심에 대한 정보가 포함되어 있지 않다.			</span>
</div>
<br/>
<strong class="tt1">해설</strong>
<div class="t1">
		각 군집의 중심에 대한 정보는 Cluster means:의 결과로부터 포함되어 있다.				</div>


<div class="more-c">
<strong class="tt1">비기봇 해설</strong>
<div class="t1">
				정답은 4번입니다.<br/>
<br/>
이 문제는 비계층적 군집분석, 특히 K-평균 군집분석에 대한 이해를 평가합니다. K-평균 군집분석은 사전에 군집의 개수를 결정하고, 각 군집의 중심을 계산하여 데이터를 군집화하는 방법입니다. 제공된 이미지에서는 3개의 군집으로 나누어졌으며, 각 군집의 크기와 중심값이 제시되어 있습니다.<br/>
<br/>
1. 비계층적 군집분석의 결과이다.<br/>
: 비계층적 군집분석은 K-평균 군집분석과 같은 방법을 포함하며, 사전에 군집의 개수를 결정합니다.<br/>
<br/>
2. 위의 방법을 사용할 때 군집 개수를 사전에 결정해야 한다.<br/>
: K-평균 군집분석은 사전에 군집의 개수를 결정해야 하는 특징이 있습니다.<br/>
<br/>
3. 각 군집은 7개, 9개, 6개의 전투기를 포함한다.<br/>
: 이미지에서 각 군집은 7개, 6개, 9개의 전투기를 포함하고 있음을 보여줍니다.<br/>
<br/>
4. 각 군집의 중심에 대한 정보가 포함되어 있지 않다.<br/>
: K-평균 군집분석에서는 각 군집의 중심에 대한 정보가 제공되며, 이미지에서도 각 군집의 중심값이 제시되어 있습니다.<br/>
<br/>
<br/>
K-평균 군집분석에서는 각 군집의 중심에 대한 정보가 필수적으로 포함됩니다. 이미지에서도 각 군집의 중심값이 명시되어 있으므로, '각 군집의 중심에 대한 정보가 포함되어 있지 않다'는 설명은 부적절합니다.<br/>
<br/>
따라서, 정답은 '4. 각 군집의 중심에 대한 정보가 포함되어 있지 않다.' 입니다.<br/>
</div>
<div class="t2">
									#K-평균 군집분석									# 군집의 개수									# 군집의 중심									# 비계층적 군집분석							</div>
</div>

</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
<div class="sg1">
<div class="w1">
<span class="g1">4과목</span>
<span class="g1">연관분석</span>
<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
</div>
</div>
<div class="tg1">
<strong class="tt1">
<span class="tt1n">53.</span>
<span class="tt1t1">
				k-평균 군집으로 대표되는 비계층적 군집 방법에서는 군집의 개수인 k를 미리 정해주어야 한다. 다음 중 군집수를 정하는 데 활용할 수 있는 그래프로 가장 적절한 것은 무엇인가?							</span>
</strong>
<span class="tt1t1">
</span>
</div>
<ol class="lst1">
<li class="li1"><a class="a1"><span class="t1">
			ROC 그래프					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			집단 내 제곱합 그래프 					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			덴드로그램					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			향상도 곡선					</span></a></li>
</ol>
<div class="eg1">
<a class="b2 help" href="#m-help1a53" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
<span class="t1">정답보기</span>
<i class="ic1"></i>
</a>
</div>
<div class="tg2 loaded" id="m-help1a53" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
<strong class="tt1">정답</strong>
<div class="t2">
<i class="t2n">2</i>
<span class="t2t1">
			집단 내 제곱합 그래프 			</span>
</div>
<br/>
<strong class="tt1">해설</strong>
<div class="t1">
		k-평균 군집은 초기 중심으로부터 오차 제곱합을 최소화하는 방향으로 군집이 형성되므로 집단 내 제곱합 그래프가 필요하다.				</div>


<div class="more-c">
<strong class="tt1">비기봇 해설</strong>
<div class="t1">
				정답은 2번입니다.<br/>
<br/>
k-평균 군집 분석에서 군집의 개수 k를 정하는 것은 매우 중요합니다. 이를 위해 엘보우 방법을 사용하는데, 이는 집단 내 제곱합 그래프를 통해 군집의 수를 결정합니다. 이 그래프는 군집의 수에 따른 집단 내 제곱합의 변화를 보여주며, 그래프의 꺾이는 지점이 최적의 군집 수를 나타냅니다.<br/>
<br/>
1. ROC 그래프<br/>
: ROC 그래프는 수신자 조작 특성 곡선으로, 주로 이진 분류 문제에서 모델의 성능을 평가하는 데 사용됩니다. 군집의 수를 결정하는 데는 적합하지 않습니다.<br/>
<br/>
2. 집단 내 제곱합 그래프<br/>
: 집단 내 제곱합 그래프는 군집의 수에 따른 집단 내 제곱합의 변화를 보여주며, 엘보우 방법을 통해 최적의 군집 수를 결정하는 데 사용됩니다.<br/>
<br/>
3. 덴드로그램<br/>
: 덴드로그램은 계층적 군집 분석에서 군집의 계층 구조를 시각화하는 데 사용됩니다. 비계층적 군집 방법에서는 사용되지 않습니다.<br/>
<br/>
4. 향상도 곡선<br/>
: 향상도 곡선은 주로 마케팅에서 캠페인의 효과를 평가하는 데 사용되며, 군집의 수를 결정하는 데는 적합하지 않습니다.<br/>
<br/>
<br/>
집단 내 제곱합 그래프는 k-평균 군집 분석에서 군집의 수를 결정하는 데 사용되는 엘보우 방법의 핵심 도구입니다. 이 그래프를 통해 군집의 수에 따른 집단 내 제곱합의 변화를 관찰하고, 그래프의 꺾이는 지점에서 최적의 군집 수를 결정할 수 있습니다. 다른 선택지들은 군집의 수를 결정하는 데 적합하지 않습니다.<br/>
<br/>
따라서, 정답은 '2. 집단 내 제곱합 그래프' 입니다.<br/>
</div>
<div class="t2">
									#k-평균 군집									# 엘보우 방법									# 집단 내 제곱합									# 군집 수 결정							</div>
</div>

</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
<div class="sg1">
<div class="w1">
<span class="g1">4과목</span>
<span class="g1">연관분석</span>
<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
</div>
</div>
<div class="tg1">
<strong class="tt1">
<span class="tt1n">54.</span>
<span class="tt1t1">
				다음 중 k평균군집에 대한 설명으로 부적절한 것은?							</span>
</strong>
<span class="tt1t1">
</span>
</div>
<ol class="lst1">
<li class="li1"><a class="a1"><span class="t1">
			한번 군집이 형성되면 군집에 속하는 개체들은 다른 군집으로 이동할 수 없다. 					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			초기 군집의 중심을 임의로 선택해야 한다.					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			군집의 개수를 미리 선택해야 한다. 					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			이상점에 영향을 많이 받는다.					</span></a></li>
</ol>
<div class="eg1">
<a class="b2 help" href="#m-help1a54" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
<span class="t1">정답보기</span>
<i class="ic1"></i>
</a>
</div>
<div class="tg2 loaded" id="m-help1a54" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
<strong class="tt1">정답</strong>
<div class="t2">
<i class="t2n">1</i>
<span class="t2t1">
			한번 군집이 형성되면 군집에 속하는 개체들은 다른 군집으로 이동할 수 없다. 			</span>
</div>
<br/>
<strong class="tt1">해설</strong>
<div class="t1">
		k-평균 군집은 한번 군집이 형성되더라도 다른 군집으로 이동이 가능하다.				</div>


<div class="more-c">
<strong class="tt1">비기봇 해설</strong>
<div class="t1">
				정답은 1번입니다.<br/>
<br/>
k-평균 군집화는 주어진 데이터셋을 k개의 군집으로 나누는 비지도 학습 알고리즘입니다. 이 알고리즘은 각 데이터 포인트를 가장 가까운 군집 중심에 할당하고, 군집 중심을 반복적으로 업데이트하여 최적의 군집을 찾습니다.<br/>
<br/>
1. 한번 군집이 형성되면 군집에 속하는 개체들은 다른 군집으로 이동할 수 없다.<br/>
: k-평균 군집화에서는 각 데이터 포인트가 가장 가까운 군집 중심에 할당되며, 군집 중심이 업데이트될 때마다 데이터 포인트는 다른 군집으로 이동할 수 있습니다.<br/>
<br/>
2. 초기 군집의 중심을 임의로 선택해야 한다.<br/>
: k-평균 군집화는 초기 군집 중심을 임의로 선택하는데, 이 선택이 알고리즘의 결과에 큰 영향을 미칠 수 있습니다.<br/>
<br/>
3. 군집의 개수를 미리 선택해야 한다.<br/>
: k-평균 군집화는 알고리즘을 실행하기 전에 군집의 개수를 미리 정해야 합니다. 이는 알고리즘의 중요한 전제 조건입니다.<br/>
<br/>
4. 이상점에 영향을 많이 받는다.<br/>
: k-평균 군집화는 이상점(outlier)에 민감하며, 이상점은 군집 중심의 위치를 왜곡시킬 수 있습니다.<br/>
<br/>
<br/>
k-평균 군집화에서는 군집 중심이 업데이트될 때마다 데이터 포인트는 다른 군집으로 이동할 수 있습니다. 따라서 '한번 군집이 형성되면 군집에 속하는 개체들은 다른 군집으로 이동할 수 없다'는 설명은 부적절합니다. 다른 선택지들은 k-평균 군집화의 특성을 올바르게 설명하고 있습니다.<br/>
<br/>
따라서, 정답은 '1. 한번 군집이 형성되면 군집에 속하는 개체들은 다른 군집으로 이동할 수 없다.' 입니다.<br/>
</div>
<div class="t2">
									#k-평균 군집화									# 군집 중심									# 이상점									# 초기화							</div>
</div>

</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
<div class="sg1">
<div class="w1">
<span class="g1">4과목</span>
<span class="g1">연관분석</span>
<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
</div>
</div>
<div class="tg1">
<strong class="tt1">
<span class="tt1n">55.</span>
<span class="tt1t1">
				다음 군집화 방법 중 DBSCAN, DENCLUE 기법 등 임의적인(Arbitrarity) 모양의 군집 탐색에 가장 효과적인 방법은?							</span>
</strong>
<span class="tt1t1">
</span>
</div>
<ol class="lst1">
<li class="li1"><a class="a1"><span class="t1">
			밀도기반 군집 					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			모형기반 군집 					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			격자기반 군집 					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			커널기반 군집					</span></a></li>
</ol>
<div class="eg1">
<a class="b2 help" href="#m-help1a55" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
<span class="t1">정답보기</span>
<i class="ic1"></i>
</a>
</div>
<div class="tg2 loaded" id="m-help1a55" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
<strong class="tt1">정답</strong>
<div class="t2">
<i class="t2n">1</i>
<span class="t2t1">
			밀도기반 군집 			</span>
</div>
<br/>
<strong class="tt1">해설</strong>
<div class="t1">
		밀도기반 군집분석이란 어느 점을 기준으로 주어진 반경 내에 최소 개수만큼의 데이터들을 가질수 있도록 함으로써 특정 밀도함수 혹은 밀도에 의해 군집을 형성해나가는 기법으로 DBSCAN, OPTICS, DENCLUE 등이 있다.				</div>


<div class="more-c">
<strong class="tt1">비기봇 해설</strong>
<div class="t1">
				정답은 1번입니다.<br/>
<br/>
군집화 기법은 데이터를 유사한 특성을 가진 그룹으로 나누는 방법입니다. 이 중 밀도기반 군집화는 데이터의 밀도를 기준으로 군집을 형성하는 방법으로, DBSCAN과 같은 기법이 대표적입니다. DBSCAN은 특정 반경 내에 최소한의 데이터 포인트가 존재할 때 군집을 형성하며, 노이즈를 처리할 수 있는 장점이 있습니다. 이는 임의적인 모양의 군집을 탐색하는 데 효과적입니다. 반면, 모형기반 군집화는 데이터가 특정 확률 분포를 따른다고 가정하고, 격자기반 군집화는 공간을 격자로 나누어 군집을 형성합니다. 커널기반 군집화는 데이터의 분포를 커널 함수로 표현하여 군집을 형성합니다.<br/>
<br/>
1. 밀도기반 군집 <br/>
: 밀도기반 군집화는 데이터의 밀도를 기준으로 군집을 형성하는 방법입니다. DBSCAN은 밀도기반 군집화의 대표적인 기법으로, 특정 반경 내에 최소한의 데이터 포인트가 있을 때 군집을 형성합니다. 이는 임의적인 모양의 군집을 탐색하는 데 효과적이며, 노이즈를 처리할 수 있는 장점이 있습니다.<br/>
<br/>
2. 모형기반 군집 <br/>
: 모형기반 군집화는 데이터가 특정 확률 분포를 따른다고 가정하고, 이를 통해 군집을 형성하는 방법입니다. 이는 데이터의 분포를 모델링하여 군집을 형성하지만, 임의적인 모양의 군집을 탐색하는 데는 한계가 있습니다.<br/>
<br/>
3. 격자기반 군집 <br/>
: 격자기반 군집화는 공간을 격자로 나누어 군집을 형성하는 방법입니다. 이는 데이터의 위치에 따라 군집을 형성하지만, 임의적인 모양의 군집을 탐색하는 데는 적합하지 않습니다.<br/>
<br/>
4. 커널기반 군집 <br/>
: 커널기반 군집화는 데이터의 분포를 커널 함수로 표현하여 군집을 형성하는 방법입니다. 이는 데이터의 분포를 부드럽게 표현할 수 있지만, 임의적인 모양의 군집을 탐색하는 데는 제한적입니다.<br/>
<br/>
밀도기반 군집화는 데이터의 밀도를 기준으로 군집을 형성하기 때문에 임의적인 모양의 군집을 탐색하는 데 효과적입니다. DBSCAN과 같은 기법은 노이즈를 처리할 수 있는 장점도 있습니다. 반면, 모형기반, 격자기반, 커널기반 군집화는 각각의 특성상 임의적인 모양의 군집을 탐색하는 데는 한계가 있습니다.<br/>
따라서, 정답은 '1. 밀도기반 군집' 입니다.<br/>
</div>
<div class="t2">
									#밀도기반 군집화									# DBSCAN									# 임의적 모양									# 노이즈 처리									# 군집화 기법							</div>
</div>

</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
<div class="sg1">
<div class="w1">
<span class="g1">4과목</span>
<span class="g1">연관분석</span>
<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
</div>
</div>
<div class="tg1">
<strong class="tt1">
<span class="tt1n">56.</span>
<span class="tt1t1">
				SOM(Self Organizing Maps) 알고리즘은 고차원의 데이터를 이해하기 쉬운 저차원의 뉴런(Neuron)으로 정렬하여 지도(Map)의 형태로 형상화하는 방법이다. 다음 중 SOM 방법의 설명으로 적절하지 않은 것은 무엇인가?							</span>
</strong>
<span class="tt1t1">
</span>
</div>
<ol class="lst1">
<li class="li1"><a class="a1"><span class="t1">
			입력 벡터와 가장 비슷한 연결강도 벡터를 가진 경쟁층의 뉴런이 승자이며, 승자와 그 주변의 경쟁층 뉴런에 대해서만 연결강도를 수행하는 학습 방법이다.					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			고차원의 표현을 1차원으로 표현할 수 있는 장점이 있다.					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			지도 형태의 형상화는 입력변수의 위치 관계를 그대로 보존한다는 특징이 있다.					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			자율적인(Unsupervised) 신경망 모델로서 역전파(Back Propagation) 알고리즘처럼 여러 단계의 피드백을 처리하면서 전방 패스(Feed-Forward Flow)를 사용하는 방법이다.					</span></a></li>
</ol>
<div class="eg1">
<a class="b2 help" href="#m-help1a56" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
<span class="t1">정답보기</span>
<i class="ic1"></i>
</a>
</div>
<div class="tg2 loaded" id="m-help1a56" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
<strong class="tt1">정답</strong>
<div class="t2">
<i class="t2n">4</i>
<span class="t2t1">
			자율적인(Unsupervised) 신경망 모델로서 역전파(Back Propagation) 알고리즘처럼 여러 단계의 피드백을 처리하면서 전방 패스(Feed-Forward Flow)를 사용하는 방법이다.			</span>
</div>
<br/>
<strong class="tt1">해설</strong>
<div class="t1">
		SOM의 특징은 역전파(Back Propagation) 알고리즘 등을 이용하는 인공신경망과 달리 단 하나의 전방 패스(Feed-forward flow)를 사용함으로써 속도가 매우 빠르다.				</div>


<div class="more-c">
<strong class="tt1">비기봇 해설</strong>
<div class="t1">
				정답은 4번입니다.<br/>
<br/>
SOM(Self Organizing Maps)은 고차원 데이터를 저차원으로 변환하여 시각적으로 이해하기 쉽게 만드는 비지도 학습 알고리즘입니다. 이 알고리즘은 입력 데이터의 구조를 보존하면서 뉴런의 연결 강도를 조정하여 데이터의 패턴을 학습합니다.<br/>
<br/>
1. 입력 벡터와 가장 비슷한 연결강도 벡터를 가진 경쟁층의 뉴런이 승자이며, 승자와 그 주변의 경쟁층 뉴런에 대해서만 연결강도를 수행하는 학습 방법이다.<br/>
: SOM은 입력 벡터와 가장 유사한 뉴런을 선택하고, 그 뉴런과 주변 뉴런의 연결 강도를 조정하여 학습합니다. 이는 경쟁 학습의 특징입니다.<br/>
<br/>
2. 고차원의 표현을 1차원으로 표현할 수 있는 장점이 있다.<br/>
: SOM은 고차원 데이터를 2차원 또는 3차원으로 시각화하는 데 주로 사용되며, 1차원으로 표현하는 것은 일반적이지 않습니다.<br/>
<br/>
3. 지도 형태의 형상화는 입력변수의 위치 관계를 그대로 보존한다는 특징이 있다.<br/>
: SOM의 중요한 특징 중 하나는 입력 데이터의 위치 관계를 보존하여 시각화한다는 점입니다. 이는 데이터의 구조적 특성을 유지하는 데 유리합니다.<br/>
<br/>
4. 자율적인(Unsupervised) 신경망 모델로서 역전파(Back Propagation) 알고리즘처럼 여러 단계의 피드백을 처리하면서 전방 패스(Feed-Forward Flow)를 사용하는 방법이다.<br/>
: SOM은 비지도 학습 알고리즘으로, 역전파와 같은 지도 학습의 피드백 메커니즘을 사용하지 않습니다. 대신, 경쟁 학습을 통해 뉴런의 연결 강도를 조정합니다.<br/>
<br/>
<br/>
SOM은 자율적인 비지도 학습 알고리즘으로, 역전파와 같은 지도 학습의 피드백 메커니즘을 사용하지 않습니다. 따라서 4번 선지는 SOM의 설명으로 적절하지 않습니다. 다른 선택지들은 SOM의 특성을 잘 설명하고 있습니다.<br/>
<br/>
따라서, 정답은 '4. 자율적인(Unsupervised) 신경망 모델로서 역전파(Back Propagation) 알고리즘처럼 여러 단계의 피드백을 처리하면서 전방 패스(Feed-Forward Flow)를 사용하는 방법이다.' 입니다.<br/>
</div>
<div class="t2">
									#SOM									# 비지도 학습									# 경쟁 학습									# 데이터 시각화							</div>
</div>

</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
<div class="sg1">
<div class="w1">
<span class="g1">4과목</span>
<span class="g1">연관분석</span>
<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
</div>
</div>
<div class="tg1">
<strong class="tt1">
<span class="tt1n">57.</span>
<span class="tt1t1">
				nci.data는 64개 암세포주에 대한 6830개 유전자 microarray 데이터이다. 아래는 이 자료를 이용한 군집분석 결과이다. 다음 중 아래 결과에 대한 설명으로 가장 부적절한 것은?							</span>
</strong>
<span class="tt1t1">
<a class="p1" href="exam1view1img1.php?img=7effa060-266c-80a1-0b90-e5a91247d349.png" rel="noopener" target="_blank" title="새 창">
<img alt="문제에 포함된 이미지" src="https://www.dataedupt.kr/data/img/question/7effa060-266c-80a1-0b90-e5a91247d349.png"/>
</a>
</span>
</div>
<ol class="lst1">
<li class="li1"><a class="a1"><span class="t1">
			최단 연결법을 사용한 계층적 군집분석 방법이다.					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			두 군집 사이의 거리를 각 군집에서 하나의 관측값을 뽑았을 때 나타날 수 있는 거리의 최소값으로 측정한다.					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			사슬모양의 군집이 생길 수 있다. 					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			평균연결법에 비해 계산량이 많다.					</span></a></li>
</ol>
<div class="eg1">
<a class="b2 help" href="#m-help1a57" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
<span class="t1">정답보기</span>
<i class="ic1"></i>
</a>
</div>
<div class="tg2 loaded" id="m-help1a57" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
<strong class="tt1">정답</strong>
<div class="t2">
<i class="t2n">4</i>
<span class="t2t1">
			평균연결법에 비해 계산량이 많다.			</span>
</div>
<br/>
<strong class="tt1">해설</strong>
<div class="t1">
		최단 연결법은 평균연결법에 비해 계산량이 많지 않다.				</div>


<div class="more-c">
<strong class="tt1">비기봇 해설</strong>
<div class="t1">
				정답은 4번입니다.<br/>
<br/>
이 문제는 군집분석 방법 중 하나인 최단 연결법(single linkage)에 대한 이해를 평가합니다. 최단 연결법은 두 군집 사이의 거리를 각 군집에서 하나의 관측값을 뽑았을 때 나타날 수 있는 거리의 최소값으로 측정합니다. 이 방법은 사슬모양의 군집을 형성할 수 있으며, 평균연결법에 비해 계산량이 적습니다.<br/>
<br/>
1. 최단 연결법을 사용한 계층적 군집분석 방법이다.<br/>
: 최단 연결법은 두 군집 사이의 거리를 측정할 때, 각 군집에서 하나의 관측값을 뽑아 나타날 수 있는 거리의 최소값을 사용합니다.<br/>
<br/>
2. 두 군집 사이의 거리를 각 군집에서 하나의 관측값을 뽑았을 때 나타날 수 있는 거리의 최소값으로 측정한다.<br/>
: 최단 연결법의 특징 중 하나는 두 군집 사이의 거리를 최소값으로 측정한다는 점입니다.<br/>
<br/>
3. 사슬모양의 군집이 생길 수 있다.<br/>
: 최단 연결법은 사슬모양의 군집을 형성할 수 있는 특성이 있습니다.<br/>
<br/>
4. 평균연결법에 비해 계산량이 많다.<br/>
: 최단 연결법은 평균연결법에 비해 계산량이 적습니다. 평균연결법은 모든 쌍의 평균 거리를 계산해야 하기 때문에 더 많은 계산이 필요합니다.<br/>
<br/>
<br/>
최단 연결법은 평균연결법에 비해 계산량이 적습니다. 평균연결법은 모든 쌍의 평균 거리를 계산해야 하기 때문에 더 많은 계산이 필요합니다. 따라서 4번 선택지가 부적절한 설명입니다.<br/>
<br/>
따라서, 정답은 '4. 평균연결법에 비해 계산량이 많다.' 입니다.<br/>
</div>
<div class="t2">
									#최단 연결법									# 군집분석									# 최소값									# 사슬모양							</div>
</div>

</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
<div class="sg1">
<div class="w1">
<span class="g1">4과목</span>
<span class="g1">텍스트 마이닝</span>
<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
</div>
</div>
<div class="tg1">
<strong class="tt1">
<span class="tt1n">58.</span>
<span class="tt1t1">
				다음 중 연관성 분석에 대한 설명으로 부적절한 것은?							</span>
</strong>
<span class="tt1t1">
</span>
</div>
<ol class="lst1">
<li class="li1"><a class="a1"><span class="t1">
			Apriori 알고리즘은 최소지지도 보다 큰 빈발항목집합에서 높은 측도(신뢰도, 향상도) 값을 갖는 연관규칙을 구하는 방법이다.					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			연관성 분석은 하나 이상의 제품이나 서비스를 포함하는 거래 내역을 이용하여 동시에 구매되는 제품별 거래 빈도표를 통해 규칙을 찾는데서 시작했다.					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			품목 A와 품목 B의 구매가 상호 관련이 없다면 향상도는 1이 된다.					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			사건들이 어떤 순서로 일어나고 이 사건들 사이에 연관성을 알아내는 것이 시차 연관분석이지만 원인과 결과의 형태로 해석되지는 않는다.					</span></a></li>
</ol>
<div class="eg1">
<a class="b2 help" href="#m-help1a58" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
<span class="t1">정답보기</span>
<i class="ic1"></i>
</a>
</div>
<div class="tg2 loaded" id="m-help1a58" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
<strong class="tt1">정답</strong>
<div class="t2">
<i class="t2n">4</i>
<span class="t2t1">
			사건들이 어떤 순서로 일어나고 이 사건들 사이에 연관성을 알아내는 것이 시차 연관분석이지만 원인과 결과의 형태로 해석되지는 않는다.			</span>
</div>
<br/>
<strong class="tt1">해설</strong>
<div class="t1">
		시차 연관분석은 시간이 지남에 따라 어떤 소비형태를 보이는가에 대한 분석으로 원인과 결과의 형태로 해석이 가능해서 결과가 더욱 유용하게 쓰인다.				</div>


<div class="more-c">
<strong class="tt1">비기봇 해설</strong>
<div class="t1">
				1. Apriori 알고리즘은 연관성 분석에서 가장 널리 사용되는 알고리즘 중 하나로, 빈발항목집합을 찾아내는 방법을 제공한다. 이는 연관성 분석의 핵심적인 과정이므로 이 설명은 적절하다.<br/>
<br/>
2. 연관성 분석은 고객의 구매 패턴을 분석하여 서로 관련이 있는 제품을 찾아내는 방법이다. 이를 통해 상품 추천 등의 마케팅 전략에 활용할 수 있다. 따라서 이 설명도 적절하다.<br/>
<br/>
3. 향상도는 두 품목의 독립성을 측정하는 지표로, 향상도가 1이라는 것은 두 품목이 서로 독립적이라는 의미이다. 따라서 이 설명도 적절하다.<br/>
<br/>
4. 시차 연관분석은 사건들 사이의 시간적 순서를 고려하여 연관성을 분석하는 방법이다. 그러나 이 방법은 사건들 사이의 원인과 결과 관계를 분석하는 것이 아니라, 단지 사건들이 어떤 순서로 발생하는지를 분석하는 것이다. 따라서 이 설명은 부적절하다.<br/>
</div>
<div class="t2">
									# 연관성 분석									# Apriori 알고리즘									# 빈발항목집합									# 향상도									# 시차 연관분석									# 신뢰도							</div>
</div>

</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
<div class="sg1">
<div class="w1">
<span class="g1">4과목</span>
<span class="g1">군집분석</span>
<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
</div>
</div>
<div class="tg1">
<strong class="tt1">
<span class="tt1n">59.</span>
<span class="tt1t1">
				다음 중 이상값 자료에 민감한 k-평균 군집의 단점을 보완하기 위해 평균 대신 사용되는 것으로 적절한 것은?							</span>
</strong>
<span class="tt1t1">
</span>
</div>
<ol class="lst1">
<li class="li1"><a class="a1"><span class="t1">
			중앙값					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			최대값					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			조화평균					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			가중평균					</span></a></li>
</ol>
<div class="eg1">
<a class="b2 help" href="#m-help1a59" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
<span class="t1">정답보기</span>
<i class="ic1"></i>
</a>
</div>
<div class="tg2 loaded" id="m-help1a59" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
<strong class="tt1">정답</strong>
<div class="t2">
<i class="t2n">1</i>
<span class="t2t1">
			중앙값			</span>
</div>
<br/>
<strong class="tt1">해설</strong>
<div class="t1">
		k-means 기법은 극도로 큰 값(혹은 작은 값)이 데이터의 분포를 사실상 왜곡할 수 있기 때문에 이상치에 민감하여 군집에서 객체들의 평균값을 취하 는 대신에 군집에서 가장 중심에 위치한 객체인 median을 사용하는 k-medoids 군집화 알고리즘이 있다.				</div>


<div class="more-c">
<strong class="tt1">비기봇 해설</strong>
<div class="t1">
				정답은 1번입니다.<br/>
<br/>
k-평균 군집화는 데이터의 중심을 평균으로 계산하여 군집을 형성하는 방법입니다. 그러나 평균은 이상값에 민감하여 군집의 중심이 왜곡될 수 있습니다. 이를 보완하기 위해 이상값의 영향을 덜 받는 대체 통계량을 사용할 수 있습니다.<br/>
<br/>
1. 중앙값<br/>
: 중앙값은 데이터의 중간값으로, 이상값의 영향을 덜 받습니다. 따라서 군집의 중심을 계산할 때 이상값에 민감한 평균 대신 사용할 수 있습니다.<br/>
<br/>
2. 최대값<br/>
: 최대값은 데이터 집합에서 가장 큰 값으로, 이상값에 매우 민감합니다. 따라서 군집의 중심을 계산할 때 적절하지 않습니다.<br/>
<br/>
3. 조화평균<br/>
: 조화평균은 주로 비율 데이터에 사용되며, 이상값에 대한 민감도가 평균보다 낮지만 중앙값만큼 강력하지 않습니다.<br/>
<br/>
4. 가중평균<br/>
: 가중평균은 각 데이터에 가중치를 부여하여 평균을 계산하는 방법으로, 이상값의 영향을 줄이기 위해서는 적절한 가중치 설정이 필요합니다.<br/>
<br/>
<br/>
중앙값은 이상값의 영향을 덜 받기 때문에 k-평균 군집화에서 평균 대신 사용할 수 있는 적절한 대안입니다. 다른 선택지들은 이상값에 민감하거나, 군집의 중심을 계산하는 데 적합하지 않습니다.<br/>
<br/>
따라서, 정답은 '1. 중앙값' 입니다.<br/>
</div>
<div class="t2">
									#k-평균 군집화									# 이상값									# 중앙값									# 평균							</div>
</div>

</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
<div class="sg1">
<div class="w1">
<span class="g1">4과목</span>
<span class="g1">연관분석</span>
<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
</div>
</div>
<div class="tg1">
<strong class="tt1">
<span class="tt1n">60.</span>
<span class="tt1t1">
				다음 중 R에서 연관성 분석을 위해 apriori함수를 활용하여 연관 규칙을 생성하였다. 다음 중 생성된 연관 규칙을 보기 위해 사용되는 함수로 가장 적절한 것은?							</span>
</strong>
<span class="tt1t1">
</span>
</div>
<ol class="lst1">
<li class="li1"><a class="a1"><span class="t1">
			sort()					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			arule()					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			inspect()					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			apriori()					</span></a></li>
</ol>
<div class="eg1">
<a class="b2 help" href="#m-help1a60" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
<span class="t1">정답보기</span>
<i class="ic1"></i>
</a>
</div>
<div class="tg2 loaded" id="m-help1a60" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
<strong class="tt1">정답</strong>
<div class="t2">
<i class="t2n">3</i>
<span class="t2t1">
			inspect()			</span>
</div>
<br/>
<strong class="tt1">해설</strong>
<div class="t1">
		apriori 함수를 활용해 생성한 연관규칙은 inspect( ) 함수를 통해 확인이 가능하다.				</div>


<div class="more-c">
<strong class="tt1">비기봇 해설</strong>
<div class="t1">
				정답은 3번입니다.<br/>
<br/>
R에서 연관성 분석을 수행할 때 apriori 함수를 사용하여 연관 규칙을 생성한 후, 생성된 연관 규칙을 확인하기 위해 적절한 함수를 선택하는 것이 중요합니다. 이 문제는 생성된 연관 규칙을 보기 위해 어떤 함수를 사용하는 것이 적절한지를 묻고 있습니다.<br/>
<br/>
1. sort()<br/>
: sort() 함수는 일반적으로 데이터나 객체를 정렬하는 데 사용됩니다. 연관 규칙을 생성한 후 이를 정렬할 수는 있지만, 직접적으로 규칙을 보는 데 사용되지는 않습니다.<br/>
<br/>
2. arule()<br/>
: arule()는 R에서 연관 규칙을 다루는 패키지의 이름과 유사하지만, 실제로 존재하지 않는 함수입니다. 따라서 연관 규칙을 보기 위해 사용할 수 없습니다.<br/>
<br/>
3. inspect()<br/>
: inspect() 함수는 arules 패키지에서 제공하는 함수로, 생성된 연관 규칙을 자세히 볼 수 있도록 해줍니다. 이 함수는 연관 규칙의 내용을 확인하는 데 적합합니다.<br/>
<br/>
4. apriori()<br/>
: apriori() 함수는 연관 규칙을 생성하는 데 사용되는 함수입니다. 생성된 규칙을 보는 데 직접 사용되지는 않습니다.<br/>
<br/>
<br/>
inspect() 함수는 arules 패키지에서 제공하는 함수로, 생성된 연관 규칙을 확인하는 데 사용됩니다. 다른 선택지들은 연관 규칙을 직접적으로 확인하는 데 적합하지 않거나 존재하지 않는 함수입니다.<br/>
<br/>
따라서, 정답은 '3. inspect()' 입니다.<br/>
</div>
<div class="t2">
									#R									# 연관성 분석									# apriori									# inspect							</div>
</div>

</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
<div class="sg1">
<div class="w1">
<span class="g1">4과목</span>
<span class="g1">텍스트 마이닝</span>
<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
</div>
</div>
<div class="tg1">
<strong class="tt1">
<span class="tt1n">61.</span>
<span class="tt1t1">
				다음 중 아래 거래 전표에서 연관 규칙 “빵 → 우유”의 향상도를 구한 것으로 알맞은 것은?							</span>
</strong>
<span class="tt1t1">
<a class="p1" href="exam1view1img1.php?img=99719423-851c-9b8c-ce13-1c17d1dc56d0.png" rel="noopener" target="_blank" title="새 창">
<img alt="문제에 포함된 이미지" src="https://www.dataedupt.kr/data/img/question/99719423-851c-9b8c-ce13-1c17d1dc56d0.png"/>
</a>
</span>
</div>
<ol class="lst1">
<li class="li1"><a class="a1"><span class="t1">
			30%					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			50%					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			83%					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			100%					</span></a></li>
</ol>
<div class="eg1">
<a class="b2 help" href="#m-help1a61" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
<span class="t1">정답보기</span>
<i class="ic1"></i>
</a>
</div>
<div class="tg2 loaded" id="m-help1a61" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
<strong class="tt1">정답</strong>
<div class="t2">
<i class="t2n">3</i>
<span class="t2t1">
			83%			</span>
</div>
<br/>
<strong class="tt1">해설</strong>
<div class="t1">
		빵→우유의 향상도는 ({{{300}over{1000}} over {{600}over{1000} times {600}over{1000}}}={{1000} over {12}} = 83%)이다.				</div>


<div class="more-c">
<strong class="tt1">비기봇 해설</strong>
<div class="t1">
				향상도는 규칙 A→B에서 A가 구매되지 않았을 때 품목 B의 구매확률에 비해 A가 구매됐을 때 품목 B의 구매확률의 증가 비입니다.<br/>
<br/>
향상도 = (A와 B가 동시에 포함된 거래) / (A를 포함하는 거래 X B를 포함하는 거래)<br/>
<br/>
A와 B가 동시에 포함된 거래 = 300/1000 = 0.3<br/>
A를 포함하는 거래 = 600/1000=0.6<br/>
B를 포함하는 거래 = 600/1000=0.6<br/>
<br/>
0.3/(0.6*0.6) = 0.8333이므로 정답은 3번 83%입니다.<br/>
</div>
<div class="t2">
									# 연관 규칙									# 향상도									# 지지도									# 신뢰도									# 거래 건수							</div>
</div>

</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
<div class="sg1">
<div class="w1">
<span class="g1">4과목</span>
<span class="g1">텍스트 마이닝</span>
<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
</div>
</div>
<div class="tg1">
<strong class="tt1">
<span class="tt1n">62.</span>
<span class="tt1t1">
				아래 거래 전표에서 연관 규칙 “A→B”의 향상도는 얼마인가?(소수점 첫째자리에서 반올림)							</span>
</strong>
<span class="tt1t1">
<a class="p1" href="exam1view1img1.php?img=e63e16c6-5ee3-16e3-c314-2b5f38bc4751.png" rel="noopener" target="_blank" title="새 창">
<img alt="문제에 포함된 이미지" src="https://www.dataedupt.kr/data/img/question/e63e16c6-5ee3-16e3-c314-2b5f38bc4751.png"/>
</a>
</span>
</div>
<ol class="lst1">
<li class="li1"><a class="a1"><span class="t1">
			30%					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			50%					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			83%					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			100%					</span></a></li>
</ol>
<div class="eg1">
<a class="b2 help" href="#m-help1a62" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
<span class="t1">정답보기</span>
<i class="ic1"></i>
</a>
</div>
<div class="tg2 loaded" id="m-help1a62" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
<strong class="tt1">정답</strong>
<div class="t2">
<i class="t2n">3</i>
<span class="t2t1">
			83%			</span>
</div>
<br/>
<strong class="tt1">해설</strong>
<div class="t1">
		향상도는 ({P(B|A) over P(B)}={P(A cap B) over P(A)P(B)}={A와 B가 동시에 포함된 거래수 over A를 포함하는 거래수 times B를 포함하는 거래수}={신뢰도 over P(B)})로 계산할 수 있다.				</div>


<div class="more-c">
<strong class="tt1">비기봇 해설</strong>
<div class="t1">
				연관 규칙의 향상도(Lift)는 A와 B가 독립적인지 아닌지를 판단하는 지표로, 향상도가 1이면 두 항목은 독립적이라는 의미이다. 향상도가 1보다 크면 두 항목이 함께 일어날 확률이 높고, 1보다 작으면 두 항목이 함께 일어날 확률이 낮다.<br/>
<br/>
향상도는 다음과 같이 계산한다.<br/>
향상도(Lift) = P(A∩B) / (P(A) * P(B))<br/>
<br/>
여기서 P(A)는 A가 일어날 확률, P(B)는 B가 일어날 확률, P(A∩B)는 A와 B가 함께 일어날 확률을 의미한다.<br/>
<br/>
문제에서 A의 거래건수는 100건, B의 거래건수는 (B, D)와 (A, B, D)를 합친 350건, A와 B가 함께 일어난 거래건수는 (A, B, D)인 250건이다.<br/>
<br/>
따라서 향상도는 (250/800) / ((100/800) * (350/800)) = 0.8333... ≈ 83%(소수점 첫째자리에서 반올림)이다.<br/>
</div>
<div class="t2">
									#연관규칙									# 지지도									# 향상도									# 신뢰도									# 장바구니 분석							</div>
</div>

</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
<div class="sg1">
<div class="w1">
<span class="g1">4과목</span>
<span class="g1">텍스트 마이닝</span>
<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
</div>
</div>
<div class="tg1">
<strong class="tt1">
<span class="tt1n">63.</span>
<span class="tt1t1">
				아래는 쇼핑몰의 거래 내역이다. 다음 중 규칙 “사과 → 딸기”에 대한 향상도(Lift)는 얼마인가?							</span>
</strong>
<span class="tt1t1">
<a class="p1" href="exam1view1img1.php?img=36d29a0b-fd50-41ee-eea5-419a4c342af6.png" rel="noopener" target="_blank" title="새 창">
<img alt="문제에 포함된 이미지" src="https://www.dataedupt.kr/data/img/question/36d29a0b-fd50-41ee-eea5-419a4c342af6.png"/>
</a>
</span>
</div>
<ol class="lst1">
<li class="li1"><a class="a1"><span class="t1">
			0.3/(0.6 × 0.45) 					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			0.4/(0.7 × 0.45) 					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			0.3/(0.7 × 0.45) 					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			0.4/(0.6 × 0.45)					</span></a></li>
</ol>
<div class="eg1">
<a class="b2 help" href="#m-help1a63" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
<span class="t1">정답보기</span>
<i class="ic1"></i>
</a>
</div>
<div class="tg2 loaded" id="m-help1a63" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
<strong class="tt1">정답</strong>
<div class="t2">
<i class="t2n">3</i>
<span class="t2t1">
			0.3/(0.7 × 0.45) 			</span>
</div>
<br/>
<strong class="tt1">해설</strong>
<div class="t1">
		사과 → 딸기의 향상도를 게산하면 ({P(딸기|사과) over P(딸기)}=({P(사과 cap 딸기) over P(사과)P(딸기)}={{60 over 200} over{140 over 200} times {90 over 200}}={0.3 over 0.7 times 0.45})이다.				</div>


<div class="more-c">
<strong class="tt1">비기봇 해설</strong>
<div class="t1">
				1단계: 향상도(Lift) 계산법을 이해한다. 향상도는 연관규칙분석에서 두 항목의 독립성을 판단하는 지표로, 향상도가 1보다 크면 두 항목이 서로 양의 상관관계를, 1보다 작으면 음의 상관관계를, 1이면 독립적인 관계를 가진다고 해석한다.<br/>
향상도는 다음과 같이 계산한다: (A와 B가 동시에 일어날 확률) / (A가 일어날 확률 × B가 일어날 확률)<br/>
<br/>
2단계: 각 항목이 일어날 확률을 계산한다. 사과가 일어날 확률은 140/200 = 0.7, 딸기가 일어날 확률은 90/200 = 0.45, 사과와 딸기가 동시에 일어날 확률은 60/200 = 0.3이다.<br/>
<br/>
3단계: 향상도를 계산한다. (0.3) / (0.7 × 0.45)  이다.<br/>
<br/>
따라서, 정답은 3번이다.<br/>
</div>
<div class="t2">
									#연관규칙									# 지지도									# 향상도									# 신뢰도									# 장바구니 분석							</div>
</div>

</div>
</div>
<!-- /cp1question1 -->





<script>
/* === AUTO-PATCH: answer-toggle-v2 === */
(function () {
  function qsa(sel, root) { return Array.from((root || document).querySelectorAll(sel)); }
  function qs(sel, root) { return (root || document).querySelector(sel); }

  function getPanelFromBtn(btn) {
    const href = btn && btn.getAttribute('href');
    if (!href || !href.startsWith('#')) return null;
    return document.querySelector(href);
  }

  function setHelpLabel(btn, open) {
    const t = btn ? btn.querySelector('.t1') : null;
    if (t) t.textContent = open ? '정답닫기' : '정답보기';
    if (btn) btn.setAttribute('aria-expanded', String(open));
  }

  function panelIsOpen(panel) {
    if (!panel) return false;
    if (panel.style.display) return panel.style.display !== 'none';
    return getComputedStyle(panel).display !== 'none';
  }

  function openPanel(btn, panel) {
    if (!panel) return;
    panel.style.display = 'block';
    panel.classList.add('loaded');     // 기존 테마 연동
    setHelpLabel(btn, true);
  }

  function closePanel(btn, panel) {
    if (!panel) return;
    panel.style.display = 'none';
    setHelpLabel(btn, false);
  }

  // ✅ 전체 정답 보기/닫기
  window.controlAllAnswers = function (show) {
    qsa('.tg2').forEach(panel => {
      panel.style.display = show ? 'block' : 'none';
      if (show) panel.classList.add('loaded');
    });
    qsa('a.b2.help').forEach(btn => setHelpLabel(btn, show));
  };

  // ✅ 개별 정답보기 토글 (이게 없으면 "클릭해도 아무 동작 없음")
  function onHelpClick(e) {
    const btn = e.target.closest('a.b2.help[href^="#"]');
    if (!btn) return;
    e.preventDefault();

    const panel = getPanelFromBtn(btn);
    if (!panel) return;

    panelIsOpen(panel) ? closePanel(btn, panel) : openPanel(btn, panel);
  }

  // ✅ 보기 클릭 → 정오답 판정 + s1/s2 적용 + 자동 정답보기
  function onOptionPick(e) {
    const li = e.target.closest('.cp1question1 .lst1 .li1');
    if (!li) return;

    const qBox = li.closest('.cp1question1');
    if (!qBox) return;

    const btn = qs('a.b2.help[href^="#"]', qBox);
    const panel = getPanelFromBtn(btn);

    // 정답 번호(i.t2n)는 해설 패널 안에 있음(1-based)
    const n = panel ? panel.querySelector('i.t2n') : null;
    const correctIdx = n ? parseInt((n.textContent || '').trim(), 10) : NaN;

    const options = qsa('.lst1 .li1', qBox);
    const idx = options.indexOf(li) + 1; // 1-based

    if (!Number.isFinite(correctIdx) || correctIdx <= 0) return;

    const isCorrect = idx === correctIdx;
    qBox.setAttribute('data-answer-state', isCorrect ? 'correct' : 'wrong');

    // 헤더 표시 (정답 s1 | 오답 s2)
    const b = qs('.w1 b', qBox);
    if (b) b.className = isCorrect ? 's1' : 's2';

    // 보기에도 클래스 부여(원하면 CSS로 강조)
    options.forEach((opt, i) => {
      opt.classList.remove('is-correct', 'is-wrong');
      if (i + 1 === correctIdx) opt.classList.add('is-correct');
    });
    li.classList.add(isCorrect ? 'is-correct' : 'is-wrong');

    // 자동 정답보기
    openPanel(btn, panel);
  }

  // capture로 등록: 다른 스크립트가 click을 막아도 최대한 동작
  document.addEventListener('click', onHelpClick, true);
  document.addEventListener('click', onOptionPick, true);
})();
</script>

<!-- AUTO:score-counter start -->
<script>
(function () {
  function qsa(sel, root) { return Array.from((root || document).querySelectorAll(sel)); }
  function qs(sel, root) { return (root || document).querySelector(sel); }

  function setText(el, n) {
    if (!el) return;
    el.textContent = String(n) + '개';
  }

  function updateTotal(total) {
    const block = qs('.cp1dlist2');
    if (!block) return;
    qsa('.cp1dlist2 .di1', block).forEach(li => {
      const label = (qs('.dt1', li)?.textContent || '').trim();
      if (label === '총 문제') {
        const dd = qs('.dd1', li);
        if (dd) dd.textContent = String(total) + '개';
      }
    });
  }

  function getPanelFromQ(qBox) {
    const btn = qBox.querySelector('a.b2.help[href^="#"]');
    if (!btn) return null;
    const href = btn.getAttribute('href');
    if (!href || !href.startsWith('#')) return null;
    return document.querySelector(href);
  }

  function getCorrectIndex(panel) {
    const n = panel ? panel.querySelector('i.t2n') : null;
    if (!n) return null;
    const v = parseInt((n.textContent || '').trim(), 10);
    return Number.isFinite(v) ? v : null; // 1-based
  }

  function recompute() {
    const total = qsa('.cp1question1').length;
    let correct = 0;
    let wrong = 0;

    qsa('.cp1question1').forEach(qBox => {
      const state = qBox.getAttribute('data-answer-state');
      if (state === 'correct') correct += 1;
      else if (state === 'wrong') wrong += 1;
    });

    const unanswered = Math.max(0, total - (correct + wrong));

    updateTotal(total);
    setText(qs('.cp1dlist2 .em1'), correct);
    setText(qs('.cp1dlist2 .em2'), wrong);
    setText(qs('.cp1dlist2 .em3'), unanswered);
  }

  function handle(e) {
    const li = e.target.closest('.cp1question1 .lst1 .li1');
    if (!li) return;

    const qBox = li.closest('.cp1question1');
    if (!qBox) return;

    const options = qsa('.lst1 .li1', qBox);
    const idx = options.indexOf(li) + 1; // 1-based
    if (idx <= 0) return;

    const panel = getPanelFromQ(qBox);
    const correctIdx = getCorrectIndex(panel);
    if (!correctIdx) {
      qBox.removeAttribute('data-answer-state');
      recompute();
      return;
    }

    qBox.setAttribute('data-answer-state', (idx === correctIdx) ? 'correct' : 'wrong');
    recompute();
  }

  // click이 막혀도 동작하도록 pointerup도 함께 수신(충돌 방어)
  document.addEventListener('click', handle, true);
  document.addEventListener('pointerup', handle, true);

  function init() { recompute(); }
  if (document.readyState === 'loading') document.addEventListener('DOMContentLoaded', init);
  else init();
})();
</script>
<!-- AUTO:score-counter end -->

</body>
</html>
