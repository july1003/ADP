<html lang="ko" style="" class="cssscrollbar Desktop PC zoom object-fit gteIE9orSUA Chrome width-large lt-width-xlarge"><head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>예상문제 </title>
<style>
/* AUTO:exam-ui start */
/* 클릭 가능 UX */
a.b2.help,
.cp1question1 .lst1 .li1,
.cp1question1 .lst1 .li1 a {
  cursor: pointer;
}
/* hover (navy) */
.cp1question1 .lst1 .li1:hover {
  background: rgba(31, 42, 68, 0.06);
}
/* 선택 표시 (navy) */
.cp1question1 .lst1 .li1.is-selected {
  background: rgba(31, 42, 68, 0.12);
  border-radius: 6px;
}
.cp1question1 .lst1 .li1.is-selected .t1 {
  font-weight: 600;
  color: #2980b9; /* 딥 블루 */
}
/* 정답 (navy) */
.cp1question1 .lst1 .li1.is-correct {
  background: rgba(52, 152, 219, 0.18); /* 라이트 블루 */
  border-radius: 6px;
}
.cp1question1 .lst1 .li1.is-correct .t1 {
  font-weight: 700;
  color: #2980b9; /* 딥 블루 */
}
/* 오답 */
.cp1question1 .lst1 .li1.is-wrong {
  background: rgba(160, 30, 30, 0.12);
  border-radius: 6px;
}
.cp1question1 .lst1 .li1.is-wrong .t1 {
  font-weight: 600;
  color: #7a1f1f;
}
/* 보기 버튼 (navy) */
a.b2.help {
  color: #2980b9; /* 딥 블루 */
}
a.b2.help.on {
  font-weight: 600;
}
/* AUTO:exam-ui end */
.li1 {padding:4px 0px; line-height:1.2;font-size:16px}


/* AUTO:clickable-ui start */
a.b2.help,
.cp1question1 .lst1 .li1,
.cp1question1 .lst1 .li1 a {
  cursor: pointer;
}
.cp1question1 .lst1 .li1:hover {
  background: rgba(0, 0, 0, 0.04);
}
a.b2.help:hover {
  opacity: 0.85;
}
/* AUTO:clickable-ui end */
/* AUTO:mobile-scroll-fix start */
html {
  scroll-behavior: smooth;
}
.container {
  max-width: 600px;
  width: 100%;
  margin: 0 auto;
}
/* AUTO:mobile-scroll-fix end */
body {width:100%;}
	.eg1 {padding:10px 0px; text-align:center;width:100%;}
	.tg2 {border-bottom:1px solid #ddd;padding:5% 5%;display:none}
	.cp1question1 {padding-bottom:12px;}
	img {
	  width: 100%;
	  height: 100%;
	  object-fit: contain; /* 또는 cover */
	}
h2 a {
  font-size: 16px;        /* 글씨 크기 */
  text-decoration: none;  /* 밑줄 제거 */
  color: #333;            /* 기본 글자 색 */
  font-weight: 500;       /* 약간 두껍게 */
  transition: color 0.3s ease; /* hover 시 부드럽게 색 변화 */
}
h2 a:hover {
  color: #007acc;         /* hover 시 포인트 색 */
}

/* AUTO:cp1dlist2-style start */
.cp1dlist2 {
  display: flex;
  justify-content: flex-end;
  background-color: #f0f0f0;
  border-radius: 12px;
  padding: 10px 15px;
}

.cp1dlist2 ul {
  list-style: none;
  margin: 0;
  padding: 0;
  display: flex;
  gap: 10px;
}

.em2 {
  color: #d63031;
}
/* AUTO:cp1dlist2-style end */

</style>
</head>
<body>
<div class="container clearfix">
<div id="body" tabindex="-1">
<!-- container -->
<div class="container clearfix">
<!-- #forPrint -->
<div id="forPrint">
<!-- _content -->
<div id="body_content">
<h2><a href="./index.html"> &lt; 돌아가기</a>

<span class="all-controls" style="margin-left: 15px; vertical-align: middle;">
    <button type="button" onclick="window.controlAllAnswers(true)" style="padding: 6px 12px; background-color: #2c3e50; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 13px; font-weight: bold;">전체 정답 보기</button>
    <button type="button" onclick="window.controlAllAnswers(false)" style="padding: 6px 12px; background-color: #95a5a6; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 13px; font-weight: bold; margin-left: 5px;">전체 가리기</button>
</span></h2>
<!-- container -->
<div class="container clearfix">
<!-- cp1dlist2 -->
<div class="cp1dlist2">
<ul class="dl1">
<li class="di1">
<a class="a1">
<b class="dt1">총 문제</b>
<span class="dd1">20개</span>
</a>
</li>
<li class="di1">
<a class="a1">
<b class="dt1">맞춘 문제</b>
<span class="dd1"><b class="em1">0개</b></span>
</a>
</li>
<li class="di1">
<a class="a1">
<b class="dt1">틀린 문제</b>
<span class="dd1"><b class="em2">0개</b></span>
</a>
</li>
<li class="di1">
<a class="a1">
<b class="dt1">안 푼 문제</b>
<span class="dd1"><b class="em3">20개</b></span>
</a>
</li>
</ul>
</div>
<!-- /cp1dlist2 -->
<h3 class="hb1 h3">6장 - 비정형 데이터 마이닝</h3>
<!-- cp1question1 -->
<div class="cp1question1">
<div class="sg1">
<div class="w1">
<span class="g1">4과목</span>
<span class="g1">텍스트 마이닝</span>
<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
</div>
</div>
<div class="tg1">
<strong class="tt1">
<span class="tt1n">1.</span>
<span class="tt1t1">
				웹 콘텐츠나 PDF, 마이크로소프트 오피스 파일, XML, 텍스트 파일 등 다양한 포맷의 문서로부터 텍스트를 추출해 고품질의 정보를 도출하는 과정을 무엇이라고 하는가?							</span>
</strong>
<span class="tt1t1">
</span>
</div>
<ol class="lst1">
<li class="li1"><a class="a1"><span class="t1">
			텍스트 마이닝					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			로지스틱 회귀분석					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			시뮬레이션					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			사회연결망 분석					</span></a></li>
</ol>
<div class="eg1">
<a class="b2 help" href="#m-help1a1" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
<span class="t1">정답보기</span>
<i class="ic1"></i>
</a>
</div>
<div class="tg2 loaded" id="m-help1a1" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
<strong class="tt1">정답</strong>
<div class="t2">
<i class="t2n">1</i>
<span class="t2t1">
			텍스트 마이닝			</span>
</div>
<br/>
<strong class="tt1">해설</strong>
<div class="t1">
		텍스트 마이닝은 텍스트를 사용하여 패턴이나 관계를 추출하고 그 안에서 의미 있는 정보나 가치를 발굴하여 해석하는 일련의 과정이다.				</div>


<div class="more-c">
<strong class="tt1">비기봇 해설</strong>
<div class="t1">
				정답은 1번입니다.<br/>
<br/>
문제는 다양한 포맷의 문서로부터 텍스트를 추출하여 고품질의 정보를 도출하는 과정을 묻고 있습니다. 이는 데이터 분석의 한 분야로, 비정형 데이터를 처리하여 유의미한 정보를 얻는 것을 목표로 합니다.<br/>
<br/>
1. 텍스트 마이닝<br/>
: 텍스트 마이닝은 비정형 데이터인 텍스트 데이터를 분석하여 유의미한 정보를 추출하는 과정입니다. 이는 주로 자연어 처리 기술을 활용하여 수행됩니다.<br/>
<br/>
2. 로지스틱 회귀분석<br/>
: 로지스틱 회귀분석은 통계적 방법으로, 주로 이진 종속 변수와 독립 변수 간의 관계를 모델링하는 데 사용됩니다. 텍스트 추출과는 직접적인 관련이 없습니다.<br/>
<br/>
3. 시뮬레이션<br/>
: 시뮬레이션은 실제 시스템의 동작을 모방하여 결과를 예측하는 방법으로, 주로 물리적 시스템이나 경제 모델링에 사용됩니다. 텍스트 추출과는 관련이 없습니다.<br/>
<br/>
4. 사회연결망 분석<br/>
: 사회연결망 분석은 네트워크 이론을 기반으로 사회적 관계를 분석하는 방법입니다. 이는 주로 사람들 간의 관계를 시각화하고 분석하는 데 사용되며, 텍스트 추출과는 관련이 없습니다.<br/>
<br/>
<br/>
텍스트 마이닝은 다양한 포맷의 문서로부터 텍스트를 추출하여 고품질의 정보를 도출하는 과정과 직접적으로 관련이 있습니다. 다른 선택지들은 각각의 고유한 분석 방법을 설명하고 있지만, 텍스트 추출과는 직접적인 관련이 없습니다.<br/>
<br/>
따라서, 정답은 '1. 텍스트 마이닝' 입니다.<br/>
</div>
<div class="t2">
									#텍스트 마이닝									# 데이터 분석									# 자연어 처리									# 비정형 데이터							</div>
</div>

</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
<div class="sg1">
<div class="w1">
<span class="g1">4과목</span>
<span class="g1">통계분석</span>
<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
</div>
</div>
<div class="tg1">
<strong class="tt1">
<span class="tt1n">2.</span>
<span class="tt1t1">
				텍스트 마이닝의 특징에 대해 설명한 것 중 맞는 것은?							</span>
</strong>
<span class="tt1t1">
</span>
</div>
<ol class="lst1">
<li class="li1"><a class="a1"><span class="t1">
			텍스트를 어근과 어미로 구분해서 하나의 feature로 만들어내는 단계가 중요하므로 언어에 대한 이해는 중요하지만 문화와 관습까지 이해할 필요는 없다.					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			영어는 세계 공용어로써 많은 나라에서 활용하고 있기 때문에 국가별로 텍스트 마이닝 할 필요는 없다.					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			자연어 처리 분야에서 분석 결과를 평가하기 위해 사용하는 방법론 가운데 대표적인 것은 정밀도(precision)와 재현율(recall)이다.					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			corpus는 데이터 마이닝의 절차 중 데이터 마트를 생성하는 단계이다.					</span></a></li>
</ol>
<div class="eg1">
<a class="b2 help" href="#m-help1a2" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
<span class="t1">정답보기</span>
<i class="ic1"></i>
</a>
</div>
<div class="tg2 loaded" id="m-help1a2" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
<strong class="tt1">정답</strong>
<div class="t2">
<i class="t2n">3</i>
<span class="t2t1">
			자연어 처리 분야에서 분석 결과를 평가하기 위해 사용하는 방법론 가운데 대표적인 것은 정밀도(precision)와 재현율(recall)이다.			</span>
</div>
<br/>
<strong class="tt1">해설</strong>
<div class="t1">
		텍스트 마이닝을 하려면 해당 언어에 대한 깊이 있는 이해와 문화나 관습에 대한 이해도 필요하고, 국가별 언어의 차이가 있으므로 국가별 텍스트 마이닝이 필요하다. 또한 Corpus는 데이터 마이닝의 절차 중 데이터의 정제, 통합, 선택, 변환의 과정을 거친 구조화된 단계이다.				</div>


<div class="more-c">
<strong class="tt1">비기봇 해설</strong>
<div class="t1">
				- 1번 보기: 텍스트 마이닝에서는 어근과 어미를 구분하는 단계가 중요하지만, 언어에 대한 이해뿐만 아니라 문화와 관습도 중요한 요소입니다. 이는 텍스트의 의미를 정확하게 파악하고 분석하기 위해 필요합니다.<br/>
<br/>
- 2번 보기: 영어가 세계 공용어이긴 하지만, 국가별로 사용하는 영어의 표현 방식이나 의미가 다를 수 있습니다. 따라서 국가별로 텍스트 마이닝을 수행하는 것이 필요할 수 있습니다.<br/>
<br/>
- 3번 보기: 자연어 처리 분야에서 분석 결과를 평가하기 위해 정밀도(precision)와 재현율(recall)은 대표적인 방법론입니다. 정밀도는 실제로 긍정인 것 중에서 모델이 긍정으로 예측한 비율을 의미하고, 재현율은 실제 긍정인 것 중에서 모델이 긍정으로 예측한 비율을 의미합니다.<br/>
<br/>
- 4번 보기: corpus는 텍스트 마이닝에서 분석을 위해 사용하는 텍스트 데이터의 집합을 의미합니다. 데이터 마트 생성과는 관련이 없습니다.<br/>
</div>
<div class="t2">
									# 텍스트 마이닝 특징									# 어근									# 어미									# 문화									# 관습									# 정밀도									# 재현율									# 자연어 처리									# corpus									# 데이터 마트									# 집합							</div>
</div>

</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
<div class="sg1">
<div class="w1">
<span class="g1">4과목</span>
<span class="g1">텍스트 마이닝</span>
<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
</div>
</div>
<div class="tg1">
<strong class="tt1">
<span class="tt1n">3.</span>
<span class="tt1t1">
				텍스트 마이닝의 분석 결과를 평가하기 위해 사용되는 방법론 중 재현율에 관한 설명으로 맞는 것은?							</span>
</strong>
<span class="tt1t1">
<a class="p1" href="exam1view1img1.php?img=706bd835-5eb2-dce6-ddd4-6321b7fc2c0d.png" rel="noopener" target="_blank" title="새 창">
<img alt="문제에 포함된 이미지" src="https://www.dataedupt.kr/data/img/question/706bd835-5eb2-dce6-ddd4-6321b7fc2c0d.png"/>
</a>
</span>
</div>
<ol class="lst1">
<li class="li1"><a class="a1"><span class="t1">
			분석 모델이 긍정으로 분류한 데이터(a+b) 중 실제 긍정 데이터는 a이므로 재현율은 a/(a+b)이다.					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			실제 존재하는 모든 긍정 메시지(a+c) 중 분석 결과 나온 개수가 a이므로 재현율은 a/(a+c)이다.					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			전체 메시지(a+b+c+d) 중 분석 결과 나온 개수가 a이므로 재현율은 a/(a+b+c+d) 이다.					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			전체 메시지(a+b+c+d) 중 분석 결과 나온 개수가 a+b이므로 재현율은 (a+b)/(a+b+c+d)이다.					</span></a></li>
</ol>
<div class="eg1">
<a class="b2 help" href="#m-help1a3" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
<span class="t1">정답보기</span>
<i class="ic1"></i>
</a>
</div>
<div class="tg2 loaded" id="m-help1a3" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
<strong class="tt1">정답</strong>
<div class="t2">
<i class="t2n">2</i>
<span class="t2t1">
			실제 존재하는 모든 긍정 메시지(a+c) 중 분석 결과 나온 개수가 a이므로 재현율은 a/(a+c)이다.			</span>
</div>
<br/>
<strong class="tt1">해설</strong>
<div class="t1">
		재현율(Recall)은 실제 정답 중에서 분석 모델에서 정답이라고 내놓은 결과의 비율이다. 그림에서 A /(A+C)에 해당한다.				</div>


<div class="more-c">
<strong class="tt1">비기봇 해설</strong>
<div class="t1">
				정답은 2번입니다.<br/>
<br/>
재현율(Recall)은 텍스트 마이닝에서 모델이 실제 긍정 데이터를 얼마나 잘 찾아내는지를 평가하는 지표입니다. 이는 실제 긍정 데이터 중에서 모델이 긍정으로 예측한 데이터의 비율로 정의됩니다. 수식으로는 재현율 = a / (a + c)로 표현됩니다. 여기서 a는 모델이 긍정으로 예측한 실제 긍정 데이터의 수, c는 모델이 부정으로 예측한 실제 긍정 데이터의 수입니다. 따라서 재현율은 모델의 민감도를 나타내며, 실제 긍정인 데이터 중에서 모델이 얼마나 많은 긍정 데이터를 올바르게 예측했는지를 보여줍니다.<br/>
<br/>
1. 분석 모델이 긍정으로 분류한 데이터(a+b) 중 실제 긍정 데이터는 a이므로 재현율은 a/(a+b)이다. <br/>
: 이 선지는 재현율을 잘못 정의하고 있습니다. 재현율은 실제 긍정 데이터 중에서 모델이 긍정으로 예측한 비율을 나타내야 합니다. 그러나 이 선지는 모델이 긍정으로 예측한 데이터 중 실제 긍정 데이터의 비율을 설명하고 있어, 이는 정확도에 더 가까운 개념입니다.<br/>
<br/>
2. 실제 존재하는 모든 긍정 메시지(a+c) 중 분석 결과 나온 개수가 a이므로 재현율은 a/(a+c)이다. <br/>
: 이 선지는 재현율을 올바르게 설명하고 있습니다. 재현율은 실제 긍정 데이터(a + c) 중에서 모델이 긍정으로 예측한 데이터(a)의 비율로 정의됩니다. 이는 모델이 실제 긍정 데이터를 얼마나 잘 찾아내는지를 평가하는 지표입니다.<br/>
<br/>
3. 전체 메시지(a+b+c+d) 중 분석 결과 나온 개수가 a이므로 재현율은 a/(a+b+c+d) 이다. <br/>
: 이 선지는 재현율을 잘못 설명하고 있습니다. 재현율은 전체 메시지 중에서 모델이 긍정으로 예측한 비율이 아니라, 실제 긍정 데이터 중에서 모델이 긍정으로 예측한 비율을 나타내야 합니다.<br/>
<br/>
4. 전체 메시지(a+b+c+d) 중 분석 결과 나온 개수가 a+b이므로 재현율은 (a+b)/(a+b+c+d)이다. <br/>
: 이 선지는 재현율을 잘못 설명하고 있습니다. 재현율은 전체 메시지 중에서 모델이 긍정으로 예측한 비율이 아니라, 실제 긍정 데이터 중에서 모델이 긍정으로 예측한 비율을 나타내야 합니다.<br/>
<br/>
정답은 2번입니다. 재현율은 실제 긍정 데이터 중에서 모델이 긍정으로 예측한 데이터의 비율로 정의됩니다. 이는 a / (a + c)로 표현되며, 모델의 민감도를 나타냅니다. 나머지 선지들은 재현율의 정의를 잘못 설명하고 있습니다. 1번은 정확도에 가까운 설명이며, 3번과 4번은 전체 메시지를 기준으로 설명하고 있어 재현율의 정의와 맞지 않습니다.<br/>
따라서, 정답은 '2. 실제 존재하는 모든 긍정 메시지(a+c) 중 분석 결과 나온 개수가 a이므로 재현율은 a/(a+c)이다.' 입니다.<br/>
</div>
<div class="t2">
									#재현율									# 텍스트 마이닝									# 민감도									# 긍정 데이터									# 모델 평가							</div>
</div>

</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
<div class="sg1">
<div class="w1">
<span class="g1">4과목</span>
<span class="g1">통계분석</span>
<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
</div>
</div>
<div class="tg1">
<strong class="tt1">
<span class="tt1n">4.</span>
<span class="tt1t1">
				데이터 마이닝 절차 중 데이터의 정제, 통합, 선택, 변환의 과정을 거친 구조화된 단계로서 더 이상 추가적인 절차 없이 데이터 마이닝 알고리즘 실험에서 활용될 수 있는 상태를 무엇이라고 하는가?							</span>
</strong>
<span class="tt1t1">
</span>
</div>
<ol class="lst1">
<li class="li1"><a class="a1"><span class="t1">
			Feature					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			Corpus					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			Factor Source					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			Term					</span></a></li>
</ol>
<div class="eg1">
<a class="b2 help" href="#m-help1a4" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
<span class="t1">정답보기</span>
<i class="ic1"></i>
</a>
</div>
<div class="tg2 loaded" id="m-help1a4" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
<strong class="tt1">정답</strong>
<div class="t2">
<i class="t2n">1</i>
<span class="t2t1">
			Feature			</span>
</div>
<br/>
<strong class="tt1">해설</strong>
<div class="t1">
		Corpus는 데이터 마이닝의 절차 중 데이터의 정제, 통합, 선택, 변환의 과정을 거친 구조화된 단계이다.				</div>


<div class="more-c">
<strong class="tt1">비기봇 해설</strong>
<div class="t1">
				1. 데이터 마이닝 절차에서 데이터의 정제, 통합, 선택, 변환의 과정을 거쳐 준비된 구조화된 데이터는 'Feature'라고 합니다. Feature는 머신 러닝 알고리즘이 학습할 수 있는 형태로 정리된 데이터 항목을 의미하며, 이는 모델 훈련과 예측에 직접적으로 사용될 수 있습니다.<br/>
<br/>
2. Corpus는 주로 자연어 처리(NLP)에서 사용되는 용어로, 텍스트 데이터의 집합을 의미합니다. 데이터 마이닝에서의 전처리 단계를 설명하는 데는 적절하지 않습니다.<br/>
<br/>
3. Factor Source는 주로 통계나 실험 설계에서 사용되는 용어로, 요인이나 변수를 생성하는 출처를 의미합니다. 데이터 마이닝에서의 전처리 완료된 상태를 설명하는 데는 적절하지 않습니다.<br/>
<br/>
4. Term은 주로 정보 검색이나 텍스트 마이닝에서 사용되는 용어로, 단어 또는 용어를 의미합니다. 데이터 마이닝에서의 전처리 완료된 상태를 설명하는 데는 적절하지 않습니다.<br/>
</div>
<div class="t2">
									#데이터 마이닝									# 데이터 정제									# Feature									# Corpus									# Factor Source									# Term							</div>
</div>

</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
<div class="sg1">
<div class="w1">
<span class="g1">4과목</span>
<span class="g1">텍스트 마이닝</span>
<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
</div>
</div>
<div class="tg1">
<strong class="tt1">
<span class="tt1n">5.</span>
<span class="tt1t1">
				텍스트 마이닝 패키지인 TM에서 문서를 관리하는 기본 구조를 Corpus라고 부르는데, 이는 텍스트 문서들의 집합을 의미한다. 메모리에서만 텍스트 문서를 유지하고 관리하는 것은 무엇인가?							</span>
</strong>
<span class="tt1t1">
</span>
</div>
<ol class="lst1">
<li class="li1"><a class="a1"><span class="t1">
			VCorpus					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			PCorpus					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			MCorpus					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			DataFrame Source					</span></a></li>
</ol>
<div class="eg1">
<a class="b2 help" href="#m-help1a5" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
<span class="t1">정답보기</span>
<i class="ic1"></i>
</a>
</div>
<div class="tg2 loaded" id="m-help1a5" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
<strong class="tt1">정답</strong>
<div class="t2">
<i class="t2n">1</i>
<span class="t2t1">
			VCorpus			</span>
</div>
<br/>
<strong class="tt1">해설</strong>
<div class="t1">
		VCorpus(short for Volatile Corpus)는 메모리에서만 유지된다.				</div>


<div class="more-c">
<strong class="tt1">비기봇 해설</strong>
<div class="t1">
				정답은 1번입니다.<br/>
<br/>
문제는 텍스트 마이닝 패키지인 TM에서 문서를 관리하는 기본 구조인 Corpus에 대해 묻고 있습니다. Corpus는 텍스트 문서들의 집합을 의미하며, 메모리에서만 텍스트 문서를 유지하고 관리하는 구조를 찾는 것이 핵심입니다.<br/>
<br/>
1. VCorpus<br/>
: VCorpus는 Volatile Corpus의 약자로, 메모리에서만 텍스트 문서를 유지하고 관리하는 구조입니다. 이는 휘발성 메모리에서 작동하여 프로그램이 종료되면 데이터가 사라집니다.<br/>
<br/>
2. PCorpus<br/>
: PCorpus는 Permanent Corpus의 약자로, 디스크에 데이터를 저장하여 프로그램이 종료되어도 데이터가 유지됩니다.<br/>
<br/>
3. MCorpus<br/>
: MCorpus는 일반적으로 사용되지 않는 용어로, TM 패키지에서 정의된 구조가 아닙니다.<br/>
<br/>
4. DataFrame Source<br/>
: DataFrame Source는 텍스트 데이터를 DataFrame 형태로 관리하는 방법으로, Corpus의 한 형태가 아닙니다.<br/>
<br/>
<br/>
VCorpus는 메모리에서만 텍스트 문서를 유지하고 관리하는 구조로, 문제에서 묻는 조건에 부합합니다. PCorpus는 디스크에 데이터를 저장하므로 조건에 맞지 않으며, MCorpus는 존재하지 않는 용어이고, DataFrame Source는 Corpus의 형태가 아닙니다.<br/>
<br/>
따라서, 정답은 '1. VCorpus' 입니다.<br/>
</div>
<div class="t2">
									#Corpus									# VCorpus									# 메모리									# 텍스트 마이닝							</div>
</div>

</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
<div class="sg1">
<div class="w1">
<span class="g1">4과목</span>
<span class="g1">텍스트 마이닝</span>
<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
</div>
</div>
<div class="tg1">
<strong class="tt1">
<span class="tt1n">6.</span>
<span class="tt1t1">
				텍스트 마이닝 패키지인 TM에서 영어 문서 A에 포함된 대소문자를 모두 소문자로 바꾸기 위해 사용하는 R 프로그래밍으로 적합한 것은 무엇인가? 							</span>
</strong>
<span class="tt1t1">
</span>
</div>
<ol class="lst1">
<li class="li1"><a class="a1"><span class="t1">
			A ← tm_map(A, as.PlainTextDocurment)					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			A ← tm_map(A, removeWords, stopwords("english")) 					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			A ← tm_map(A, stripWhitespace)					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			A ← tm_map(A, tolower)					</span></a></li>
</ol>
<div class="eg1">
<a class="b2 help" href="#m-help1a6" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
<span class="t1">정답보기</span>
<i class="ic1"></i>
</a>
</div>
<div class="tg2 loaded" id="m-help1a6" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
<strong class="tt1">정답</strong>
<div class="t2">
<i class="t2n">4</i>
<span class="t2t1">
			A ← tm_map(A, tolower)			</span>
</div>
<br/>
<strong class="tt1">해설</strong>
<div class="t1">
		대문자를 소문자로 변환하는 코드는 A&lt;-tm_map(A, tolower))이다.				</div>


<div class="more-c">
<strong class="tt1">비기봇 해설</strong>
<div class="t1">
				정답은 4번입니다.<br/>
<br/>
텍스트 마이닝은 비정형 데이터인 텍스트로부터 유용한 정보를 추출하는 과정입니다. 이 과정에서 텍스트를 구조화하여 패턴을 도출하고, 결과를 평가 및 해석합니다. R의 'tm' 패키지는 이러한 텍스트 마이닝 작업을 지원하며, 다양한 전처리 기능을 제공합니다. 전처리 과정에는 대소문자 변환, 공백 제거, 불용어 처리 등이 포함됩니다. 특히, 대소문자 변환은 텍스트의 일관성을 유지하고 분석의 정확성을 높이기 위해 중요합니다. 'tm_map' 함수는 이러한 전처리 작업을 수행하는 데 사용되며, 특정 기능을 적용할 수 있는 다양한 함수를 지원합니다.<br/>
<br/>
1. A ← tm_map(A, as.PlainTextDocurment) <br/>
: 이 선지는 'as.PlainTextDocument' 함수를 사용하여 문서를 일반 텍스트 형식으로 변환하는 방법을 설명합니다. 이는 XML과 같은 구조화된 문서를 텍스트로 변환할 때 유용하지만, 대소문자 변환과는 관련이 없습니다. 따라서 이 선지는 문제의 요구사항과 맞지 않습니다.<br/>
<br/>
2. A ← tm_map(A, removeWords, stopwords("english")) <br/>
: 이 선지는 'removeWords' 함수를 사용하여 불용어를 제거하는 방법을 설명합니다. 불용어는 분석에 불필요한 단어로, 이를 제거함으로써 텍스트의 유의미한 정보를 강조할 수 있습니다. 그러나 이 과정은 대소문자 변환과는 직접적인 관련이 없습니다.<br/>
<br/>
3. A ← tm_map(A, stripWhitespace) <br/>
: 이 선지는 'stripWhitespace' 함수를 사용하여 텍스트 내의 불필요한 공백을 제거하는 방법을 설명합니다. 공백 제거는 텍스트의 가독성을 높이고 분석의 정확성을 향상시키지만, 대소문자 변환과는 관련이 없습니다.<br/>
<br/>
4. A ← tm_map(A, tolower) <br/>
: 이 선지는 'tolower' 함수를 사용하여 텍스트 내의 모든 대문자를 소문자로 변환하는 방법을 설명합니다. 이는 텍스트의 일관성을 유지하고 분석의 정확성을 높이는 데 필수적입니다. 따라서 이 선지는 문제의 요구사항에 정확히 부합합니다.<br/>
<br/>
정답은 '4'입니다. 'tolower' 함수는 텍스트 내의 모든 대문자를 소문자로 변환하여 일관성을 유지합니다. 이는 텍스트 마이닝에서 중요한 전처리 단계입니다. 다른 선지들은 각각 다른 전처리 작업을 설명하고 있으며, 대소문자 변환과는 직접적인 관련이 없습니다.<br/>
따라서, 정답은 '4. A ← tm_map(A, tolower)' 입니다.<br/>
</div>
<div class="t2">
									#텍스트 마이닝									# 전처리									# 대소문자 변환									# tm 패키지									# tolower							</div>
</div>

</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
<div class="sg1">
<div class="w1">
<span class="g1">4과목</span>
<span class="g1">텍스트 마이닝</span>
<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
</div>
</div>
<div class="tg1">
<strong class="tt1">
<span class="tt1n">7.</span>
<span class="tt1t1">
				텍스트 마이닝 패키지인 TM에서 dtm이라는 문서에 포함된 단어 중 10회 이상 사용된 단어를 찾는 방법을 R로 프로그래밍한 것으로 옳은 것은?							</span>
</strong>
<span class="tt1t1">
</span>
</div>
<ol class="lst1">
<li class="li1"><a class="a1"><span class="t1">
			findFreqTerms(dtm,10)					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			findAssocs(dtm,10,10)					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			tm_map(dtm,10,findFreq) 					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			Corpus(findFreqTerms(dtm,10))					</span></a></li>
</ol>
<div class="eg1">
<a class="b2 help" href="#m-help1a7" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
<span class="t1">정답보기</span>
<i class="ic1"></i>
</a>
</div>
<div class="tg2 loaded" id="m-help1a7" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
<strong class="tt1">정답</strong>
<div class="t2">
<i class="t2n">1</i>
<span class="t2t1">
			findFreqTerms(dtm,10)			</span>
</div>
<br/>
<strong class="tt1">해설</strong>
<div class="t1">
		dtm이라는 문서에 포함된 단어 중 10회 이상 사용된 단어를 찾는 R 프로그램 방법은 findFreqTerms(dtm,10)이다.				</div>


<div class="more-c">
<strong class="tt1">비기봇 해설</strong>
<div class="t1">
				정답은 1번입니다.<br/>
<br/>
이 문제는 R의 텍스트 마이닝 패키지인 TM에서 문서-단어 행렬(Document-Term Matrix, DTM)을 사용하여 특정 빈도 이상의 단어를 찾는 방법에 대한 이해를 평가합니다. 주어진 함수 중에서 올바른 함수를 선택해야 합니다.<br/>
<br/>
1. findFreqTerms(dtm,10)<br/>
: findFreqTerms 함수는 DTM에서 특정 빈도 이상의 단어를 찾는 데 사용됩니다. 첫 번째 인자는 DTM 객체이고, 두 번째 인자는 최소 빈도입니다.<br/>
<br/>
2. findAssocs(dtm,10,10)<br/>
: findAssocs 함수는 특정 단어와 연관된 단어를 찾는 데 사용됩니다. 두 번째 인자는 연관성을 찾을 기준 단어이고, 세 번째 인자는 연관성의 최소값입니다.<br/>
<br/>
3. tm_map(dtm,10,findFreq)<br/>
: tm_map 함수는 텍스트 변환을 위해 사용되며, 주로 전처리 작업에 사용됩니다. 여기서는 적절하지 않습니다.<br/>
<br/>
4. Corpus(findFreqTerms(dtm,10))<br/>
: Corpus 함수는 텍스트 데이터를 코퍼스로 변환하는 데 사용됩니다. findFreqTerms와 함께 사용되지 않습니다.<br/>
<br/>
<br/>
findFreqTerms 함수는 DTM에서 특정 빈도 이상의 단어를 찾는 데 적합한 함수입니다. 다른 선택지들은 각각 다른 목적의 함수이거나, 문법적으로 잘못된 사용입니다.<br/>
<br/>
따라서, 정답은 '1. findFreqTerms(dtm,10)' 입니다.<br/>
</div>
<div class="t2">
									#TM 패키지									# DTM									# findFreqTerms									# R 프로그래밍							</div>
</div>

</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
<div class="sg1">
<div class="w1">
<span class="g1">4과목</span>
<span class="g1">텍스트 마이닝</span>
<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
</div>
</div>
<div class="tg1">
<strong class="tt1">
<span class="tt1n">8.</span>
<span class="tt1t1">
				문장에서 사용된 단어의 긍정과 부정여부에 따라 얼마나 긍정적인 단어가 많은지 여부로 소스를 부여해 긍정 문장인지를 평가하기 위한 분석으로 트위터의 트윗을 통해 자사의 브랜드의 긍정/부정 여부를 판단하는데 활용되는 분석은 무엇인가?							</span>
</strong>
<span class="tt1t1">
</span>
</div>
<ol class="lst1">
<li class="li1"><a class="a1"><span class="t1">
			감성분석(Sentiment Analysis)					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			분류분석(classification Analysis)					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			소셜네트워크분석(Social Network Analysis) 					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			트윗분석(Twit Analysis)					</span></a></li>
</ol>
<div class="eg1">
<a class="b2 help" href="#m-help1a8" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
<span class="t1">정답보기</span>
<i class="ic1"></i>
</a>
</div>
<div class="tg2 loaded" id="m-help1a8" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
<strong class="tt1">정답</strong>
<div class="t2">
<i class="t2n">1</i>
<span class="t2t1">
			감성분석(Sentiment Analysis)			</span>
</div>
<br/>
<strong class="tt1">해설</strong>
<div class="t1">
		문장에서 사용된 단어의 긍정과 부정 여부에 따라 얼마나 대상에 대한 반응이 긍정인지 부정인지를 평가하는 분석 방법은 감성분석이다.				</div>


<div class="more-c">
<strong class="tt1">비기봇 해설</strong>
<div class="t1">
				정답은 1번입니다.<br/>
<br/>
이 문제는 텍스트에서 긍정적 또는 부정적인 감정을 분석하여 브랜드에 대한 인식을 평가하는 방법에 관한 것입니다. 주로 소셜 미디어 데이터를 활용하여 감정의 긍정 또는 부정 여부를 판단하는 데 사용됩니다.<br/>
<br/>
1. 감성분석(Sentiment Analysis)<br/>
: 감성분석은 텍스트에서 감정의 긍정적 또는 부정적 경향을 파악하는 방법으로, 주로 소셜 미디어에서 브랜드에 대한 인식을 평가하는 데 사용됩니다.<br/>
<br/>
2. 분류분석(classification Analysis)<br/>
: 분류분석은 데이터를 특정 범주로 분류하는 방법으로, 감정의 긍정 또는 부정 여부를 직접적으로 분석하는 데 사용되지는 않습니다.<br/>
<br/>
3. 소셜네트워크분석(Social Network Analysis)<br/>
: 소셜네트워크분석은 네트워크 내의 관계와 구조를 분석하는 방법으로, 감정의 긍정 또는 부정 여부를 직접적으로 분석하는 데 사용되지는 않습니다.<br/>
<br/>
4. 트윗분석(Twit Analysis)<br/>
: 트윗분석은 트위터 데이터를 분석하는 방법이지만, 감정의 긍정 또는 부정 여부를 분석하는 방법을 구체적으로 지칭하지는 않습니다.<br/>
<br/>
<br/>
감성분석은 텍스트에서 감정의 긍정적 또는 부정적 경향을 파악하는 데 사용되며, 이는 브랜드에 대한 인식을 평가하는 데 매우 유용합니다. 다른 선택지들은 감정 분석과 직접적인 관련이 없거나 구체적인 방법을 지칭하지 않습니다.<br/>
<br/>
따라서, 정답은 '1. 감성분석(Sentiment Analysis)' 입니다.<br/>
</div>
<div class="t2">
									#감성분석									# 긍정									# 부정									# 브랜드 인식							</div>
</div>

</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
<div class="sg1">
<div class="w1">
<span class="g1">4과목</span>
<span class="g1">정형 데이터 마이닝</span>
<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
</div>
</div>
<div class="tg1">
<strong class="tt1">
<span class="tt1n">9.</span>
<span class="tt1t1">
				사회연결망 분석(social network analysis)에 대한 설명으로 부적절한 것은 어느 것인가?							</span>
</strong>
<span class="tt1t1">
</span>
</div>
<ol class="lst1">
<li class="li1"><a class="a1"><span class="t1">
			개인과 집단들 간의 관계를 노드와 링크로써 모델링해 그것의 위상 구조와 확산 및 진화과정을 계량적으로 분석한 방법론이다.					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			최근 인터넷과 소셜네트워크의 발달로 발생하는 대용량 데이터를 활용해 개인과 개인, 개인과 집단 간의 네트워크를 분석하는 방법론이다.					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			제이콥 마리노(Jacob Mareno)가 처음 “sociometry”에 발표하지만 사회연결망이라는 용어는 Barnes(1954)가 처음으로 내놓았다.					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			최근에는 주로 그룹간 또는 그룹 안의 개인에 집중한 연구가 진행되고 있다.					</span></a></li>
</ol>
<div class="eg1">
<a class="b2 help" href="#m-help1a9" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
<span class="t1">정답보기</span>
<i class="ic1"></i>
</a>
</div>
<div class="tg2 loaded" id="m-help1a9" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
<strong class="tt1">정답</strong>
<div class="t2">
<i class="t2n">4</i>
<span class="t2t1">
			최근에는 주로 그룹간 또는 그룹 안의 개인에 집중한 연구가 진행되고 있다.			</span>
</div>
<br/>
<strong class="tt1">해설</strong>
<div class="t1">
		최근에는 독립 네트워크 사이의 관계에 대한 사회연결망 연구가 활발히 이루어지고 있다.				</div>


<div class="more-c">
<strong class="tt1">비기봇 해설</strong>
<div class="t1">
				1. 사회연결망 분석의 기본 개념을 잘 설명하고 있습니다. 노드와 링크를 통해 관계를 모델링하고 분석하는 방법론이 맞습니다.<br/>
<br/>
2. 최근 인터넷과 소셜 네트워크의 발달로 인해 대용량 데이터를 활용한 사회연결망 분석이 더욱 활발하게 이루어지고 있습니다.<br/>
<br/>
3. 제이콥 모레노(Jacob Moreno)는 'sociometry'를 처음 발표한 학자입니다. 하지만, 사회연결망(Social Network)이라는 용어를 처음 사용한 것은 J.A. Barnes가 맞습니다. 따라서 이 설명은 적절합니다.<br/>
<br/>
4.  이 설명은 부적절합니다. 최근 사회연결망 분석은 개인과 개인, 개인과 집단 간의 네트워크 구조와 상호작용을 분석하는 데 중점을 두고 있습니다. 그룹 간 또는 그룹 내 개인에 집중한 연구뿐만 아니라, 보다 넓은 맥락에서 네트워크 전체를 분석하는 연구도 활발히 진행되고 있습니다.<br/>
</div>
<div class="t2">
									#사회연결망 분석							</div>
</div>

</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
<div class="sg1">
<div class="w1">
<span class="g1">4과목</span>
<span class="g1">사회연결망 분석</span>
<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
</div>
</div>
<div class="tg1">
<strong class="tt1">
<span class="tt1n">10.</span>
<span class="tt1t1">
				다음은 사회연결망 분석방법에 대한 설명이다. 이 중 잘못 나열한 것은 어느 것인가?							</span>
</strong>
<span class="tt1t1">
</span>
</div>
<ol class="lst1">
<li class="li1"><a class="a1"><span class="t1">
			집합론적인 방법 - 각 개체들 간의 관계를 쌍으로 표현한 것					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			계층적 그래프를 이용한 방법 - 계층적 군집분석의 방식으로 각 객체를 표현한 것					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			그래프 이론을 이용한 방법 - 두 객체 간의 연결망은 두 점(노드)을 연결하는 선으로 표현한 것 					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			행렬을 이용한 방법 - 각 객체를 행렬의 행과 열에 대칭적으로 배치하고 행렬로 표현한 것					</span></a></li>
</ol>
<div class="eg1">
<a class="b2 help" href="#m-help1a10" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
<span class="t1">정답보기</span>
<i class="ic1"></i>
</a>
</div>
<div class="tg2 loaded" id="m-help1a10" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
<strong class="tt1">정답</strong>
<div class="t2">
<i class="t2n">2</i>
<span class="t2t1">
			계층적 그래프를 이용한 방법 - 계층적 군집분석의 방식으로 각 객체를 표현한 것			</span>
</div>
<br/>
<strong class="tt1">해설</strong>
<div class="t1">
		사회연결망 분석 방법에는 집합론적인 방법, 그래프 이론을 이용한 방법, 행렬을 이용한 방법이 있다.				</div>


<div class="more-c">
<strong class="tt1">비기봇 해설</strong>
<div class="t1">
				정답은 2번입니다.<br/>
<br/>
사회연결망 분석은 다양한 방법을 통해 객체들 간의 관계를 분석하는 기법입니다. 이 분석은 주로 집합론, 그래프 이론, 행렬 등을 활용하여 객체 간의 관계를 시각적으로 표현하고 분석합니다. 집합론적인 방법은 객체 간의 관계를 쌍으로 표현하며, 그래프 이론은 노드와 엣지를 통해 관계를 시각화합니다. 행렬을 이용한 방법은 객체를 행과 열에 배치하여 관계를 수치적으로 나타냅니다. 이러한 방법들은 각각의 특성과 장점을 가지고 있으며, 분석 목적에 따라 적절히 선택하여 사용됩니다.<br/>
<br/>
1. 집합론적인 방법 - 각 개체들 간의 관계를 쌍으로 표현한 것 <br/>
: 집합론적인 방법은 객체들 간의 관계를 쌍으로 표현하는 방식입니다. 이는 각 객체를 집합의 원소로 보고, 이들 간의 관계를 쌍으로 나타내어 분석하는 방법입니다. 이러한 방법은 관계의 유무를 명확히 표현할 수 있어, 관계의 존재 여부를 쉽게 파악할 수 있습니다.<br/>
<br/>
2. 계층적 그래프를 이용한 방법 - 계층적 군집분석의 방식으로 각 객체를 표현한 것 <br/>
: 계층적 그래프를 이용한 방법은 계층적 군집분석을 통해 객체를 표현하는 방식입니다. 이는 객체들을 계층적으로 분류하여, 각 계층 간의 관계를 그래프로 나타내는 방법입니다. 그러나 문제에서 언급된 '계층적 그래프'는 사회연결망 분석의 일반적인 방법으로는 잘 알려져 있지 않으며, 이로 인해 잘못된 설명으로 볼 수 있습니다.<br/>
<br/>
3. 그래프 이론을 이용한 방법 - 두 객체 간의 연결망은 두 점(노드)을 연결하는 선으로 표현한 것 <br/>
: 그래프 이론을 이용한 방법은 두 객체 간의 관계를 노드와 엣지로 표현하는 방식입니다. 이는 객체를 노드로, 관계를 엣지로 나타내어 시각적으로 관계를 분석할 수 있게 합니다. 이러한 방법은 관계의 구조적 특성을 파악하는 데 유용합니다.<br/>
<br/>
4. 행렬을 이용한 방법 - 각 객체를 행렬의 행과 열에 대칭적으로 배치하고 행렬로 표현한 것 <br/>
: 행렬을 이용한 방법은 객체를 행과 열에 배치하여 관계를 수치적으로 표현하는 방식입니다. 각 객체를 행렬의 행과 열에 대칭적으로 배치하고, 관계가 존재하면 해당 위치에 값을 넣어 관계를 나타냅니다. 이는 관계의 유무를 명확히 수치화할 수 있는 장점이 있습니다.<br/>
<br/>
선지 2의 '계층적 그래프를 이용한 방법'은 사회연결망 분석의 일반적인 방법으로 잘 알려져 있지 않으며, 계층적 군집분석과 혼동될 수 있습니다. 나머지 선지들은 각각 집합론, 그래프 이론, 행렬을 이용한 방법으로 사회연결망 분석에서 일반적으로 사용되는 방법들입니다.<br/>
따라서, 정답은 '2. 계층적 그래프를 이용한 방법 - 계층적 군집분석의 방식으로 각 객체를 표현한 것' 입니다.<br/>
</div>
<div class="t2">
									#사회연결망 분석									# 집합론									# 그래프 이론									# 행렬									# 계층적 군집분석							</div>
</div>

</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
<div class="sg1">
<div class="w1">
<span class="g1">4과목</span>
<span class="g1">사회연결망 분석</span>
<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
</div>
</div>
<div class="tg1">
<strong class="tt1">
<span class="tt1n">11.</span>
<span class="tt1t1">
				사회연결망 분석(social network analysis)의 네트워크 구조를 파악하는 기법 중 하나로 위세가 높은 사람들과 관계가 많을수록 자신의 위세 또한 높아지는 것을 특징으로 하며, 영향력이 높은 사람에 대한 단 하나의 연결이 그렇지 않은 다른 여러 사람들과 관계를 맺는 경우보다 자신의 영향력을 키우는 기법은 무엇인가?							</span>
</strong>
<span class="tt1t1">
</span>
</div>
<ol class="lst1">
<li class="li1"><a class="a1"><span class="t1">
			연결정도 중심성(Degree centrality)					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			근접 중심성(Closeness centrality)					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			매개 중심성(Betweenness centrality)					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			위세 중심성(Eigenvector centrality)					</span></a></li>
</ol>
<div class="eg1">
<a class="b2 help" href="#m-help1a11" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
<span class="t1">정답보기</span>
<i class="ic1"></i>
</a>
</div>
<div class="tg2 loaded" id="m-help1a11" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
<strong class="tt1">정답</strong>
<div class="t2">
<i class="t2n">4</i>
<span class="t2t1">
			위세 중심성(Eigenvector centrality)			</span>
</div>
<br/>
<strong class="tt1">해설</strong>
<div class="t1">
		위세 중심성 : 자신의 연결정도 중심성으로부터 발생하는 영향력과 자신이 연결된 타인의 영향력을 합하여 결정한다.				</div>


<div class="more-c">
<strong class="tt1">비기봇 해설</strong>
<div class="t1">
				정답은 4번입니다.<br/>
<br/>
문제는 사회연결망 분석에서 위세가 높은 사람들과의 관계를 통해 자신의 위세를 높이는 기법을 묻고 있습니다. 이는 네트워크 내에서 영향력 있는 사람과의 연결이 중요하다는 것을 강조합니다.<br/>
<br/>
1. 연결정도 중심성(Degree centrality)<br/>
: 연결정도 중심성은 네트워크에서 한 노드가 직접 연결된 다른 노드의 수를 측정하는 방법입니다. 이는 단순히 연결의 수를 기반으로 하며, 연결된 노드의 중요도는 고려하지 않습니다.<br/>
<br/>
2. 근접 중심성(Closeness centrality)<br/>
: 근접 중심성은 네트워크 내에서 한 노드가 다른 모든 노드에 얼마나 가까운지를 측정합니다. 이는 네트워크 내에서 정보가 얼마나 빠르게 전달될 수 있는지를 나타냅니다.<br/>
<br/>
3. 매개 중심성(Betweenness centrality)<br/>
: 매개 중심성은 네트워크 내에서 한 노드가 다른 노드 쌍 간의 최단 경로에 얼마나 자주 위치하는지를 측정합니다. 이는 정보 흐름의 중개자로서의 역할을 강조합니다.<br/>
<br/>
4. 위세 중심성(Eigenvector centrality)<br/>
: 위세 중심성은 연결된 노드의 중요도에 따라 자신의 중요도가 결정되는 방법입니다. 영향력 있는 노드와의 연결이 자신의 위세를 높이는 데 기여합니다.<br/>
<br/>
<br/>
위세 중심성은 연결된 노드의 중요도에 따라 자신의 중요도가 결정되므로, 영향력 있는 사람과의 연결이 자신의 위세를 높이는 데 직접적인 영향을 미칩니다. 다른 선택지들은 각각의 중심성을 측정하는 방법이지만, 문제에서 묻는 '위세가 높은 사람들과의 관계'를 통한 위세 증대와는 직접적인 관련이 없습니다.<br/>
<br/>
따라서, 정답은 '4. 위세 중심성(Eigenvector centrality)' 입니다.<br/>
</div>
<div class="t2">
									#사회연결망 분석									# 위세 중심성									# 영향력									# 네트워크							</div>
</div>

</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
<div class="sg1">
<div class="w1">
<span class="g1">4과목</span>
<span class="g1">정형 데이터 마이닝</span>
<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
</div>
</div>
<div class="tg1">
<strong class="tt1">
<span class="tt1n">12.</span>
<span class="tt1t1">
				사회연결망 분석(social network analysis)에서 아래 그림과 같은 결과를 얻었다. 내용에 대한 설명 중 적절하지 않은 것은?							</span>
</strong>
<span class="tt1t1">
<a class="p1" href="exam1view1img1.php?img=cdbaabc0-a8c4-8cb1-4d1a-573455529492.png" rel="noopener" target="_blank" title="새 창">
<img alt="문제에 포함된 이미지" src="https://www.dataedupt.kr/data/img/question/cdbaabc0-a8c4-8cb1-4d1a-573455529492.png"/>
</a>
</span>
</div>
<ol class="lst1">
<li class="li1"><a class="a1"><span class="t1">
			3개의 군집(cluster)으로 군집화하는 것이 최선인 것으로 결과가 나왔다.					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			군집화의 결과, 3번 노드와 15번 노드는 같은 군집에 포함된 것을 알 수 있다.					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			3개의 군집으로 나누었을 때 최고의 모듈성은 28%임을 알 수 있다.					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			community detection을 위해 edge betweenness 알고리즘을 활용하여 커뮤니티를 발견한다.					</span></a></li>
</ol>
<div class="eg1">
<a class="b2 help" href="#m-help1a12" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
<span class="t1">정답보기</span>
<i class="ic1"></i>
</a>
</div>
<div class="tg2 loaded" id="m-help1a12" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
<strong class="tt1">정답</strong>
<div class="t2">
<i class="t2n">2</i>
<span class="t2t1">
			군집화의 결과, 3번 노드와 15번 노드는 같은 군집에 포함된 것을 알 수 있다.			</span>
</div>
<br/>
<strong class="tt1">해설</strong>
<div class="t1">
		분석 결과에서 3번 노드는 3번 군집, 15번 노드는 1번군집이므로 다른 군집으로 묶였다.				</div>


<div class="more-c">
<strong class="tt1">비기봇 해설</strong>
<div class="t1">
				1번: "3개의 군집(cluster)으로 군집화하는 것이 최선인 것으로 결과가 나왔다."는 설명은 적절합니다. 출력 결과에서 "Number of communities (best split): 3"이라고 명시되어 있습니다.<br/>
<br/>
2번: "군집화의 결과, 3번 노드와 15번 노드는 같은 군집에 포함된 것을 알 수 있다."는 설명은 적절하지 않습니다. 출력 결과의 Membership vector를 보면, 3번 노드는 1번 군집에, 15번 노드는 2번 군집에 속해 있습니다.<br/>
<br/>
3번: "3개의 군집으로 나누었을 때 최고의 모듈성은 28%임을 알 수 있다."는 설명은 적절합니다. 출력 결과에서 "Modularity (best split): 0.2797619"라고 명시되어 있습니다.<br/>
<br/>
4번: "community detection을 위해 edge betweenness 알고리즘을 활용하여 커뮤니티를 발견한다."는 설명은 적절합니다. 출력 결과에서 "Graph community structure calculated with the edge betweenness algorithm"이라고 명시되어 있습니다.<br/>
</div>
<div class="t2">
									# 사회연결망 분석									# 군집화									# edge betweenness									# 모듈성									# Membership vector									# R프로그램 결과해석							</div>
</div>

</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
<div class="sg1">
<div class="w1">
<span class="g1">4과목</span>
<span class="g1">사회연결망 분석</span>
<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
</div>
</div>
<div class="tg1">
<strong class="tt1">
<span class="tt1n">13.</span>
<span class="tt1t1">
				텍스트 데이터를 전처리하여 각 문서와 단어 간의 사용 여부를 이용해 만들어진 matrix를 무엇이라고 하는가?							</span>
</strong>
<span class="tt1t1">
</span>
</div>
<ol class="lst1">
<li class="li1"><a class="a1"><span class="t1">
			TDM(Term-Document Matrix)					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			워드 스테밍(Word Stemming)					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			웹 크롤링(Web Crawling)					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			제외어 처리(Stop Word)					</span></a></li>
</ol>
<div class="eg1">
<a class="b2 help" href="#m-help1a13" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
<span class="t1">정답보기</span>
<i class="ic1"></i>
</a>
</div>
<div class="tg2 loaded" id="m-help1a13" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
<strong class="tt1">정답</strong>
<div class="t2">
<i class="t2n">1</i>
<span class="t2t1">
			TDM(Term-Document Matrix)			</span>
</div>
<br/>
<strong class="tt1">해설</strong>
<div class="t1">
		TDM(Term-Document Matrix)은 텍스트 데이터를 전처리하여 각 문서와 단어 간의 사용 여부를 이용해 만들어진 matrix이다.				</div>


<div class="more-c">
<strong class="tt1">비기봇 해설</strong>
<div class="t1">
				정답은 1번입니다.<br/>
<br/>
문제는 텍스트 데이터를 전처리하여 각 문서와 단어 간의 사용 여부를 나타내는 매트릭스를 묻고 있습니다. 이는 정보 검색 및 자연어 처리에서 중요한 개념입니다.<br/>
<br/>
1. TDM(Term-Document Matrix)<br/>
: TDM은 문서와 단어 간의 관계를 행렬 형태로 나타내며, 각 행은 문서를, 각 열은 단어를 나타냅니다. 이 행렬은 문서 내 단어의 빈도나 존재 여부를 나타내는 데 사용됩니다.<br/>
<br/>
2. 워드 스테밍(Word Stemming)<br/>
: 워드 스테밍은 단어의 어근을 추출하는 과정으로, 단어의 형태를 줄여서 기본 형태로 만드는 작업입니다. 이는 문서와 단어 간의 관계를 나타내는 매트릭스와는 관련이 없습니다.<br/>
<br/>
3. 웹 크롤링(Web Crawling)<br/>
: 웹 크롤링은 웹 페이지를 자동으로 탐색하고 데이터를 수집하는 기술로, 문서와 단어 간의 관계를 나타내는 매트릭스와는 관련이 없습니다.<br/>
<br/>
4. 제외어 처리(Stop Word)<br/>
: 제외어 처리는 분석에서 불필요한 단어를 제거하는 과정으로, 문서와 단어 간의 관계를 나타내는 매트릭스와는 관련이 없습니다.<br/>
<br/>
<br/>
TDM은 문서와 단어 간의 관계를 행렬 형태로 나타내는 방법으로, 문제에서 묻는 '각 문서와 단어 간의 사용 여부를 이용해 만들어진 매트릭스'에 해당합니다. 다른 선택지들은 각각의 다른 개념을 설명하고 있으며, 문서와 단어 간의 관계를 나타내는 매트릭스와는 관련이 없습니다.<br/>
<br/>
따라서, 정답은 '1. TDM(Term-Document Matrix)' 입니다.<br/>
</div>
<div class="t2">
									#TDM									# Term-Document Matrix									# 텍스트 전처리									# 자연어 처리							</div>
</div>

</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
<div class="sg1">
<div class="w1">
<span class="g1">4과목</span>
<span class="g1">텍스트 마이닝</span>
<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
</div>
</div>
<div class="tg1">
<strong class="tt1">
<span class="tt1n">14.</span>
<span class="tt1t1">
				다음 중 텍스트 마이닝의 기능 중 부적절한 것은?							</span>
</strong>
<span class="tt1t1">
</span>
</div>
<ol class="lst1">
<li class="li1"><a class="a1"><span class="t1">
			문서 요약(summarization)					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			문서 분류(classification)					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			문서 제작(production)					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			특성 추출(feature extraction)					</span></a></li>
</ol>
<div class="eg1">
<a class="b2 help" href="#m-help1a14" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
<span class="t1">정답보기</span>
<i class="ic1"></i>
</a>
</div>
<div class="tg2 loaded" id="m-help1a14" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
<strong class="tt1">정답</strong>
<div class="t2">
<i class="t2n">3</i>
<span class="t2t1">
			문서 제작(production)			</span>
</div>
<br/>
<strong class="tt1">해설</strong>
<div class="t1">
		텍스트 마이닝은 크게 문서요약(summarization), 문서분류(classification), 문서군집(clustering), 특성추출(feature extraction)이다.				</div>


<div class="more-c">
<strong class="tt1">비기봇 해설</strong>
<div class="t1">
				정답은 3번입니다.<br/>
<br/>
텍스트 마이닝은 대량의 텍스트 데이터를 분석하여 유용한 정보를 추출하는 기술입니다. 주요 기능으로는 문서 요약, 문서 분류, 특성 추출 등이 있으며, 이러한 기능들은 텍스트 데이터를 이해하고 활용하는 데 필수적입니다.<br/>
<br/>
1. 문서 요약(summarization)<br/>
: 문서 요약은 긴 문서에서 핵심 내용을 추출하여 짧게 요약하는 기능으로, 텍스트 마이닝의 중요한 기능 중 하나입니다.<br/>
<br/>
2. 문서 분류(classification)<br/>
: 문서 분류는 문서를 특정 기준에 따라 그룹화하는 과정으로, 텍스트 마이닝에서 자주 사용되는 기능입니다.<br/>
<br/>
3. 문서 제작(production)<br/>
: 문서 제작은 새로운 문서를 생성하는 과정으로, 텍스트 마이닝의 기능과는 거리가 멉니다.<br/>
<br/>
4. 특성 추출(feature extraction)<br/>
: 특성 추출은 텍스트에서 중요한 특징이나 패턴을 식별하는 과정으로, 텍스트 마이닝의 핵심 기능 중 하나입니다.<br/>
<br/>
<br/>
문서 제작은 텍스트 마이닝의 기능이 아닙니다. 텍스트 마이닝은 주로 기존의 텍스트 데이터를 분석하고 이해하는 데 중점을 두며, 문서 요약, 문서 분류, 특성 추출과 같은 기능을 포함합니다. 따라서 문서 제작은 부적절한 기능입니다.<br/>
<br/>
따라서, 정답은 '3. 문서 제작(production)' 입니다.<br/>
</div>
<div class="t2">
									#텍스트 마이닝									# 문서 요약									# 문서 분류									# 특성 추출							</div>
</div>

</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
<div class="sg1">
<div class="w1">
<span class="g1">4과목</span>
<span class="g1">텍스트 마이닝</span>
<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
</div>
</div>
<div class="tg1">
<strong class="tt1">
<span class="tt1n">15.</span>
<span class="tt1t1">
				tm 패키지의 데이터들의 변형을 위한 tm_map( )이라는 함수를 통해 사용할 수 있는 명령어로 틀린 것은?							</span>
</strong>
<span class="tt1t1">
</span>
</div>
<ol class="lst1">
<li class="li1"><a class="a1"><span class="t1">
			removeWords					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			stemMing					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			stripWhitespace					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			removeNumbers					</span></a></li>
</ol>
<div class="eg1">
<a class="b2 help" href="#m-help1a15" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
<span class="t1">정답보기</span>
<i class="ic1"></i>
</a>
</div>
<div class="tg2 loaded" id="m-help1a15" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
<strong class="tt1">정답</strong>
<div class="t2">
<i class="t2n">2</i>
<span class="t2t1">
			stemMing			</span>
</div>
<br/>
<strong class="tt1">해설</strong>
<div class="t1">
		tm_map( )이라는 함수를 통해 사용할 수 있는 명령어는 removeWords, removeNumbers, removePunctuation, stripWhitespace, stemDocument이다.				</div>


<div class="more-c">
<strong class="tt1">비기봇 해설</strong>
<div class="t1">
				정답은 2번입니다.<br/>
<br/>
tm 패키지의 tm_map() 함수는 텍스트 마이닝에서 텍스트 데이터를 전처리하기 위한 다양한 명령어를 제공합니다. 이 함수는 텍스트 데이터의 불필요한 부분을 제거하거나 변형하는 데 사용됩니다.<br/>
<br/>
1. removeWords<br/>
: removeWords는 텍스트에서 특정 단어를 제거하는 데 사용되는 함수입니다. 이는 불필요한 단어를 제거하여 텍스트의 품질을 높이는 데 유용합니다.<br/>
<br/>
2. stemMing<br/>
: stemMing은 텍스트의 어간을 추출하는 과정으로, 일반적으로 'stemDocument'라는 함수가 사용됩니다. 'stemMing'은 tm 패키지의 명령어가 아닙니다.<br/>
<br/>
3. stripWhitespace<br/>
: stripWhitespace는 텍스트에서 불필요한 공백을 제거하는 함수로, 텍스트의 가독성을 높이는 데 사용됩니다.<br/>
<br/>
4. removeNumbers<br/>
: removeNumbers는 텍스트에서 숫자를 제거하는 함수로, 숫자가 분석에 방해가 될 때 유용하게 사용됩니다.<br/>
<br/>
<br/>
stemMing은 tm 패키지의 tm_map() 함수에서 사용되는 명령어가 아닙니다. 대신 'stemDocument'라는 함수가 사용됩니다. 다른 선택지들은 모두 tm_map() 함수에서 사용 가능한 명령어입니다.<br/>
<br/>
따라서, 정답은 '2. stemMing' 입니다.<br/>
</div>
<div class="t2">
									#tm 패키지									# tm_map									# 텍스트 전처리									# 명령어							</div>
</div>

</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
<div class="sg1">
<div class="w1">
<span class="g1">4과목</span>
<span class="g1">통계분석</span>
<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
</div>
</div>
<div class="tg1">
<strong class="tt1">
<span class="tt1n">16.</span>
<span class="tt1t1">
				다음 중 아래 Term-Document Matrix에서 sparsity(희박성)의 값으로 적절한 것은?							</span>
</strong>
<span class="tt1t1">
<a class="p1" href="exam1view1img1.php?img=d4884969-f7ad-a69b-0e15-af3267968940.png" rel="noopener" target="_blank" title="새 창">
<img alt="문제에 포함된 이미지" src="https://www.dataedupt.kr/data/img/question/d4884969-f7ad-a69b-0e15-af3267968940.png"/>
</a>
</span>
</div>
<ol class="lst1">
<li class="li1"><a class="a1"><span class="t1">
			2%					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			44%					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			64%					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			98%					</span></a></li>
</ol>
<div class="eg1">
<a class="b2 help" href="#m-help1a16" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
<span class="t1">정답보기</span>
<i class="ic1"></i>
</a>
</div>
<div class="tg2 loaded" id="m-help1a16" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
<strong class="tt1">정답</strong>
<div class="t2">
<i class="t2n">3</i>
<span class="t2t1">
			64%			</span>
</div>
<br/>
<strong class="tt1">해설</strong>
<div class="t1">
		sparsity는 tdm 안에 0인 원소가 있는 %를 의미한다. 총 25개 중 0이 16개 있으므로 64%이다.				</div>


<div class="more-c">
<strong class="tt1">비기봇 해설</strong>
<div class="t1">
				희박성(sparsity)은 행렬에서 0의 비율을 의미합니다. 주어진 Term-Document Matrix에서 총 셀의 수는 5 (문서) x 5 (용어) = 25입니다. 이 중 0의 개수를 세어보면, 16개입니다. 따라서 희박성은 (16/25) * 100 = 64%입니다.<br/>
<br/>
<br/>
</div>
<div class="t2">
									# 희박성									# Term-Document Matrix									# 0의 비율									# 행렬									# sparsity							</div>
</div>

</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
<div class="sg1">
<div class="w1">
<span class="g1">4과목</span>
<span class="g1">텍스트 마이닝</span>
<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
</div>
</div>
<div class="tg1">
<strong class="tt1">
<span class="tt1n">17.</span>
<span class="tt1t1">
				아래의 그림에 대한 설명으로 부적절한 것은?							</span>
</strong>
<span class="tt1t1">
<a class="p1" href="exam1view1img1.php?img=c2465dde-f5fd-6166-5e71-9960b044f5ec.JPG" rel="noopener" target="_blank" title="새 창">
<img alt="문제에 포함된 이미지" src="https://www.dataedupt.kr/data/img/question/c2465dde-f5fd-6166-5e71-9960b044f5ec.JPG"/>
</a>
</span>
</div>
<ol class="lst1">
<li class="li1"><a class="a1"><span class="t1">
			문서 내에서 가장 빈번하게 나타나는 단어는 크게 표시되어 있다. 					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			위의 그림을 만들려면 텍스트 데이터가 필요하다.					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			작은 글자는 다른 문서와 연결성이 낮아서 작게 표현했다. 					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			워드 클라우드의 글자 수를 지정할 수 있다.					</span></a></li>
</ol>
<div class="eg1">
<a class="b2 help" href="#m-help1a17" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
<span class="t1">정답보기</span>
<i class="ic1"></i>
</a>
</div>
<div class="tg2 loaded" id="m-help1a17" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
<strong class="tt1">정답</strong>
<div class="t2">
<i class="t2n">3</i>
<span class="t2t1">
			작은 글자는 다른 문서와 연결성이 낮아서 작게 표현했다. 			</span>
</div>
<br/>
<strong class="tt1">해설</strong>
<div class="t1">
		워드 클라우드에서 작은 글자는 다른 단어보다 빈번하게 나타나지 않아 작게 표현한 것이다.				</div>


<div class="more-c">
<strong class="tt1">비기봇 해설</strong>
<div class="t1">
				정답은 3번입니다.<br/>
<br/>
워드 클라우드는 텍스트 데이터에서 단어의 빈도를 시각적으로 표현하는 도구입니다. 빈도가 높은 단어일수록 더 크게 표시되며, 이를 통해 문서의 주요 주제를 빠르게 파악할 수 있습니다.<br/>
<br/>
1. 문서 내에서 가장 빈번하게 나타나는 단어는 크게 표시되어 있다.<br/>
: 워드 클라우드는 단어의 빈도에 따라 크기를 조절하여 시각적으로 표현합니다. 따라서 빈번하게 나타나는 단어가 크게 표시됩니다.<br/>
<br/>
2. 위의 그림을 만들려면 텍스트 데이터가 필요하다.<br/>
: 워드 클라우드를 생성하기 위해서는 분석할 텍스트 데이터가 필요합니다. 이 데이터에서 단어의 빈도를 계산하여 시각화합니다.<br/>
<br/>
3. 작은 글자는 다른 문서와 연결성이 낮아서 작게 표현했다.<br/>
: 워드 클라우드에서 작은 글자는 빈도가 낮은 단어를 나타내며, 다른 문서와의 연결성은 직접적으로 표현되지 않습니다.<br/>
<br/>
4. 워드 클라우드의 글자 수를 지정할 수 있다.<br/>
: 워드 클라우드를 생성할 때 글자 수를 제한하거나 특정 단어만 포함하도록 설정할 수 있습니다.<br/>
<br/>
<br/>
워드 클라우드에서 작은 글자는 단순히 빈도가 낮은 단어를 나타내며, 다른 문서와의 연결성을 나타내지 않습니다. 따라서 3번이 부적절한 설명입니다. 다른 선택지는 워드 클라우드의 특성을 잘 설명하고 있습니다.<br/>
<br/>
따라서, 정답은 '3. 작은 글자는 다른 문서와 연결성이 낮아서 작게 표현했다.' 입니다.<br/>
</div>
<div class="t2">
									#워드 클라우드									# 빈도									# 시각화									# 텍스트 데이터							</div>
</div>

</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
<div class="sg1">
<div class="w1">
<span class="g1">4과목</span>
<span class="g1">사회연결망 분석</span>
<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
</div>
</div>
<div class="tg1">
<strong class="tt1">
<span class="tt1n">18.</span>
<span class="tt1t1">
				다음 중 사회연결망 분석에서 행과 열에 같은 개체가 배열되어 있는 매트릭스로 적절한 것은?							</span>
</strong>
<span class="tt1t1">
</span>
</div>
<ol class="lst1">
<li class="li1"><a class="a1"><span class="t1">
			준 연결 매트릭스					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			2원모드 매트릭스 					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			상관 매트릭스 					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			1원모드 매트릭스					</span></a></li>
</ol>
<div class="eg1">
<a class="b2 help" href="#m-help1a18" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
<span class="t1">정답보기</span>
<i class="ic1"></i>
</a>
</div>
<div class="tg2 loaded" id="m-help1a18" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
<strong class="tt1">정답</strong>
<div class="t2">
<i class="t2n">4</i>
<span class="t2t1">
			1원모드 매트릭스			</span>
</div>
<br/>
<strong class="tt1">해설</strong>
<div class="t1">
		1원모드 매트릭스는 행과 열에 같은 개체가 배열되는 것이다.				</div>


<div class="more-c">
<strong class="tt1">비기봇 해설</strong>
<div class="t1">
				정답은 4번입니다.<br/>
<br/>
사회연결망 분석에서 매트릭스는 네트워크의 구조를 수학적으로 표현하는 도구입니다. 이 중에서 행과 열에 같은 개체가 배열되어 있는 매트릭스는 네트워크의 노드 간의 관계를 나타내는 데 사용됩니다.<br/>
<br/>
1. 준 연결 매트릭스<br/>
: 준 연결 매트릭스는 네트워크의 연결성을 나타내지만, 행과 열에 같은 개체가 배열되어 있지 않을 수 있습니다.<br/>
<br/>
2. 2원모드 매트릭스<br/>
: 2원모드 매트릭스는 두 개의 다른 집합 간의 관계를 나타내며, 행과 열에 같은 개체가 배열되지 않습니다.<br/>
<br/>
3. 상관 매트릭스<br/>
: 상관 매트릭스는 변수 간의 상관관계를 나타내며, 행과 열에 같은 개체가 배열될 수 있지만, 이는 사회연결망 분석의 맥락과는 다릅니다.<br/>
<br/>
4. 1원모드 매트릭스<br/>
: 1원모드 매트릭스는 네트워크의 노드 간의 관계를 나타내며, 행과 열에 같은 개체가 배열되어 있습니다.<br/>
<br/>
<br/>
1원모드 매트릭스는 네트워크의 노드 간의 관계를 나타내기 때문에 행과 열에 같은 개체가 배열되어 있습니다. 다른 선택지들은 네트워크의 구조를 나타내는 방식이 다르거나, 사회연결망 분석의 맥락과 맞지 않습니다.<br/>
<br/>
따라서, 정답은 '4. 1원모드 매트릭스' 입니다.<br/>
</div>
<div class="t2">
									#사회연결망 분석									# 매트릭스									# 1원모드 매트릭스									# 네트워크							</div>
</div>

</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
<div class="sg1">
<div class="w1">
<span class="g1">4과목</span>
<span class="g1">사회연결망 분석</span>
<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
</div>
</div>
<div class="tg1">
<strong class="tt1">
<span class="tt1n">19.</span>
<span class="tt1t1">
				다음 중 사회연결망 분석을 R 프로그램으로 실행할 때, 사용하는 함수가 아닌 것은?							</span>
</strong>
<span class="tt1t1">
</span>
</div>
<ol class="lst1">
<li class="li1"><a class="a1"><span class="t1">
			V( )					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			E( ) 					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			simplify( )					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			inspect( )					</span></a></li>
</ol>
<div class="eg1">
<a class="b2 help" href="#m-help1a19" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
<span class="t1">정답보기</span>
<i class="ic1"></i>
</a>
</div>
<div class="tg2 loaded" id="m-help1a19" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
<strong class="tt1">정답</strong>
<div class="t2">
<i class="t2n">4</i>
<span class="t2t1">
			inspect( )			</span>
</div>
<br/>
<strong class="tt1">해설</strong>
<div class="t1">
		R 프로그램에서 사회연결망 분석을 실행할 때, inspect( ) 함수는 사용하지 않는다.				</div>


<div class="more-c">
<strong class="tt1">비기봇 해설</strong>
<div class="t1">
				정답은 4번입니다.<br/>
<br/>
사회연결망 분석을 R 프로그램으로 실행할 때, 주로 사용하는 함수들은 네트워크의 노드와 엣지를 다루거나 네트워크의 구조를 단순화하는 데 사용됩니다. 이 문제는 이러한 함수들 중에서 R에서 사용되지 않는 함수를 찾는 것입니다.<br/>
<br/>
1. V( )<br/>
: V() 함수는 R의 igraph 패키지에서 그래프의 노드(정점)를 다루기 위해 사용됩니다. 이 함수는 네트워크 분석에서 매우 중요합니다.<br/>
<br/>
2. E( )<br/>
: E() 함수는 R의 igraph 패키지에서 그래프의 엣지(간선)를 다루기 위해 사용됩니다. 네트워크의 연결 관계를 분석할 때 필수적입니다.<br/>
<br/>
3. simplify( )<br/>
: simplify() 함수는 R의 igraph 패키지에서 그래프를 단순화하는 데 사용됩니다. 중복된 엣지를 제거하거나 루프를 제거하는 데 유용합니다.<br/>
<br/>
4. inspect( )<br/>
: inspect() 함수는 R의 igraph 패키지에서 사용되지 않는 함수입니다. 이 함수는 주로 데이터 프레임이나 다른 객체를 검사하는 데 사용되며, 네트워크 분석과는 관련이 없습니다.<br/>
<br/>
<br/>
inspect() 함수는 R의 igraph 패키지에서 사용되지 않으며, 네트워크 분석과 관련이 없습니다. 반면, V(), E(), simplify() 함수는 모두 igraph 패키지에서 네트워크 분석을 위해 사용되는 함수들입니다.<br/>
<br/>
따라서, 정답은 '4. inspect( )' 입니다.<br/>
</div>
<div class="t2">
									#R 프로그램									# 사회연결망 분석									# igraph 패키지									# 함수							</div>
</div>

</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
<div class="sg1">
<div class="w1">
<span class="g1">4과목</span>
<span class="g1">사회연결망 분석</span>
<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
</div>
</div>
<div class="tg1">
<strong class="tt1">
<span class="tt1n">20.</span>
<span class="tt1t1">
				다음 중 사회연결망 분석의 중심성을 측정하는 방법으로 틀린 것은?							</span>
</strong>
<span class="tt1t1">
</span>
</div>
<ol class="lst1">
<li class="li1"><a class="a1"><span class="t1">
			연결정도 중심성 					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			위세 중심성 					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			근접 중심성 					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			밀도 중심성					</span></a></li>
</ol>
<div class="eg1">
<a class="b2 help" href="#m-help1a20" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
<span class="t1">정답보기</span>
<i class="ic1"></i>
</a>
</div>
<div class="tg2 loaded" id="m-help1a20" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
<strong class="tt1">정답</strong>
<div class="t2">
<i class="t2n">4</i>
<span class="t2t1">
			밀도 중심성			</span>
</div>
<br/>
<strong class="tt1">해설</strong>
<div class="t1">
		사회연결망 분석의 중심성 측정 방법은 연결정도 중심성, 위세 중심성, 근접 중심성, 매개 중심성이다.				</div>


<div class="more-c">
<strong class="tt1">비기봇 해설</strong>
<div class="t1">
				정답은 4번입니다.<br/>
<br/>
사회연결망 분석에서 중심성은 네트워크 내에서 특정 노드의 중요성을 측정하는 방법입니다. 중심성의 종류에는 연결정도 중심성, 위세 중심성, 근접 중심성 등이 있으며, 각각의 중심성은 네트워크 내에서 노드의 위치와 역할을 다르게 평가합니다.<br/>
<br/>
1. 연결정도 중심성<br/>
: 연결정도 중심성은 특정 노드가 직접 연결된 다른 노드의 수를 측정하여 네트워크 내에서의 중요성을 평가합니다.<br/>
<br/>
2. 위세 중심성<br/>
: 위세 중심성은 연결된 노드의 중요도에 따라 특정 노드의 중요성을 평가합니다. 즉, 중요한 노드와 연결될수록 해당 노드의 위세 중심성은 높아집니다.<br/>
<br/>
3. 근접 중심성<br/>
: 근접 중심성은 특정 노드가 네트워크 내 다른 모든 노드와 얼마나 가까운지를 측정하여 중요성을 평가합니다. 이는 네트워크 내에서 정보가 얼마나 빠르게 전달될 수 있는지를 나타냅니다.<br/>
<br/>
4. 밀도 중심성<br/>
: 밀도 중심성은 네트워크 전체의 연결 밀도를 측정하는 개념으로, 특정 노드의 중심성을 측정하는 방법이 아닙니다.<br/>
<br/>
<br/>
밀도 중심성은 네트워크 전체의 연결 밀도를 나타내는 개념으로, 특정 노드의 중심성을 측정하는 방법이 아닙니다. 따라서 다른 선택지들은 모두 특정 노드의 중심성을 측정하는 방법이므로, 정답은 4번입니다.<br/>
<br/>
따라서, 정답은 '4. 밀도 중심성' 입니다.<br/>
</div>
<div class="t2">
									#중심성									# 연결정도 중심성									# 위세 중심성									# 근접 중심성							</div>
</div>

</div>
</div>
<!-- /cp1question1 -->





<script>
/* === AUTO-PATCH: answer-toggle-v2 === */
(function () {
  function qsa(sel, root) { return Array.from((root || document).querySelectorAll(sel)); }
  function qs(sel, root) { return (root || document).querySelector(sel); }

  function getPanelFromBtn(btn) {
    const href = btn && btn.getAttribute('href');
    if (!href || !href.startsWith('#')) return null;
    return document.querySelector(href);
  }

  function setHelpLabel(btn, open) {
    const t = btn ? btn.querySelector('.t1') : null;
    if (t) t.textContent = open ? '정답닫기' : '정답보기';
    if (btn) btn.setAttribute('aria-expanded', String(open));
  }

  function panelIsOpen(panel) {
    if (!panel) return false;
    if (panel.style.display) return panel.style.display !== 'none';
    return getComputedStyle(panel).display !== 'none';
  }

  function openPanel(btn, panel) {
    if (!panel) return;
    panel.style.display = 'block';
    panel.classList.add('loaded');     // 기존 테마 연동
    setHelpLabel(btn, true);
  }

  function closePanel(btn, panel) {
    if (!panel) return;
    panel.style.display = 'none';
    setHelpLabel(btn, false);
  }

  // ✅ 전체 정답 보기/닫기
  window.controlAllAnswers = function (show) {
    qsa('.tg2').forEach(panel => {
      panel.style.display = show ? 'block' : 'none';
      if (show) panel.classList.add('loaded');
    });
    qsa('a.b2.help').forEach(btn => setHelpLabel(btn, show));
  };

  // ✅ 개별 정답보기 토글 (이게 없으면 "클릭해도 아무 동작 없음")
  function onHelpClick(e) {
    const btn = e.target.closest('a.b2.help[href^="#"]');
    if (!btn) return;
    e.preventDefault();

    const panel = getPanelFromBtn(btn);
    if (!panel) return;

    panelIsOpen(panel) ? closePanel(btn, panel) : openPanel(btn, panel);
  }

  // ✅ 보기 클릭 → 정오답 판정 + s1/s2 적용 + 자동 정답보기
  function onOptionPick(e) {
    const li = e.target.closest('.cp1question1 .lst1 .li1');
    if (!li) return;

    const qBox = li.closest('.cp1question1');
    if (!qBox) return;

    const btn = qs('a.b2.help[href^="#"]', qBox);
    const panel = getPanelFromBtn(btn);

    // 정답 번호(i.t2n)는 해설 패널 안에 있음(1-based)
    const n = panel ? panel.querySelector('i.t2n') : null;
    const correctIdx = n ? parseInt((n.textContent || '').trim(), 10) : NaN;

    const options = qsa('.lst1 .li1', qBox);
    const idx = options.indexOf(li) + 1; // 1-based

    if (!Number.isFinite(correctIdx) || correctIdx <= 0) return;

    const isCorrect = idx === correctIdx;
    qBox.setAttribute('data-answer-state', isCorrect ? 'correct' : 'wrong');

    // 헤더 표시 (정답 s1 | 오답 s2)
    const b = qs('.w1 b', qBox);
    if (b) b.className = isCorrect ? 's1' : 's2';

    // 보기에도 클래스 부여(원하면 CSS로 강조)
    options.forEach((opt, i) => {
      opt.classList.remove('is-correct', 'is-wrong');
      if (i + 1 === correctIdx) opt.classList.add('is-correct');
    });
    li.classList.add(isCorrect ? 'is-correct' : 'is-wrong');

    // 자동 정답보기
    openPanel(btn, panel);
  }

  // capture로 등록: 다른 스크립트가 click을 막아도 최대한 동작
  document.addEventListener('click', onHelpClick, true);
  document.addEventListener('click', onOptionPick, true);
})();
</script>

<!-- AUTO:score-counter start -->
<script>
(function () {
  function qsa(sel, root) { return Array.from((root || document).querySelectorAll(sel)); }
  function qs(sel, root) { return (root || document).querySelector(sel); }

  function setText(el, n) {
    if (!el) return;
    el.textContent = String(n) + '개';
  }

  function updateTotal(total) {
    const block = qs('.cp1dlist2');
    if (!block) return;
    qsa('.cp1dlist2 .di1', block).forEach(li => {
      const label = (qs('.dt1', li)?.textContent || '').trim();
      if (label === '총 문제') {
        const dd = qs('.dd1', li);
        if (dd) dd.textContent = String(total) + '개';
      }
    });
  }

  function getPanelFromQ(qBox) {
    const btn = qBox.querySelector('a.b2.help[href^="#"]');
    if (!btn) return null;
    const href = btn.getAttribute('href');
    if (!href || !href.startsWith('#')) return null;
    return document.querySelector(href);
  }

  function getCorrectIndex(panel) {
    const n = panel ? panel.querySelector('i.t2n') : null;
    if (!n) return null;
    const v = parseInt((n.textContent || '').trim(), 10);
    return Number.isFinite(v) ? v : null; // 1-based
  }

  function recompute() {
    const total = qsa('.cp1question1').length;
    let correct = 0;
    let wrong = 0;

    qsa('.cp1question1').forEach(qBox => {
      const state = qBox.getAttribute('data-answer-state');
      if (state === 'correct') correct += 1;
      else if (state === 'wrong') wrong += 1;
    });

    const unanswered = Math.max(0, total - (correct + wrong));

    updateTotal(total);
    setText(qs('.cp1dlist2 .em1'), correct);
    setText(qs('.cp1dlist2 .em2'), wrong);
    setText(qs('.cp1dlist2 .em3'), unanswered);
  }

  function handle(e) {
    const li = e.target.closest('.cp1question1 .lst1 .li1');
    if (!li) return;

    const qBox = li.closest('.cp1question1');
    if (!qBox) return;

    const options = qsa('.lst1 .li1', qBox);
    const idx = options.indexOf(li) + 1; // 1-based
    if (idx <= 0) return;

    const panel = getPanelFromQ(qBox);
    const correctIdx = getCorrectIndex(panel);
    if (!correctIdx) {
      qBox.removeAttribute('data-answer-state');
      recompute();
      return;
    }

    qBox.setAttribute('data-answer-state', (idx === correctIdx) ? 'correct' : 'wrong');
    recompute();
  }

  // click이 막혀도 동작하도록 pointerup도 함께 수신(충돌 방어)
  document.addEventListener('click', handle, true);
  document.addEventListener('pointerup', handle, true);

  function init() { recompute(); }
  if (document.readyState === 'loading') document.addEventListener('DOMContentLoaded', init);
  else init();
})();
</script>
<!-- AUTO:score-counter end -->

</body>
</html>
