<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <script src="https://code.jquery.com/jquery-3.7.1.min.js"></script>
  <base href="https://www.dataedupt.kr/">
  <title>모의고사 1</title>
</head>
<style>
/* AUTO:exam-ui start */
/* 클릭 가능 UX */
a.b2.help,
.cp1question1 .lst1 .li1,
.cp1question1 .lst1 .li1 a {
  cursor: pointer;
}
/* hover (navy) */
.cp1question1 .lst1 .li1:hover {
  background: rgba(31, 42, 68, 0.06);
}
/* 선택 표시 (navy) */
.cp1question1 .lst1 .li1.is-selected {
  background: rgba(31, 42, 68, 0.12);
  border-radius: 6px;
}
.cp1question1 .lst1 .li1.is-selected .t1 {
  font-weight: 600;
  color: #2980b9; /* 딥 블루 */
}
/* 정답 (navy) */
.cp1question1 .lst1 .li1.is-correct {
  background: rgba(52, 152, 219, 0.18); /* 라이트 블루 */
  border-radius: 6px;
}
.cp1question1 .lst1 .li1.is-correct .t1 {
  font-weight: 700;
  color: #2980b9; /* 딥 블루 */
}
/* 오답 */
.cp1question1 .lst1 .li1.is-wrong {
  background: rgba(160, 30, 30, 0.12);
  border-radius: 6px;
}
.cp1question1 .lst1 .li1.is-wrong .t1 {
  font-weight: 600;
  color: #7a1f1f;
}
/* 보기 버튼 (navy) */
a.b2.help {
  color: #2980b9; /* 딥 블루 */
}
a.b2.help.on {
  font-weight: 600;
}
/* AUTO:exam-ui end */
.li1 {padding:4px 0px; line-height:1.2;font-size:16px}


/* AUTO:clickable-ui start */
a.b2.help,
.cp1question1 .lst1 .li1,
.cp1question1 .lst1 .li1 a {
  cursor: pointer;
}
.cp1question1 .lst1 .li1:hover {
  background: rgba(0, 0, 0, 0.04);
}
a.b2.help:hover {
  opacity: 0.85;
}
/* AUTO:clickable-ui end */
/* AUTO:mobile-scroll-fix start */
html {
  scroll-behavior: smooth;
}
.container {
  max-width: 600px;
  width: 100%;
  margin: 0 auto;
}
/* AUTO:mobile-scroll-fix end */
body {width:100%;}
	.eg1 {padding:10px 0px; text-align:center;width:100%;}
	.tg2 {border-bottom:1px solid #ddd;padding:5% 5%; display:none}
	.cp1question1 {padding-bottom:12px;}
	img {
	  width: 100%;
	  height: 100%;
	  object-fit: contain; /* 또는 cover */
	}
h2 a {
  font-size: 16px;        /* 글씨 크기 */
  text-decoration: none;  /* 밑줄 제거 */
  color: #333;            /* 기본 글자 색 */
  font-weight: 500;       /* 약간 두껍게 */
  transition: color 0.3s ease; /* hover 시 부드럽게 색 변화 */
}
h2 a:hover {
  color: #007acc;         /* hover 시 포인트 색 */
}

/* AUTO:cp1dlist2-style start */
.cp1dlist2 {
  display: flex;
  justify-content: flex-end;
  background-color: #f0f0f0;
  border-radius: 12px;
  padding: 10px 15px;
}

.cp1dlist2 ul {
  list-style: none;
  margin: 0;
  padding: 0;
  display: flex;
  gap: 10px;
}

.em2 {
  color: #d63031;
}
/* AUTO:cp1dlist2-style end */

</style>
<body>
<div class="container  clearfix">
<h2><a href="index.html"> &lt; 돌아가기</a>

<span class="all-controls" style="margin-left: 15px; vertical-align: middle;">
    <button type="button" onclick="window.controlAllAnswers(true)" style="padding: 6px 12px; background-color: #2c3e50; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 13px; font-weight: bold;">전체 정답 보기</button>
    <button type="button" onclick="window.controlAllAnswers(false)" style="padding: 6px 12px; background-color: #95a5a6; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 13px; font-weight: bold; margin-left: 5px;">전체 가리기</button>
</span></h2>
<!-- cp1dlist2 -->
<div class="cp1dlist2">
<ul class="dl1">
<li class="di1">
<a class="a1">
<b class="dt1">총 문제</b>
<span class="dd1">80개</span>
</a>
</li>
<li class="di1">
<a class="a1">
<b class="dt1">맞춘 문제</b>
<span class="dd1"><b class="em1">0개</b></span>
</a>
</li>
<li class="di1">
<a class="a1">
<b class="dt1">틀린 문제</b>
<span class="dd1"><b class="em2">0개</b></span>
</a>
</li>
<li class="di1">
<a class="a1">
<b class="dt1">안 푼 문제</b>
<span class="dd1"><b class="em3">80개</b></span>
</a>
</li>
</ul>
</div>
<!-- /cp1dlist2 -->
<h3 class="hb1 h3">3회 모의고사</h3>
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">1과목</span>
			<span class="g1">빅데이터의 이해</span>
			<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">1.</span>
			<span class="tt1t1">
				일반적인 빅데이터의 정의와 가장 거리가 먼 것은? 							</span>
		</strong>
		<span class="tt1t1">
				    </span> 
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			빅데이터는 일반적인 데이터베이스 소프트웨어로 저장, 관리, 분석 등 범위를 초과하는 규모의 데이터이다.  					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			빅데이터는 대규모 데이터로부터 저렴한 비용으로 가치를 추출하고 데이터의 초고속 수집, 발굴, 분석을 지원하도록 고안된 차세대 기술 및 아키텍처다. 					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			빅데이터는 데이터의 양(volume), 데이터 유형과 소스의 다양성(variety), 데이터 수립과 처리 측면에서 속도(velocity)가 급격히 증가하면서 나타났다. 					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			기존의 작은 데이터 처리 분석으로는 얻을 수 없었던 통찰과 가치를 하둡(hadoop)을 기반으로 하는 대용량 분산처리기술을 통해 창출하는 새로운 방식이다.					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a1" class="b2 help" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a1" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">4</i>
			<span class="t2t1">
			기존의 작은 데이터 처리 분석으로는 얻을 수 없었던 통찰과 가치를 하둡(hadoop)을 기반으로 하는 대용량 분산처리기술을 통해 창출하는 새로운 방식이다.			</span>
					</div>
        <br>
				<strong class="tt1">해설</strong>
		<div class="t1">
		하둡은 빅데이터의 보완기술, 특징일 뿐 정의는 아니다.				</div>
		
				
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				정답은 4번입니다.<br>
<br>
빅데이터는 대량의 데이터를 처리하고 분석하여 유의미한 정보를 추출하는 기술과 방법론을 포함합니다. 이는 데이터의 양, 다양성, 속도라는 세 가지 주요 특성에 의해 정의됩니다.<br>
<br>
1. 빅데이터는 일반적인 데이터베이스 소프트웨어로 저장, 관리, 분석 등 범위를 초과하는 규모의 데이터이다.<br>
: 빅데이터는 전통적인 데이터베이스 소프트웨어로는 처리할 수 없는 대량의 데이터를 다루는 것을 의미합니다. 이는 데이터의 양이 방대하여 기존의 방법으로는 저장, 관리, 분석이 어려운 경우를 포함합니다.<br>
<br>
2. 빅데이터는 대규모 데이터로부터 저렴한 비용으로 가치를 추출하고 데이터의 초고속 수집, 발굴, 분석을 지원하도록 고안된 차세대 기술 및 아키텍처다.<br>
: 빅데이터 기술은 대규모 데이터로부터 가치를 추출하기 위해 설계된 차세대 기술과 아키텍처를 포함합니다. 이는 비용 효율적으로 데이터를 수집하고 분석할 수 있는 방법을 제공합니다.<br>
<br>
3. 빅데이터는 데이터의 양(volume), 데이터 유형과 소스의 다양성(variety), 데이터 수립과 처리 측면에서 속도(velocity)가 급격히 증가하면서 나타났다.<br>
: 빅데이터의 세 가지 주요 특성은 데이터의 양, 데이터 유형과 소스의 다양성, 그리고 데이터 처리 속도의 증가입니다. 이러한 특성들은 빅데이터의 정의에 필수적입니다.<br>
<br>
4. 기존의 작은 데이터 처리 분석으로는 얻을 수 없었던 통찰과 가치를 하둡(hadoop)을 기반으로 하는 대용량 분산처리기술을 통해 창출하는 새로운 방식이다.<br>
: 하둡과 같은 대용량 분산처리기술은 빅데이터를 처리하는 데 사용되지만, 빅데이터의 정의 자체에 포함되지는 않습니다. 이는 빅데이터를 처리하는 방법 중 하나일 뿐, 빅데이터의 본질적인 정의와는 거리가 있습니다.<br>
<br>
<br>
빅데이터의 정의는 데이터의 양, 다양성, 속도와 관련이 있으며, 이를 처리하기 위한 기술과 아키텍처를 포함합니다. 하둡은 빅데이터를 처리하는 기술 중 하나로, 빅데이터의 정의와 직접적인 관련이 없습니다. 따라서 하둡을 언급한 선택지가 가장 거리가 멉니다.<br>
<br>
따라서, 정답은 '4. 기존의 작은 데이터 처리 분석으로는 얻을 수 없었던 통찰과 가치를 하둡(hadoop)을 기반으로 하는 대용량 분산처리기술을 통해 창출하는 새로운 방식이다.' 입니다.<br>
			</div>
			<div class="t2">
									#빅데이터									# 데이터베이스									# 하둡									# 분산처리							</div>
		</div>
		
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">1과목</span>
			<span class="g1">데이터베이스 정의와 특징</span>
			<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">2.</span>
			<span class="tt1t1">
				정보위주의 처리를 의미하며, 다양한 비즈니스 관점에서 쉽고 빠르게 다차원적인 데이터에 접근하여 의사결정에 활용할 수 있는 정보를 얻게 해주는 기술을 의미하는 시스템으로 알맞은 것은?							</span>
		</strong>
		<span class="tt1t1">
				    </span> 
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			OLTP 시스템					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			OLAP 시스템					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			GIS 시스템					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			ERP 시스템					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a2" class="b2 help" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a2" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">2</i>
			<span class="t2t1">
			OLAP 시스템			</span>
					</div>
        <br>
				<strong class="tt1">해설</strong>
		<div class="t1">
		OLTP 시스템은 단순 자동화에 치우쳐 있는 시스템이다.				</div>
		
				
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				정답은 2번입니다.<br>
<br>
OLAP 시스템은 On-Line Analytical Processing의 약자로, 정보 위주의 분석 처리를 의미합니다. 이 시스템은 다양한 비즈니스 관점에서 쉽고 빠르게 다차원적인 데이터에 접근하여 의사결정에 활용할 수 있는 정보를 제공하는 기술입니다. OLAP는 주로 데이터 조회를 통해 제품의 판매 추이, 구매 성향 파악, 재무 회계 분석 등을 수행합니다. 이는 OLTP 시스템에서 처리된 트랜잭션 데이터를 분석하는 데 사용됩니다. OLTP가 데이터 갱신 위주라면, OLAP는 데이터 조회 위주라고 할 수 있습니다.<br>
<br>
1. OLTP 시스템 <br>
: OLTP 시스템은 On-Line Transaction Processing의 약자로, 주로 데이터의 입력, 갱신, 삭제 등 트랜잭션 처리를 중심으로 하는 시스템입니다. 이는 실시간으로 데이터베이스에 접근하여 데이터를 처리하는 데 중점을 두고 있으며, 주로 은행의 입출금, 항공 예약 시스템 등에서 사용됩니다. 따라서 OLAP와는 달리 분석보다는 트랜잭션 처리에 중점을 두고 있어 문제의 요구사항과는 맞지 않습니다.<br>
<br>
2. OLAP 시스템 <br>
: OLAP 시스템은 다차원적인 데이터 분석을 통해 의사결정에 필요한 정보를 제공하는 시스템입니다. 이는 다양한 비즈니스 관점에서 데이터를 조회하고 분석하여, 제품의 판매 추이, 구매 성향 파악, 재무 회계 분석 등을 수행합니다. OLAP는 데이터 조회 위주로, OLTP에서 수집된 데이터를 기반으로 분석을 수행합니다. 따라서 문제에서 요구하는 정보 위주의 처리 시스템에 가장 적합합니다.<br>
<br>
3. GIS 시스템 <br>
: GIS 시스템은 Geographic Information System의 약자로, 지리적 데이터를 수집, 저장, 분석, 관리하는 시스템입니다. 이는 주로 지도 제작, 지리적 분석, 위치 기반 서비스 등에 사용됩니다. 따라서 비즈니스 관점에서 다차원적인 데이터 분석을 통해 의사결정에 활용하는 OLAP 시스템과는 다른 목적을 가지고 있습니다.<br>
<br>
4. ERP 시스템 <br>
: ERP 시스템은 Enterprise Resource Planning의 약자로, 기업의 경영자원을 하나의 통합 시스템으로 관리하여 생산성을 극대화하려는 경영혁신기법입니다. 이는 주로 기업의 자원 관리, 생산 계획, 인사 관리 등을 통합적으로 관리하는 데 중점을 두고 있습니다. 따라서 OLAP처럼 데이터 분석을 통해 의사결정에 직접적으로 활용하는 시스템과는 다릅니다.<br>
<br>
OLAP 시스템은 정보 위주의 분석 처리를 통해 다양한 비즈니스 관점에서 데이터를 조회하고 분석하여 의사결정에 필요한 정보를 제공합니다. 이는 문제에서 요구하는 '정보위주의 처리'와 '다차원적인 데이터 접근'에 부합합니다. 반면, OLTP는 트랜잭션 처리에 중점을 두고 있으며, GIS는 지리적 데이터 관리, ERP는 기업 자원 관리에 중점을 두고 있어 문제의 요구사항과는 맞지 않습니다.<br>
따라서, 정답은 '2. OLAP 시스템' 입니다.<br>
			</div>
			<div class="t2">
									#OLAP									# 데이터 분석									# 의사결정									# 다차원 데이터									# 정보 처리							</div>
		</div>
		
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">1과목</span>
			<span class="g1">빅데이터의 이해</span>
			<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">3.</span>
			<span class="tt1t1">
				다음 중 빅데이터가 만들어 내는 변화로 부적절한 것은?							</span>
		</strong>
		<span class="tt1t1">
				    </span> 
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			데이터의 사후처리보다 사전처리에 비중을 둔다. 					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			데이터의 질보다 양을 중요시 한다. 					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			통계학에서 중요시 하는 인과관계보다 상관관계에 비중을 둔다. 					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			조사 방법론으로는 표본조사에서 전수조사에 비중을 둔다.					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a3" class="b2 help" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a3" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">1</i>
			<span class="t2t1">
			데이터의 사후처리보다 사전처리에 비중을 둔다. 			</span>
					</div>
        <br>
				<strong class="tt1">해설</strong>
		<div class="t1">
		빅데이터가 만들어 내는 변화에는 데이터의 사전처리에서 사후처리에 비중을 많이 두게 된다. 				</div>
		
				
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				정답은 1번입니다.<br>
<br>
빅데이터는 대량의 데이터를 분석하여 유의미한 정보를 추출하는 과정에서 다양한 변화를 가져옵니다. 이러한 변화는 데이터 처리 방식, 분석 방법론, 데이터의 중요성 등에 영향을 미칩니다.<br>
<br>
1. 데이터의 사후처리보다 사전처리에 비중을 둔다.<br>
: 빅데이터 환경에서는 데이터가 생성되기 전에 미리 처리하는 것보다, 생성된 후에 분석하는 것이 더 중요합니다. 따라서 사전처리보다는 사후처리에 비중을 두는 것이 일반적입니다.<br>
<br>
2. 데이터의 질보다 양을 중요시 한다.<br>
: 빅데이터에서는 데이터의 양이 많을수록 더 많은 패턴과 인사이트를 얻을 수 있기 때문에, 데이터의 양이 질보다 중요시되는 경향이 있습니다.<br>
<br>
3. 통계학에서 중요시 하는 인과관계보다 상관관계에 비중을 둔다.<br>
: 빅데이터 분석에서는 인과관계보다는 상관관계를 통해 데이터 간의 관계를 파악하는 것이 더 일반적입니다. 이는 대량의 데이터를 빠르게 분석하기 위한 방법론 중 하나입니다.<br>
<br>
4. 조사 방법론으로는 표본조사에서 전수조사에 비중을 둔다.<br>
: 빅데이터 분석에서는 전체 데이터를 대상으로 하는 전수조사가 가능해지면서, 표본조사보다 전수조사가 더 많이 활용됩니다.<br>
<br>
<br>
빅데이터 환경에서는 데이터의 사후처리가 더 중요합니다. 따라서 '데이터의 사후처리보다 사전처리에 비중을 둔다'는 빅데이터의 변화로 부적절합니다. 다른 선택지들은 빅데이터가 가져오는 일반적인 변화와 일치합니다.<br>
<br>
따라서, 정답은 '1. 데이터의 사후처리보다 사전처리에 비중을 둔다.' 입니다.<br>
			</div>
			<div class="t2">
									#빅데이터									# 사전처리									# 사후처리									# 상관관계									# 전수조사							</div>
		</div>
		
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">1과목</span>
			<span class="g1">데이터베이스 정의와 특징</span>
			<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">4.</span>
			<span class="tt1t1">
				다음 중 용어와 의미가 잘못 연결된 것을 모두 고르시오.					
					<span class="tt1t1">
						A. OLTP -다차원의 데이터를 대화식으로 분석하기 위한 소프트웨어 <br>
B. Business Intelligence -경영 의사결정을 위한 통계적이고 수학적인 분석에 초점을 둔 기법 <br>
C. Business Analytics - 데이터 기반 의사결정을 지원하기 위한 리포트 중심의 도구<br>
D. Data mining - 대용량 데이터로부터 의미 있는 관계, 규칙, 패턴을 찾는 과정 					</span>
							</span>
		</strong>
		<span class="tt1t1">
				    </span> 
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			A					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			A, B					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			A, B, C					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			A, B, C, D					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a4" class="b2 help" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a4" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">3</i>
			<span class="t2t1">
			A, B, C			</span>
					</div>
        <br>
				<strong class="tt1">해설</strong>
		<div class="t1">
		A. OLAP / B. Business Analytics / C. Business Intelligence				</div>
		
				
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				- A. OLTP (Online Transaction Processing)는 다차원의 데이터를 대화식으로 분석하기 위한 소프트웨어가 아니라, <br>
  주로 트랜잭션 처리 시스템을 의미합니다. OLTP는 실시간으로 데이터를 입력하고 처리하는 시스템입니다.<br>
<br>
- B. Business Intelligence (BI)는 경영 의사 결정을 위한 통계적이고 수학적인 분석에 초점을 둔 기법이 아니라, 데이터 수집, <br>
  저장, 분석을 통해 경영 의사 결정을 지원하는 도구와 프로세스를 의미합니다. BI는 주로 리포팅, 대시보드, <br>
  데이터 시각화 등을 포함합니다.<br>
<br>
- C. Business Analytics (BA)는 데이터 기반 의사 결정을 지원하기 위한 리포트 중심의 도구가 아니라, 데이터 분석을 통해 <br>
  비즈니스 문제를 해결하고 예측 모델을 구축하는 기법을 의미합니다. BA는 통계, 데이터 마이닝, 예측 분석 등을 포함합니다.<br>
<br>
- D. Data mining은 대용량 데이터로부터 의미 있는 관계, 규칙, 패턴을 찾는 과정으로 올바르게 연결되었습니다.<br>
<br>
			</div>
			<div class="t2">
									# OLTP									# Business Intelligence									# Business Analytics									# Data mining							</div>
		</div>
		
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">1과목</span>
			<span class="g1">비즈니스 모델</span>
			<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">5.</span>
			<span class="tt1t1">
				아래 제시한 문제(A,C)의 해결에 필요한 빅데이터 분석 테크닉(가,마)을 적절하게 연결한 것은?					
					<span class="tt1t1">
						&lt;문제&gt;<br>
A. 응급실 의사 배치 최적화<br>
B. 사용자 기호 분석 기반 추적<br>
C. 최다 구매 패턴을 보이는 상품 진열<br>
<br>
&lt;빅데이터 분석 테크닉&gt;<br>
가. 연관규칙 학습 <br>
나. 유형분석 <br>
다. 유전 알고리즘 <br>
라. 협업 필터링 <br>
마. 회귀분석					</span>
							</span>
		</strong>
		<span class="tt1t1">
				    </span> 
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			나 - 다 - 마					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			라 - 가 - 다					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			다 - 라 - 가					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			마 - 라 - 나					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a5" class="b2 help" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a5" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">3</i>
			<span class="t2t1">
			다 - 라 - 가			</span>
					</div>
        <br>
				<strong class="tt1">해설</strong>
		<div class="t1">
		A,C에 해당하는 개념은 유전 알고리즘, 협업 필터링, 연관규칙 학습에 관한 내용이다.				</div>
		
				
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				A. 응급실 의사 배치 최적화: 유전 알고리즘 (다)<br>
- 유전 알고리즘은 최적화 문제를 해결하는 데 효과적인 방법입니다. 응급실 의사 배치 최적화는 여러 변수와 제약 조건이 <br>
  있는 복잡한 최적화 문제로, 유전 알고리즘을 사용하여 최적의 배치를 찾을 수 있습니다.<br>
  <br>
B. 사용자 기호 분석 기반 추적: 협업 필터링 (라)<br>
- 협업 필터링은 사용자들의 기호나 행동 패턴을 분석하여 비슷한 사용자 그룹을 찾아내고, 이를 기반으로 추천 시스템을 <br>
  만드는 데 사용됩니다. 사용자 기호 분석 기반 추적에 적합한 방법입니다.<br>
  <br>
C. 최다 구매 패턴을 보이는 상품 진열: 연관 규칙 학습 (가)<br>
- 연관 규칙 학습은 데이터 내에서 항목 간의 연관성을 찾아내는 기법으로, 주로 장바구니 분석에 사용됩니다. <br>
  최다 구매 패턴을 분석하여 상품 진열을 최적화하는 데 적합합니다.<br>
<br>
			</div>
			<div class="t2">
									# 유전 알고리즘									# 협업 필터링									# 연관규칙 학습									# 유형분석									# 회귀분석							</div>
		</div>
		
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">1과목</span>
			<span class="g1">비즈니스 모델</span>
			<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">6.</span>
			<span class="tt1t1">
				“구글은 이미 지난 2010년에 서비스 이용자가 1시간 뒤에 어떤 일을 할지 87% 정확도로 예측 할 수 있는 데이터와 분석신뢰도를 확보하고 있다” 의 빅데이터 위기요인은 무엇인가? 							</span>
		</strong>
		<span class="tt1t1">
				    </span> 
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			데이터오용					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			책임원칙훼손					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			사생활침해					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			분석기술의 낙후					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a6" class="b2 help" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a6" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">3</i>
			<span class="t2t1">
			사생활침해			</span>
					</div>
        <br>
				<strong class="tt1">해설</strong>
		<div class="t1">
		빅데이터의 위기요인 3가지는 데이터오용, 책임원칙훼손, 사생활침해이다.				</div>
		
				
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				정답은 3번입니다.<br>
<br>
빅데이터의 활용은 많은 이점을 제공하지만, 동시에 여러 가지 위기 요인을 내포하고 있습니다. 특히, 개인의 행동을 예측할 수 있는 수준의 데이터 분석은 사생활 침해의 위험을 증가시킵니다. 이는 개인의 프라이버시가 침해될 수 있는 가능성을 의미하며, 데이터가 어떻게 사용되는지에 대한 투명성과 책임이 중요합니다. 빅데이터 시대의 위기 요인에는 사생활 침해, 책임 원칙 훼손, 데이터 오용 등이 있으며, 이러한 문제를 해결하기 위해서는 데이터 사용에 대한 명확한 규제와 책임 있는 데이터 관리가 필요합니다.<br>
<br>
1. 데이터오용 <br>
: 데이터오용은 데이터를 원래의 목적과 다르게 사용하거나, 잘못된 방식으로 사용하는 것을 의미합니다. 이는 데이터의 신뢰성을 떨어뜨리고, 잘못된 결론을 초래할 수 있습니다. 예를 들어, 고객의 구매 데이터를 잘못 해석하여 잘못된 마케팅 전략을 수립하는 경우가 이에 해당합니다. 그러나 이 문제는 주어진 시나리오에서 직접적으로 언급된 위기 요인과는 거리가 있습니다.<br>
<br>
2. 책임원칙훼손 <br>
: 책임원칙훼손은 빅데이터 분석의 결과가 개인에게 부정적인 영향을 미칠 수 있는 상황에서 발생합니다. 예를 들어, 예측 알고리즘이 잘못된 결과를 제공하여 개인의 기회를 제한하거나 불이익을 줄 수 있습니다. 이는 빅데이터 분석의 정확도가 높아질수록 발생할 수 있는 문제로, 예측 결과에 대한 책임을 명확히 하는 것이 중요합니다. 그러나 이 문제는 주어진 시나리오에서 직접적으로 언급된 위기 요인과는 다릅니다.<br>
<br>
3. 사생활침해 <br>
: 사생활침해는 개인의 프라이버시가 침해되는 상황을 의미합니다. 빅데이터 분석을 통해 개인의 행동을 예측할 수 있는 경우, 개인의 사생활이 노출될 위험이 있습니다. 예를 들어, 사용자의 위치 데이터나 검색 기록을 통해 개인의 일상적인 행동을 추적할 수 있는 경우가 이에 해당합니다. 주어진 시나리오에서 구글이 사용자의 행동을 예측할 수 있다는 점은 사생활 침해의 위험을 나타냅니다.<br>
<br>
4. 분석기술의 낙후 <br>
: 분석기술의 낙후는 데이터 분석 기술이 최신 기술에 비해 뒤떨어져 있는 상황을 의미합니다. 이는 데이터 분석의 정확성과 효율성을 저하시킬 수 있습니다. 그러나 주어진 시나리오에서는 구글이 높은 정확도로 예측할 수 있는 기술을 보유하고 있다는 점에서, 분석기술의 낙후는 해당되지 않습니다.<br>
<br>
문제에서 제시된 시나리오는 구글이 사용자의 행동을 높은 정확도로 예측할 수 있다는 점을 강조하고 있습니다. 이는 개인의 사생활이 침해될 수 있는 가능성을 나타내며, 따라서 사생활 침해가 주요 위기 요인으로 작용합니다. 다른 선택지들은 각각의 위기 요인을 설명하고 있지만, 주어진 시나리오와 직접적으로 관련이 있는 것은 사생활 침해입니다.<br>
따라서, 정답은 '3. 사생활침해' 입니다.<br>
			</div>
			<div class="t2">
									#빅데이터									# 사생활 침해									# 데이터 분석									# 프라이버시							</div>
		</div>
		
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">1과목</span>
			<span class="g1">전략 인사이트 도출을 위한 필요 역략</span>
			<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">7.</span>
			<span class="tt1t1">
				데이터사이언티스트가 갖추어야 할 역량에 대한 설명 중 소프트스킬(Soft Skill)에 해당하지 않는 것은 무엇인가? 							</span>
		</strong>
		<span class="tt1t1">
				    </span> 
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			창의적 사고와 호기심 그리고 논리적 비판을 할 수 있는 통찰력 있는 분석 기술 					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			최적의 분석 설계 및 노하우 축적이 가능한 분석 기술에 대한 숙련도 					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			스토리텔링과 같은 설득력 있는 전달 기술 					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			커뮤니케이션이 가능한 다분야간의 협력 기술					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a7" class="b2 help" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a7" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">2</i>
			<span class="t2t1">
			최적의 분석 설계 및 노하우 축적이 가능한 분석 기술에 대한 숙련도 			</span>
					</div>
        <br>
				<strong class="tt1">해설</strong>
		<div class="t1">
		최적의 분석 설계 및 노하우 축적이 가능한 분석 기술에 대한 숙련도는 데이터사이언티스트가 갖추어야할 하드스킬(Hard Skill)에 해당한다.				</div>
		
				
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				정답은 2번입니다.<br>
<br>
데이터 사이언티스트는 데이터를 분석하고 해석하여 비즈니스 문제를 해결하는 전문가입니다. 이들은 하드 스킬과 소프트 스킬을 모두 갖추어야 합니다. 하드 스킬은 데이터 분석 기술, 프로그래밍, 통계학 등의 기술적 능력을 포함하며, 소프트 스킬은 커뮤니케이션, 창의적 사고, 협력 능력 등 사람과의 상호작용 및 문제 해결에 필요한 능력을 포함합니다. 소프트 스킬은 데이터 사이언티스트가 분석 결과를 효과적으로 전달하고, 다양한 분야의 전문가들과 협력하여 문제를 해결하는 데 필수적입니다.<br>
<br>
1. 창의적 사고와 호기심 그리고 논리적 비판을 할 수 있는 통찰력 있는 분석 기술 <br>
: 통찰력 있는 분석 기술은 데이터 사이언티스트가 데이터를 통해 깊이 있는 인사이트를 도출하는 능력을 의미합니다. 이는 창의적 사고와 논리적 비판을 통해 문제의 본질을 파악하고, 새로운 해결책을 제시하는 데 중요한 역할을 합니다. 이러한 능력은 소프트 스킬에 해당합니다.<br>
<br>
2. 최적의 분석 설계 및 노하우 축적이 가능한 분석 기술에 대한 숙련도 <br>
: 분석 기술에 대한 숙련도는 데이터 사이언티스트가 다양한 분석 기법을 효과적으로 활용할 수 있는 능력을 의미합니다. 이는 데이터 분석의 정확성과 효율성을 높이는 데 필수적이며, 하드 스킬에 해당합니다. 따라서 소프트 스킬로 분류되지 않습니다.<br>
<br>
3. 스토리텔링과 같은 설득력 있는 전달 기술 <br>
: 스토리텔링과 같은 설득력 있는 전달 기술은 분석 결과를 이해하기 쉽게 전달하는 능력을 의미합니다. 이는 데이터를 기반으로 한 인사이트를 청중에게 효과적으로 전달하여 의사결정에 영향을 미치는 데 중요한 역할을 하며, 소프트 스킬에 해당합니다.<br>
<br>
4. 커뮤니케이션이 가능한 다분야간의 협력 기술 <br>
: 다분야 간의 협력 기술은 다양한 분야의 전문가들과 효과적으로 소통하고 협력하여 문제를 해결하는 능력을 의미합니다. 이는 데이터 사이언티스트가 복잡한 문제를 해결하는 데 필수적인 소프트 스킬입니다.<br>
<br>
정답은 2번입니다. 분석 기술에 대한 숙련도는 데이터 사이언티스트가 다양한 분석 기법을 효과적으로 활용할 수 있는 능력을 의미하며, 이는 하드 스킬에 해당합니다. 나머지 선지들은 모두 소프트 스킬에 해당합니다. 1번은 창의적 사고와 논리적 비판을 통한 통찰력 있는 분석, 3번은 스토리텔링을 통한 설득력 있는 전달, 4번은 다분야 간의 협력을 통한 커뮤니케이션 능력으로 모두 소프트 스킬입니다.<br>
따라서, 정답은 '2. 최적의 분석 설계 및 노하우 축적이 가능한 분석 기술에 대한 숙련도' 입니다.<br>
			</div>
			<div class="t2">
									#데이터 사이언티스트									# 소프트 스킬									# 하드 스킬									# 분석 기술									# 통찰력									# 스토리텔링									# 협력							</div>
		</div>
		
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">1과목</span>
			<span class="g1">비즈니스 모델</span>
			<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">8.</span>
			<span class="tt1t1">
				법률 전문가인 변호인, 금전 거래에 정통한 회계사처럼 컴퓨터와 수학, 나아가 통계학이나 비즈니스에 두루 깊은 지식을 갖춘 직업으로 알고리즘에 부당함으로 피해 받는 사람들을 구제할 수 있는 능력을 가진 전문가로 적절한 것은?							</span>
		</strong>
		<span class="tt1t1">
				    </span> 
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			컴퓨터 활용 능력가 					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			데이터 사이언티스트 					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			데이터 분석가 					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			알고리즈미스트					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a8" class="b2 help" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a8" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">4</i>
			<span class="t2t1">
			알고리즈미스트			</span>
					</div>
        <br>
				<strong class="tt1">해설</strong>
		<div class="t1">
		알고리즘에 대한 접근권이 제공된다고 해도 수십만 줄로 코딩된 프로그램을 보고 그 내용을 해석해 낼 수 없기 때문에 알고리즘에 부당함으로 피해 받는 사람들을 구제할 수 있는 전문가가 알고리즈미스트이다.				</div>
		
				
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				정답은 4번입니다.<br>
<br>
이 문제는 알고리즘과 관련된 불공정한 상황에서 피해를 입은 사람들을 구제할 수 있는 전문가를 찾는 것입니다. 이 전문가들은 컴퓨터 과학, 수학, 통계학, 비즈니스에 대한 깊은 지식을 갖추고 있어야 합니다.<br>
<br>
1. 컴퓨터 활용 능력가<br>
: 이 직업은 컴퓨터를 활용하는 능력을 평가하는 자격을 의미합니다. 주로 컴퓨터의 기본적인 사용법과 소프트웨어 활용 능력을 측정하는 데 중점을 둡니다. 알고리즘의 부당함을 해결하는 데 필요한 심층적인 분석 능력이나 통계적 지식은 포함되지 않습니다.<br>
<br>
2. 데이터 사이언티스트<br>
: 이 직업은 대량의 데이터를 분석하고 해석하여 유의미한 정보를 도출하는 데 중점을 둡니다. 통계학과 컴퓨터 과학에 대한 지식이 필요하지만, 알고리즘의 공정성 문제를 직접적으로 다루는 역할은 아닙니다.<br>
<br>
3. 데이터 분석가<br>
: 이 직업은 데이터를 수집하고 분석하여 비즈니스 의사결정에 필요한 정보를 제공하는 역할을 합니다. 데이터 사이언티스트와 유사하지만, 알고리즘의 공정성 문제를 해결하는 데 필요한 법률적 지식이나 심층적인 알고리즘 분석 능력은 부족할 수 있습니다.<br>
<br>
4. 알고리즈미스트<br>
: 이 직업은 알고리즘을 설계하고 분석하는 데 중점을 둡니다. 알고리즘의 공정성 문제를 해결하기 위해 필요한 컴퓨터 과학, 수학, 통계학, 비즈니스에 대한 깊은 지식을 갖추고 있으며, 알고리즘의 부당함으로 인한 피해를 구제할 수 있는 능력을 가지고 있습니다.<br>
<br>
<br>
알고리즈미스트는 알고리즘의 설계와 분석에 중점을 두고 있으며, 알고리즘의 공정성 문제를 해결할 수 있는 능력을 갖추고 있습니다. 다른 선택지들은 각각의 전문 분야에서 중요한 역할을 하지만, 알고리즘의 부당함을 직접적으로 해결하는 데 필요한 모든 지식을 갖추고 있지는 않습니다.<br>
<br>
따라서, 정답은 '4. 알고리즈미스트' 입니다.<br>
			</div>
			<div class="t2">
									#알고리즘									# 공정성									# 데이터 분석									# 컴퓨터 과학							</div>
		</div>
		
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">1과목</span>
			<span class="g1">데이터베이스 정의와 특징</span>
			<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">9.</span>
			<span class="tt1t1">
				2000년대 기업내부 데이터베이스 구축의 화두였던 고객관계관리(CRM)에 대한 설명으로 적절한 것은 무엇인가? 							</span>
		</strong>
		<span class="tt1t1">
				    </span> 
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			단순한 정보의 수집에서 탈피하고 분석이 중심이 되는 시스템 구축을 지향한다. 					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			외부 공급업체와의 정보시스템 통합을 통해 시간과 비용을 최적화하기 위함이다. 					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			부품의 설계, 제조, 유통 등의 공정을 포함한다.					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			기업의 내부 고객들만을 대상으로 한 정보시스템이다.					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a9" class="b2 help" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a9" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">1</i>
			<span class="t2t1">
			단순한 정보의 수집에서 탈피하고 분석이 중심이 되는 시스템 구축을 지향한다. 			</span>
					</div>
        <br>
				<strong class="tt1">해설</strong>
		<div class="t1">
		CRM은 고객별 구매이력 데이터베이스를 분석하여 고객에 대한 이해를 돕고 이를 바탕으로 각종 마케팅 전략을 펼치는 것을 말한다.				</div>
		
				
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				정답은 1번입니다.<br>
<br>
고객관계관리(CRM)는 고객과의 관계를 관리하고 강화하기 위한 전략적 접근 방식입니다. 이는 고객 데이터를 수집하고 분석하여 고객의 요구와 행동을 이해하고, 이를 통해 고객 만족도를 높이고 장기적인 관계를 구축하는 것을 목표로 합니다.<br>
<br>
1. 단순한 정보의 수집에서 탈피하고 분석이 중심이 되는 시스템 구축을 지향한다.<br>
: CRM의 핵심은 단순히 데이터를 수집하는 것을 넘어, 수집된 데이터를 분석하여 고객의 행동과 요구를 이해하고 예측하는 데 있습니다. 이를 통해 기업은 고객 맞춤형 서비스를 제공하고, 고객 만족도를 높일 수 있습니다.<br>
<br>
2. 외부 공급업체와의 정보시스템 통합을 통해 시간과 비용을 최적화하기 위함이다.<br>
: 이 설명은 공급망 관리(SCM)와 관련이 있습니다. SCM은 외부 공급업체와의 정보시스템 통합을 통해 효율성을 높이는 것을 목표로 합니다. CRM과는 다른 개념입니다.<br>
<br>
3. 부품의 설계, 제조, 유통 등의 공정을 포함한다.<br>
: 이 설명은 제품 수명 주기 관리(PLM)와 관련이 있습니다. PLM은 제품의 설계, 제조, 유통 등의 전 과정을 관리하는 시스템으로, CRM과는 다른 영역입니다.<br>
<br>
4. 기업의 내부 고객들만을 대상으로 한 정보시스템이다.<br>
: CRM은 기업의 외부 고객을 대상으로 하며, 고객과의 관계를 강화하는 데 중점을 둡니다. 내부 고객을 대상으로 하는 것은 인적 자원 관리(HRM)와 관련이 있습니다.<br>
<br>
<br>
CRM의 본질은 고객 데이터를 분석하여 고객의 요구를 이해하고, 이를 통해 고객과의 관계를 강화하는 것입니다. 따라서 CRM의 설명으로 적절한 것은 첫 번째 선택지입니다. 다른 선택지들은 각각 SCM, PLM, HRM과 관련된 설명으로, CRM의 정의와는 맞지 않습니다.<br>
<br>
따라서, 정답은 '1. 단순한 정보의 수집에서 탈피하고 분석이 중심이 되는 시스템 구축을 지향한다.' 입니다.<br>
			</div>
			<div class="t2">
									#고객관계관리									# 데이터 분석									# 고객 만족									# 전략적 접근							</div>
		</div>
		
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">1과목</span>
			<span class="g1">데이터와 정보</span>
			<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">10.</span>
			<span class="tt1t1">
				정량 데이터(Quantitative Data)의 범주에 포함되지 않는 것은?							</span>
		</strong>
		<span class="tt1t1">
				    </span> 
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			도형					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			기호					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			수치					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			문자					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a10" class="b2 help" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a10" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">4</i>
			<span class="t2t1">
			문자			</span>
					</div>
        <br>
				<strong class="tt1">해설</strong>
		<div class="t1">
		정량적 데이터의 형태는 수치, 도형, 기호 등이며, 정성적 데이터의 형태는 언어, 문자 등이다.				</div>
		
				
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				정답은 4번입니다.<br>
<br>
정량 데이터는 수치로 표현할 수 있는 데이터를 의미합니다. 이는 측정 가능하고 수치적 분석이 가능한 데이터를 포함합니다. 정량 데이터는 주로 수치, 도형, 기호 등으로 표현되며, 이러한 표현은 데이터의 양적 특성을 나타내는 데 사용됩니다. 반면, 정성 데이터는 언어나 문자로 표현되며, 주로 데이터의 질적 특성을 나타냅니다. 정량 데이터는 통계적 분석과 수치적 비교가 가능하다는 점에서 정성 데이터와 차별화됩니다.<br>
<br>
1. 도형 <br>
: 도형은 정량 데이터를 표현하는 데 사용될 수 있습니다. 예를 들어, 그래프나 차트에서 도형은 수치적 데이터를 시각적으로 나타내는 도구로 사용됩니다. 도형은 데이터의 양적 특성을 시각적으로 비교하거나 분석하는 데 유용합니다.<br>
<br>
2. 기호 <br>
: 기호는 정량 데이터를 나타내는 데 사용될 수 있습니다. 수학적 기호나 통계적 기호는 수치 데이터를 표현하고 분석하는 데 필수적입니다. 기호는 데이터의 수치적 특성을 간결하게 나타내고, 복잡한 수치적 관계를 설명하는 데 도움을 줍니다.<br>
<br>
3. 수치 <br>
: 수치는 정량 데이터의 핵심입니다. 수치 데이터는 측정 가능하고, 수치적 분석이 가능하며, 통계적 방법을 통해 다양한 분석을 수행할 수 있습니다. 수치는 정량 데이터의 가장 기본적인 형태로, 데이터의 양적 특성을 직접적으로 나타냅니다.<br>
<br>
4. 문자 <br>
: 문자는 정성 데이터를 나타내는 데 주로 사용됩니다. 문자는 데이터의 질적 특성을 설명하거나 서술하는 데 적합하며, 수치적 분석보다는 의미적 분석에 중점을 둡니다. 따라서 문자는 정량 데이터의 범주에 포함되지 않습니다.<br>
<br>
정량 데이터는 수치, 도형, 기호 등으로 표현되며, 이는 모두 수치적 분석이 가능한 형태입니다. 반면, 문자는 정성 데이터를 나타내는 데 사용되며, 수치적 분석보다는 질적 분석에 적합합니다. 따라서 문자는 정량 데이터의 범주에 포함되지 않으며, 정답은 4번입니다.<br>
따라서, 정답은 '4. 문자' 입니다.<br>
			</div>
			<div class="t2">
									#정량 데이터									# 정성 데이터									# 수치									# 도형									# 기호									# 문자							</div>
		</div>
		
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">2과목</span>
			<span class="g1">ETL(Extraction, Trans formation and Load)</span>
			<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">11.</span>
			<span class="tt1t1">
				ODS 구성을 위한 일괄 작업 ETL의 작업 단계 중 데이터 인티그레이션(Data Integration) 단계에 대한 설명으로 가장 적절한 것은? 							</span>
		</strong>
		<span class="tt1t1">
				    </span> 
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			클렌징된 데이터를 ODS 내의 단일 통합 테이블에 적재하는 단계이다.					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			범위, 도메인, 유일성 확보 등의 규칙을 기준으로 데이터 품질을 점검하는 단계이다. 					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			다양한 데이터 원천으로부터 데이터를 획득하는 단계이다.					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			식별된 오류 데이터들을 수정하는 단계이다.					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a11" class="b2 help" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a11" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">1</i>
			<span class="t2t1">
			클렌징된 데이터를 ODS 내의 단일 통합 테이블에 적재하는 단계이다.			</span>
					</div>
        <br>
				<strong class="tt1">해설</strong>
		<div class="t1">
		②번은 프로파일링 단계, ③번은 인터페이스 단계, ④번은 데이터 클렌징 단계에 해당한다.				</div>
		
				
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				정답은 1번입니다.<br>
<br>
ODS(Operational Data Store)는 다양한 데이터 원천으로부터 데이터를 수집하고, 이를 클렌징 및 통합하여 저장하는 데이터베이스입니다. ODS는 주로 실시간 또는 근접 실시간 데이터를 처리하며, 데이터 웨어하우스와 달리 최신 데이터를 저장하는 데 중점을 둡니다. ODS 구성을 위한 ETL(Extract, Transform, Load) 프로세스는 여러 단계로 나뉘며, 각 단계는 데이터의 수집, 정제, 통합, 그리고 최종적으로 데이터의 적재를 포함합니다. 데이터 인티그레이션 단계는 클렌징된 데이터를 ODS 내의 단일 통합 테이블에 적재하는 것을 목표로 합니다.<br>
<br>
1. 클렌징된 데이터를 ODS 내의 단일 통합 테이블에 적재하는 단계이다. <br>
: 데이터 인티그레이션 단계는 클렌징된 데이터를 ODS 내의 단일 통합 테이블에 적재하는 단계입니다. 이 단계는 데이터 클렌징이 완료된 후, 데이터를 통합하여 ODS에 저장하는 것을 목표로 합니다. 따라서 이 설명은 데이터 인티그레이션 단계에 대한 정확한 설명입니다.<br>
<br>
2. 범위, 도메인, 유일성 확보 등의 규칙을 기준으로 데이터 품질을 점검하는 단계이다. <br>
: 데이터 품질 점검은 데이터 프로파일링 단계에서 이루어집니다. 이 단계에서는 데이터의 범위, 도메인, 유일성 등을 기준으로 데이터 품질을 점검합니다. 따라서 이 설명은 데이터 인티그레이션 단계가 아닌 데이터 프로파일링 단계에 해당합니다.<br>
<br>
3. 다양한 데이터 원천으로부터 데이터를 획득하는 단계이다. <br>
: 다양한 데이터 원천으로부터 데이터를 획득하는 단계는 인터페이스 단계입니다. 이 단계에서는 OLEDB, ODBC, FTP 등의 프로토콜을 사용하여 데이터를 수집합니다. 따라서 이 설명은 데이터 인티그레이션 단계가 아닌 인터페이스 단계에 해당합니다.<br>
<br>
4. 식별된 오류 데이터들을 수정하는 단계이다. <br>
: 식별된 오류 데이터를 수정하는 단계는 데이터 클렌징 단계입니다. 이 단계에서는 데이터 프로파일링에서 식별된 오류를 수정하여 데이터의 정확성을 높입니다. 따라서 이 설명은 데이터 인티그레이션 단계가 아닌 데이터 클렌징 단계에 해당합니다.<br>
<br>
정답은 1번입니다. 데이터 인티그레이션 단계는 클렌징된 데이터를 ODS 내의 단일 통합 테이블에 적재하는 단계로, 이 설명이 가장 적절합니다. 2번은 데이터 프로파일링 단계에 해당하고, 3번은 인터페이스 단계, 4번은 데이터 클렌징 단계에 해당하므로 오답입니다.<br>
따라서, 정답은 '1. 클렌징된 데이터를 ODS 내의 단일 통합 테이블에 적재하는 단계이다.' 입니다.<br>
			</div>
			<div class="t2">
									#ODS									# 데이터 인티그레이션									# ETL									# 데이터 클렌징									# 데이터 프로파일링							</div>
		</div>
		
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">2과목</span>
			<span class="g1">분산 데이터 저장 기술</span>
			<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">12.</span>
			<span class="tt1t1">
				구글 빅테이블에 관한 설명으로 적절한 것은 무엇인가?							</span>
		</strong>
		<span class="tt1t1">
				    </span> 
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			테이블내의 모든 데이터는 Column-Key의 사전적 순서로 정렬/저장된다.					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			동일한 Column-Key 에 대해 타임스탬프(Timestamp)가 다른 여러 버전의 값이 존재할 수 없다.					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			BigTable에 저장되는 하나의 데이터(map)의 정렬 기준은 ‘rowkey + column key(로우 식별자 + 칼럼 이름)이다.					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			특정 노드에 장애가 발생할 경우 빅테이블의 마스터(Master)는 장애가 발생한 노드에서 서비스되는 Tablet을 다른 노드로 재할당 시킨다.					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a12" class="b2 help" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a12" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">4</i>
			<span class="t2t1">
			특정 노드에 장애가 발생할 경우 빅테이블의 마스터(Master)는 장애가 발생한 노드에서 서비스되는 Tablet을 다른 노드로 재할당 시킨다.			</span>
					</div>
        <br>
				<strong class="tt1">해설</strong>
		<div class="t1">
		테이블내의 모든 데이터는 Row-Key의 사전적 순서로 정렬되며, 정렬 기준은 ‘rowkey + columnkey + timestamp’이다. 동일한 Column-Key에 대해 타임스탬프(Timestamp)가 다른 여러 버전의 값이 존재할 수 있다.				</div>
		
				
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				정답은 4번입니다.<br>
<br>
구글 빅테이블은 대규모 데이터 저장을 위한 분산형 NoSQL 데이터베이스로, 주로 대량의 구조화된 데이터를 처리하는 데 사용됩니다. 빅테이블은 데이터의 확장성과 고가용성을 보장하며, 데이터는 row key를 기준으로 정렬되어 저장됩니다.<br>
<br>
1. 테이블내의 모든 데이터는 Column-Key의 사전적 순서로 정렬/저장된다.<br>
: 빅테이블에서 데이터는 row key를 기준으로 정렬됩니다. Column-Key가 아닌 row key의 사전적 순서에 따라 데이터가 정렬되고 저장됩니다. 이는 데이터 검색과 접근 속도를 높이는 데 중요한 역할을 합니다.<br>
<br>
2. 동일한 Column-Key 에 대해 타임스탬프(Timestamp)가 다른 여러 버전의 값이 존재할 수 없다.<br>
: 빅테이블은 동일한 Column-Key에 대해 여러 버전의 값을 저장할 수 있습니다. 각 값은 타임스탬프와 함께 저장되어, 시간에 따른 데이터의 변화를 추적할 수 있습니다. 이는 데이터의 버전 관리에 유용합니다.<br>
<br>
3. BigTable에 저장되는 하나의 데이터(map)의 정렬 기준은 ‘rowkey + column key(로우 식별자 + 칼럼 이름)이다.<br>
: 빅테이블에서 데이터의 정렬 기준은 row key입니다. column key는 데이터의 식별에 사용되지만, 정렬 기준은 아닙니다. 데이터는 row key에 따라 정렬되며, column key는 데이터의 구조를 정의하는 데 사용됩니다.<br>
<br>
4. 특정 노드에 장애가 발생할 경우 빅테이블의 마스터(Master)는 장애가 발생한 노드에서 서비스되는 Tablet을 다른 노드로 재할당 시킨다.<br>
: 빅테이블의 마스터는 특정 노드에 장애가 발생할 경우, 해당 노드에서 서비스되던 Tablet을 다른 노드로 재할당하여 서비스의 연속성을 유지합니다. 이는 빅테이블의 고가용성을 보장하는 중요한 메커니즘입니다.<br>
<br>
<br>
빅테이블은 고가용성을 위해 장애가 발생한 노드의 Tablet을 다른 노드로 재할당하는 기능을 제공합니다. 이는 데이터의 지속적인 접근성을 보장하는 데 필수적입니다. 다른 선택지들은 빅테이블의 데이터 정렬 및 버전 관리 방식에 대한 오해를 포함하고 있습니다.<br>
<br>
따라서, 정답은 '4. 특정 노드에 장애가 발생할 경우 빅테이블의 마스터(Master)는 장애가 발생한 노드에서 서비스되는 Tablet을 다른 노드로 재할당 시킨다.' 입니다.<br>
			</div>
			<div class="t2">
									#빅테이블									# row key									# 고가용성									# 데이터 정렬							</div>
		</div>
		
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">2과목</span>
			<span class="g1">클라우드 인프라 기술</span>
			<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">13.</span>
			<span class="tt1t1">
				하이퍼바이저(Hypervisor)의 개념 및 특징으로 옳지 않은 것은?							</span>
		</strong>
		<span class="tt1t1">
				    </span> 
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			하이퍼바이저는 실행환경 격리, 시스템 자원 할당, 하드웨어 환경 에뮬레이션(Emulation) 등의 기능을 한다.					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			엄격하게 구분할 경우에는 차이가 있지만 일반적으로 가상머신(Virtual Machine)을 하이퍼바이저라고 할 수 있으며, 하이퍼바이저는 VMM(Virtual Machine Monitor)이라고도 한다.					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			호스트 기반 하이퍼바이저는 하드웨어와 호스트 운영체제 사이에 위치하며, 베어메탈 하이퍼바이저는 호스트 운영체제와 게스트 운영체제 사이에 위치한다.					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			하이퍼바이저를 통해 사용자는 새로운 운영체제의 설치, 애플리케이션의 테스팅 및 업그레이드를 동일한 물리적 서버에서 동시에 수행할 수 있다.					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a13" class="b2 help" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a13" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">3</i>
			<span class="t2t1">
			호스트 기반 하이퍼바이저는 하드웨어와 호스트 운영체제 사이에 위치하며, 베어메탈 하이퍼바이저는 호스트 운영체제와 게스트 운영체제 사이에 위치한다.			</span>
					</div>
        <br>
				<strong class="tt1">해설</strong>
		<div class="t1">
		베어메탈 하이퍼바이저는 하드웨어와 호스트 운영체제 사이에 위치하며, 호스트 기반 하이퍼바이저는 호스트 운영 체제와 게스트 운영체제 사이에 위치한다.				</div>
		
				
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				정답은 3번입니다.<br>
<br>
하이퍼바이저는 가상화 기술의 핵심 요소로, 물리적 하드웨어 위에 가상화 레이어를 제공하여 여러 운영체제를 동시에 실행할 수 있게 합니다. 하이퍼바이저는 크게 베어메탈 하이퍼바이저와 호스트 기반 하이퍼바이저로 나뉩니다. 베어메탈 하이퍼바이저는 하드웨어 바로 위에 설치되어 높은 성능과 보안을 제공하며, 호스트 기반 하이퍼바이저는 기존 운영체제 위에 설치되어 사용이 간편하지만 성능과 보안 측면에서 제약이 있습니다. 하이퍼바이저는 VMM(Virtual Machine Monitor)이라고도 불리며, 가상머신의 실행환경을 관리하고 자원을 할당하는 역할을 합니다.<br>
<br>
1. 하이퍼바이저는 실행환경 격리, 시스템 자원 할당, 하드웨어 환경 에뮬레이션(Emulation) 등의 기능을 한다. <br>
: 하이퍼바이저는 가상화 환경에서 필수적인 역할을 하며, 실행환경을 격리하고 시스템 자원을 효율적으로 할당합니다. 하드웨어 환경을 에뮬레이션하여 여러 운영체제가 동시에 실행될 수 있도록 지원합니다. 이러한 기능은 가상화의 기본 원리로, 물리적 자원을 가상화하여 여러 가상머신이 독립적으로 운영될 수 있게 합니다.<br>
<br>
2. 엄격하게 구분할 경우에는 차이가 있지만 일반적으로 가상머신(Virtual Machine)을 하이퍼바이저라고 할 수 있으며, 하이퍼바이저는 VMM(Virtual Machine Monitor)이라고도 한다. <br>
: 가상머신과 하이퍼바이저는 엄격히 구분되지만, 일반적으로 가상머신을 관리하는 소프트웨어를 하이퍼바이저라고 부르기도 합니다. 하이퍼바이저는 VMM(Virtual Machine Monitor)로도 불리며, 가상머신의 실행을 모니터링하고 관리하는 역할을 합니다. 이는 가상화 기술의 핵심으로, 여러 운영체제를 동시에 실행할 수 있게 합니다.<br>
<br>
3. 호스트 기반 하이퍼바이저는 하드웨어와 호스트 운영체제 사이에 위치하며, 베어메탈 하이퍼바이저는 호스트 운영체제와 게스트 운영체제 사이에 위치한다. <br>
: 베어메탈 하이퍼바이저는 하드웨어와 직접 상호작용하며, 호스트 운영체제 없이도 가상머신을 실행할 수 있습니다. 반면, 호스트 기반 하이퍼바이저는 기존 운영체제 위에 설치되어 그 위에서 가상머신을 실행합니다. 따라서, 베어메탈 하이퍼바이저는 하드웨어와 운영체제 사이에 위치하고, 호스트 기반 하이퍼바이저는 호스트 운영체제와 게스트 운영체제 사이에 위치합니다. 이 선지는 두 하이퍼바이저의 위치를 잘못 설명하고 있습니다.<br>
<br>
4. 하이퍼바이저를 통해 사용자는 새로운 운영체제의 설치, 애플리케이션의 테스팅 및 업그레이드를 동일한 물리적 서버에서 동시에 수행할 수 있다. <br>
: 하이퍼바이저를 사용하면 물리적 서버 하나에서 여러 운영체제를 동시에 실행할 수 있어, 새로운 운영체제의 설치나 애플리케이션 테스트, 업그레이드를 효율적으로 수행할 수 있습니다. 이는 하이퍼바이저의 주요 장점 중 하나로, 물리적 하드웨어의 추가 구매 없이도 다양한 환경을 테스트할 수 있게 합니다.<br>
<br>
선지 3은 베어메탈 하이퍼바이저와 호스트 기반 하이퍼바이저의 위치를 잘못 설명하고 있습니다. 베어메탈 하이퍼바이저는 하드웨어와 직접 상호작용하며, 호스트 운영체제 없이도 가상머신을 실행할 수 있는 반면, 호스트 기반 하이퍼바이저는 기존 운영체제 위에 설치되어 그 위에서 가상머신을 실행합니다. 따라서, 베어메탈 하이퍼바이저는 하드웨어와 운영체제 사이에 위치하고, 호스트 기반 하이퍼바이저는 호스트 운영체제와 게스트 운영체제 사이에 위치합니다. 이로 인해 선지 3이 틀린 설명입니다.<br>
따라서, 정답은 '3. 호스트 기반 하이퍼바이저는 하드웨어와 호스트 운영체제 사이에 위치하며, 베어메탈 하이퍼바이저는 호스트 운영체제와 게스트 운영체제 사이에 위치한다.' 입니다.<br>
			</div>
			<div class="t2">
									#하이퍼바이저									# 베어메탈									# 호스트 기반									# 가상화									# VMM							</div>
		</div>
		
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">2과목</span>
			<span class="g1">CDC(Change Data Capture)</span>
			<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">14.</span>
			<span class="tt1t1">
				CDC(Change Data Capture)에 대한 설명으로 적절하지 않은 것은?							</span>
		</strong>
		<span class="tt1t1">
				    </span> 
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			CDC는 실시간 처리 보다는 배치처리에 적합하며, 데이터 웨어하우스 및 기타 데이터 저장소 구축에 폭 넓게 활용된다. 					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			CDC 구현 방식 중 대상 시스템에서 데이터 원천을 정기적으로 살펴보고 필요 시 데이터를 다운로드 하는 방식은 ‘풀 방식’에 해당한다.					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			CDC 구현 기법 중 ‘Status on Rows’는 데이터의 변경 여부를 TRUE 혹은 FALSE의 값으로 칼럼에 저장한다.					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			단일 정보 시스템 내에 다수의 CDC 메커니즘이 구현돼 동작될 수 있다.					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a14" class="b2 help" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a14" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">1</i>
			<span class="t2t1">
			CDC는 실시간 처리 보다는 배치처리에 적합하며, 데이터 웨어하우스 및 기타 데이터 저장소 구축에 폭 넓게 활용된다. 			</span>
					</div>
        <br>
				<strong class="tt1">해설</strong>
		<div class="t1">
		CDC는 실시간 혹은 근접 실시간 처리에 적합한 기법이다.				</div>
		
				
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				정답은 1번입니다.<br>
<br>
CDC(Change Data Capture)는 데이터베이스 내 데이터 변경을 식별하여 필요한 후속처리를 자동화하는 기술입니다. 이는 실시간 또는 근접 실시간 데이터 통합을 기반으로 하며, 데이터 웨어하우스 및 기타 데이터 저장소 구축에 널리 활용됩니다. CDC는 다양한 계층에서 구현될 수 있으며, 단일 정보 시스템 내에 다수의 CDC 메커니즘이 동작할 수 있습니다. CDC 구현 방식에는 '푸시 방식'과 '풀 방식'이 있으며, 구현 기법으로는 'Time Stamp on Rows', 'Event Programming', 'Log Scanner on Database' 등이 있습니다.<br>
<br>
1. CDC는 실시간 처리 보다는 배치처리에 적합하며, 데이터 웨어하우스 및 기타 데이터 저장소 구축에 폭 넓게 활용된다. <br>
: CDC는 실시간 또는 근접 실시간 데이터 통합을 기반으로 하며, 이는 데이터 웨어하우스 및 기타 데이터 저장소 구축에 폭넓게 활용됩니다. 따라서 CDC는 실시간 처리에 적합하며, 배치 처리에 적합하다는 설명은 부적절합니다.<br>
<br>
2. CDC 구현 방식 중 대상 시스템에서 데이터 원천을 정기적으로 살펴보고 필요 시 데이터를 다운로드 하는 방식은 ‘풀 방식’에 해당한다. <br>
: CDC의 '풀 방식'은 대상 시스템이 데이터 원천을 정기적으로 살펴보고 필요 시 데이터를 다운로드하는 방식입니다. 이는 CDC의 구현 방식 중 하나로, 데이터 변경을 주기적으로 확인하여 처리하는 방법입니다.<br>
<br>
3. CDC 구현 기법 중 ‘Status on Rows’는 데이터의 변경 여부를 TRUE 혹은 FALSE의 값으로 칼럼에 저장한다. <br>
: CDC 구현 기법 중 'Status on Rows'는 데이터의 변경 여부를 TRUE 또는 FALSE의 값으로 칼럼에 저장하는 방식입니다. 이는 데이터의 변경 상태를 명시적으로 기록하여 변경 여부를 쉽게 확인할 수 있게 합니다.<br>
<br>
4. 단일 정보 시스템 내에 다수의 CDC 메커니즘이 구현돼 동작될 수 있다. <br>
: 단일 정보 시스템 내에 다수의 CDC 메커니즘이 구현되어 동작할 수 있습니다. 이는 다양한 요구사항에 맞춰 여러 CDC 기법을 동시에 사용할 수 있음을 의미합니다.<br>
<br>
선지 1은 CDC가 실시간 처리보다는 배치 처리에 적합하다고 설명하고 있지만, CDC는 실시간 또는 근접 실시간 데이터 통합을 기반으로 하므로 이 설명은 부적절합니다. 나머지 선지들은 CDC의 구현 방식과 기법에 대한 설명으로, 각각의 설명이 CDC의 특성과 일치합니다.<br>
<br>
따라서, 정답은 '1. CDC는 실시간 처리 보다는 배치처리에 적합하며, 데이터 웨어하우스 및 기타 데이터 저장소 구축에 폭 넓게 활용된다.' 입니다.<br>
			</div>
			<div class="t2">
									#CDC									# 실시간 처리									# 데이터 통합									# 풀 방식									# Status on Rows									# 다수의 CDC 메커니즘							</div>
		</div>
		
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">2과목</span>
			<span class="g1">분산 컴퓨팅 기술</span>
			<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">15.</span>
			<span class="tt1t1">
				병렬 쿼리 시스템에 대한 설명 중 옳지 않은 것은? 							</span>
		</strong>
		<span class="tt1t1">
				    </span> 
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			Pig는 야후에서 개발해 오픈소스 프로젝트화한 데이터 처리를 위한 고차원 언어다. 					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			Hive는 페이스북(Facebook)에서 개발한 데이터 웨어하우징 인프라로 병렬처리 기능인 Hadoop-Streaming을 쿼리 내부에 삽입해 사용할 수 있다.					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			Sawzall은 MapReduce를 추상화한 스크립트 형태의 병렬 프로그래밍 언어다. 					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			Hive는 Pig와 달리 하둡 플랫폼에서 동작하지 않는다.					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a15" class="b2 help" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a15" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">4</i>
			<span class="t2t1">
			Hive는 Pig와 달리 하둡 플랫폼에서 동작하지 않는다.			</span>
					</div>
        <br>
				<strong class="tt1">해설</strong>
		<div class="t1">
		Hive는 Pig와 마찬가지로 하둡 플랫폼 위에서 동작한다.				</div>
		
				
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				정답은 4번입니다.<br>
<br>
병렬 쿼리 시스템은 대량의 데이터를 효율적으로 처리하기 위해 개발된 시스템입니다. 이러한 시스템은 하둡과 같은 분산 컴퓨팅 플랫폼 위에서 동작하며, 사용자가 쉽게 데이터를 처리할 수 있도록 다양한 고수준의 언어와 인터페이스를 제공합니다. Pig는 야후에서 개발한 데이터 처리 언어로, 하둡의 MapReduce 위에서 동작하며, 복잡한 데이터 처리 작업을 간단하게 수행할 수 있도록 돕습니다. Hive는 페이스북에서 개발한 데이터 웨어하우징 인프라로, SQL과 유사한 HiveQL을 통해 하둡 기반의 데이터를 쉽게 쿼리할 수 있습니다. Sawzall은 MapReduce를 추상화한 스크립트 언어로, 병렬 프로그래밍을 쉽게 할 수 있도록 돕습니다.<br>
<br>
1. Pig는 야후에서 개발해 오픈소스 프로젝트화한 데이터 처리를 위한 고차원 언어다. <br>
: Pig는 야후에서 개발된 데이터 처리 언어로, 하둡의 MapReduce 위에서 동작합니다. 이는 복잡한 데이터 처리 작업을 간단하게 수행할 수 있도록 돕는 고수준의 언어입니다. 따라서 선지 1은 옳은 설명입니다.<br>
<br>
2. Hive는 페이스북(Facebook)에서 개발한 데이터 웨어하우징 인프라로 병렬처리 기능인 Hadoop-Streaming을 쿼리 내부에 삽입해 사용할 수 있다. <br>
: Hive는 페이스북에서 개발된 데이터 웨어하우징 인프라로, 하둡 플랫폼 위에서 동작하며, SQL과 유사한 HiveQL을 제공합니다. 또한, 하둡의 병렬처리 기능인 Hadoop-Streaming을 쿼리 내부에 삽입해 사용할 수 있습니다. 따라서 선지 2는 옳은 설명입니다.<br>
<br>
3. Sawzall은 MapReduce를 추상화한 스크립트 형태의 병렬 프로그래밍 언어다. <br>
: Sawzall은 MapReduce를 추상화한 스크립트 형태의 병렬 프로그래밍 언어로, 사용자가 병렬 프로그래밍을 쉽게 할 수 있도록 돕습니다. 이는 MapReduce의 복잡성을 줄이고 생산성을 높이는 데 기여합니다. 따라서 선지 3은 옳은 설명입니다.<br>
<br>
4. Hive는 Pig와 달리 하둡 플랫폼에서 동작하지 않는다. <br>
: Hive는 하둡 플랫폼 위에서 동작하며, Pig와 마찬가지로 하둡 기반의 데이터 처리 시스템입니다. 따라서 'Hive는 Pig와 달리 하둡 플랫폼에서 동작하지 않는다'는 설명은 틀렸습니다. 선지 4는 옳지 않은 설명입니다.<br>
<br>
선지 4는 Hive가 하둡 플랫폼에서 동작하지 않는다고 잘못 설명하고 있습니다. 실제로 Hive는 하둡 기반의 데이터 웨어하우징 솔루션으로, 하둡 플랫폼 위에서 동작합니다. 나머지 선지들은 각각 Pig, Hive, Sawzall의 특성을 정확히 설명하고 있습니다.<br>
<br>
따라서, 정답은 '4. Hive는 Pig와 달리 하둡 플랫폼에서 동작하지 않는다.' 입니다.<br>
			</div>
			<div class="t2">
									#병렬 쿼리 시스템									# 하둡									# Pig									# Hive									# Sawzall									# 데이터 처리							</div>
		</div>
		
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">2과목</span>
			<span class="g1">EAI(Enterprise Application Intergration)</span>
			<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">16.</span>
			<span class="tt1t1">
				다음 중 EAI(Enterprise Application Integration)에 대한 설명으로 가장 적절한 것은?							</span>
		</strong>
		<span class="tt1t1">
				    </span> 
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			EAI는 배치 프로세스 중심이다.					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			ESB는 비즈니스 서비스를 중심으로 기업 내 각종 어플리케이션간의 상호연동이 가능하도록 통합하는 솔루션을 의미한다.					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			ESB(Enterprise Service Broker)를 통해 서비스 통합을 추구하는 것이 핵심개념이다. 					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			ERP, CRM, SCM 등 각종 시스템을 통합하여 마치 하나의 애플리케이션인 것처럼 사용할 수 있게 도와준다.					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a16" class="b2 help" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a16" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">4</i>
			<span class="t2t1">
			ERP, CRM, SCM 등 각종 시스템을 통합하여 마치 하나의 애플리케이션인 것처럼 사용할 수 있게 도와준다.			</span>
					</div>
        <br>
				<strong class="tt1">해설</strong>
		<div class="t1">
		EAI는 미들웨어를 이용하여 비즈니스 로직을 중심으로 애플리케이션을 통합·연계하는 것이 핵심이다.				</div>
		
				
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				정답은 4번입니다.<br>
<br>
EAI(Enterprise Application Integration)는 기업 내 다양한 애플리케이션을 통합하여 비즈니스 프로세스를 중심으로 상호 연동할 수 있도록 하는 솔루션입니다. 이는 기업 내 또는 기업 간 이질적인 정보 시스템들의 데이터를 연계하여 동기화 및 융화된 동작을 가능하게 합니다. EAI는 실시간 또는 근접 실시간 처리를 중심으로 하며, Hub and Spoke 아키텍처를 통해 데이터를 연계합니다. 이를 통해 기업은 정보 시스템 개발 및 유지 보수 비용을 절감하고, 지속적인 발전 기반을 확보할 수 있습니다.<br>
<br>
1. EAI는 배치 프로세스 중심이다. <br>
: EAI는 실시간 또는 근접 실시간 처리를 중심으로 하는 반면, 배치 프로세스는 ETL(Extract, Transform, Load)에서 주로 사용됩니다. 배치 프로세스는 대량의 데이터를 일정 주기로 처리하는 방식으로, 실시간 처리가 필요한 EAI와는 차이가 있습니다. 따라서 EAI가 배치 프로세스 중심이라는 것은 잘못된 설명입니다.<br>
<br>
2. ESB는 비즈니스 서비스를 중심으로 기업 내 각종 어플리케이션간의 상호연동이 가능하도록 통합하는 솔루션을 의미한다. <br>
: ESB(Enterprise Service Bus)는 서비스 중심의 통합을 추구하는 미들웨어로, EAI와는 다른 개념입니다. ESB는 다양한 서비스 간의 상호 연동을 가능하게 하며, 이는 EAI의 비즈니스 프로세스 중심 통합과는 차이가 있습니다. 따라서 ESB가 EAI의 설명으로 적절하지 않습니다.<br>
<br>
3. ESB(Enterprise Service Broker)를 통해 서비스 통합을 추구하는 것이 핵심개념이다. <br>
: ESB는 Enterprise Service Bus의 약자로, 서비스 중심의 통합을 추구하는 개념입니다. EAI는 비즈니스 프로세스를 중심으로 애플리케이션을 통합하는 것이 핵심입니다. 따라서 ESB를 통한 서비스 통합은 EAI의 핵심 개념과는 다릅니다.<br>
<br>
4. ERP, CRM, SCM 등 각종 시스템을 통합하여 마치 하나의 애플리케이션인 것처럼 사용할 수 있게 도와준다. <br>
: EAI는 ERP, CRM, SCM 등 다양한 시스템을 통합하여 마치 하나의 애플리케이션처럼 사용할 수 있게 도와줍니다. 이는 EAI의 본질적인 목표로, 기업 내 다양한 애플리케이션을 유기적으로 연동하여 필요한 정보를 중앙 집중적으로 통합, 관리, 사용할 수 있는 환경을 구현하는 것입니다.<br>
<br>
EAI는 기업 내 다양한 애플리케이션을 통합하여 하나의 시스템처럼 사용할 수 있게 하는 것이 목표입니다. 선지 4는 이러한 EAI의 본질적인 목표를 정확히 설명하고 있습니다. 반면, 선지 1은 EAI의 실시간 처리 특성을 잘못 설명하고 있으며, 선지 2와 3은 ESB와 관련된 설명으로 EAI의 개념과는 다릅니다.<br>
따라서, 정답은 '4. ERP, CRM, SCM 등 각종 시스템을 통합하여 마치 하나의 애플리케이션인 것처럼 사용할 수 있게 도와준다.' 입니다.<br>
			</div>
			<div class="t2">
									#EAI									# 실시간 처리									# Hub and Spoke									# 애플리케이션 통합							</div>
		</div>
		
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">2과목</span>
			<span class="g1">분산 데이터 저장 기술</span>
			<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">17.</span>
			<span class="tt1t1">
				다음 중 HDFS에서의 파일 읽기(read) 과정으로 가장 적절한 것은?							</span>
		</strong>
		<span class="tt1t1">
				    </span> 
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			네임노드는 클라이언트에게 블록 위치에 대한 정보를 요청하고, 클라이언트는 데이터노드에 블록 위치를 질의한다. 데이터노드가 블록 위치를 반환하여 클라이언트와 네임노드에게 순차적으로 전달하면, 네임노드는 직접 데이터노드로부터 데이터를 읽어온다. 					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			클라이언트는 모든 데이터노드에 병렬로 질의를 실행하고, 요청받은 데이터를 가지고 있는 데이터노드는 클라이언트에게 직접 응답한다. 					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			클라이언트가 네임노드에게 데이터 읽기를 요청하면 네임노드는 클라이언트를 데이터노드에 연결하여 데이터를 전송받을 수 있도록 중계 역할을 한다.					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			클라이언트는 네임노드에 블록 위치를 질의하고, 네임노드는 클라이언트에게 블록의 목록과 위치를 반환한다. 그 후 클라이언트는 데이터노드로부터 직접 데이터를 읽어 들인다. 					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a17" class="b2 help" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a17" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">4</i>
			<span class="t2t1">
			클라이언트는 네임노드에 블록 위치를 질의하고, 네임노드는 클라이언트에게 블록의 목록과 위치를 반환한다. 그 후 클라이언트는 데이터노드로부터 직접 데이터를 읽어 들인다. 			</span>
					</div>
        <br>
				<strong class="tt1">해설</strong>
		<div class="t1">
		클라이언트는 네임노드에 블록 위치를 질의하고, 네임노드는 클라이언트에게 블록의 목록과 위치를 반환한다. 그 후 클라이언트는 데이터노드로부터 직접 데이터를 읽어 들인다. 				</div>
		
				
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				정답은 4번입니다.<br>
<br>
HDFS(Hadoop Distributed File System)는 대용량 데이터를 효율적으로 저장하고 처리하기 위해 설계된 분산 파일 시스템입니다. HDFS는 파일을 블록 단위로 나누어 여러 데이터노드에 분산 저장하며, 각 블록은 3중 복제되어 데이터 유실을 방지합니다. 파일 읽기 과정에서 클라이언트는 네임노드에 파일의 블록 위치를 요청하고, 네임노드는 해당 블록이 저장된 데이터노드의 위치 정보를 클라이언트에게 반환합니다. 클라이언트는 이 정보를 바탕으로 데이터노드로부터 직접 데이터를 읽어옵니다. 네임노드는 파일의 메타데이터를 관리하며, 데이터의 저장이나 전송을 직접 수행하지 않습니다.<br>
<br>
1. 네임노드는 클라이언트에게 블록 위치에 대한 정보를 요청하고, 클라이언트는 데이터노드에 블록 위치를 질의한다. 데이터노드가 블록 위치를 반환하여 클라이언트와 네임노드에게 순차적으로 전달하면, 네임노드는 직접 데이터노드로부터 데이터를 읽어온다. <br>
: 이 선지는 네임노드가 클라이언트와 데이터노드 간의 중계 역할을 한다고 잘못 설명하고 있습니다. 실제로 네임노드는 클라이언트에게 블록의 위치 정보를 제공할 뿐, 데이터 전송에는 관여하지 않습니다. 클라이언트는 네임노드로부터 받은 정보를 바탕으로 데이터노드에 직접 접근하여 데이터를 읽어옵니다.<br>
<br>
2. 클라이언트는 모든 데이터노드에 병렬로 질의를 실행하고, 요청받은 데이터를 가지고 있는 데이터노드는 클라이언트에게 직접 응답한다. <br>
: 이 선지는 클라이언트가 모든 데이터노드에 병렬로 질의한다고 설명하지만, 이는 HDFS의 동작 방식과 다릅니다. 클라이언트는 네임노드로부터 블록 위치 정보를 받은 후, 해당 블록이 저장된 특정 데이터노드에 직접 접근하여 데이터를 읽습니다. 모든 데이터노드에 병렬로 질의하는 방식은 비효율적이며, HDFS의 설계 목적에 맞지 않습니다.<br>
<br>
3. 클라이언트가 네임노드에게 데이터 읽기를 요청하면 네임노드는 클라이언트를 데이터노드에 연결하여 데이터를 전송받을 수 있도록 중계 역할을 한다. <br>
: 이 선지는 네임노드가 클라이언트와 데이터노드 간의 연결을 중계한다고 설명하지만, 이는 사실이 아닙니다. 네임노드는 클라이언트에게 블록 위치 정보를 제공하는 역할만 하며, 클라이언트는 이 정보를 바탕으로 데이터노드에 직접 연결하여 데이터를 읽습니다. 네임노드는 데이터 전송에 직접 관여하지 않습니다.<br>
<br>
4. 클라이언트는 네임노드에 블록 위치를 질의하고, 네임노드는 클라이언트에게 블록의 목록과 위치를 반환한다. 그 후 클라이언트는 데이터노드로부터 직접 데이터를 읽어 들인다. <br>
: 이 선지는 HDFS의 파일 읽기 과정을 정확히 설명하고 있습니다. 클라이언트는 네임노드에 블록 위치를 요청하고, 네임노드는 클라이언트에게 블록의 위치 정보를 반환합니다. 클라이언트는 이 정보를 사용하여 데이터노드로부터 직접 데이터를 읽어옵니다. 이는 HDFS의 설계 원리에 부합합니다.<br>
<br>
정답은 4번입니다. HDFS의 파일 읽기 과정에서 클라이언트는 네임노드에 블록 위치를 요청하고, 네임노드는 클라이언트에게 블록의 위치 정보를 반환합니다. 클라이언트는 이 정보를 바탕으로 데이터노드에 직접 접근하여 데이터를 읽습니다. 다른 선지들은 네임노드가 데이터 전송에 관여하거나, 클라이언트가 모든 데이터노드에 병렬로 질의한다고 잘못 설명하고 있습니다.<br>
<br>
따라서, 정답은 '4. 클라이언트는 네임노드에 블록 위치를 질의하고, 네임노드는 클라이언트에게 블록의 목록과 위치를 반환한다. 그 후 클라이언트는 데이터노드로부터 직접 데이터를 읽어 들인다.' 입니다.<br>
			</div>
			<div class="t2">
									#HDFS									# 네임노드									# 데이터노드									# 파일 읽기									# 블록 위치							</div>
		</div>
		
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">2과목</span>
			<span class="g1">대용량의 비정형 데이터 처리방법</span>
			<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">18.</span>
			<span class="tt1t1">
				다음 중 데이터 연동시스템인 스쿱(Sqoop)에 대한 설명으로 가장 부적절한 것은?							</span>
		</strong>
		<span class="tt1t1">
				    </span> 
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			스쿱은 데이터의 가져오기와 내보내기를 맵리듀스를 통해 처리하여 장애 허용 능력은 제공 하지 않는다.					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			관계형 DB의 데이터를 하둡 분산파일 시스템(HDFS)으로 가져오기 위한 기술이다. 					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			스쿱을 이용하면 관계형 DB의 데이터를 HBase로 옮길 수 있다.					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			스쿱은 하둡에서 제공하는 맵 인풋 포맷터를 사용하며, SQL을 통해 테이블에서 데이터를 추출한다.					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a18" class="b2 help" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a18" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">1</i>
			<span class="t2t1">
			스쿱은 데이터의 가져오기와 내보내기를 맵리듀스를 통해 처리하여 장애 허용 능력은 제공 하지 않는다.			</span>
					</div>
        <br>
				<strong class="tt1">해설</strong>
		<div class="t1">
		스쿱은 데이터의 이동을 맵리듀스를 통해 처리하여 장애 허용 능력과 병렬 처리 기능을 제공한다. 				</div>
		
				
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				정답은 1번입니다.<br>
<br>
스쿱(Sqoop)은 대량의 데이터를 관계형 데이터베이스(RDBMS)와 하둡 분산 파일 시스템(HDFS) 간에 전송하기 위한 도구입니다. 스쿱은 맵리듀스(MapReduce) 프레임워크를 활용하여 데이터 전송 작업을 수행하며, 이로 인해 장애 허용 능력과 병렬 처리 기능을 제공합니다. 스쿱은 Import 명령어를 통해 RDBMS의 데이터를 HDFS로 옮기고, Export 명령어를 통해 HDFS의 데이터를 RDBMS로 옮길 수 있습니다. 또한, 스쿱은 HBase와 같은 NoSQL 데이터베이스와도 연동이 가능하며, 하둡에서 제공하는 맵 인풋 포맷터를 사용하여 SQL을 통해 테이블에서 데이터를 추출합니다.<br>
<br>
1. 스쿱은 데이터의 가져오기와 내보내기를 맵리듀스를 통해 처리하여 장애 허용 능력은 제공 하지 않는다. <br>
: 스쿱은 맵리듀스를 통해 데이터 전송 작업을 수행하며, 이 과정에서 장애 허용 능력과 병렬 처리 기능을 제공합니다. 이는 맵리듀스의 특성상 작업이 여러 노드에 분산되어 수행되기 때문에, 특정 노드에서 장애가 발생하더라도 다른 노드에서 작업을 이어받아 수행할 수 있기 때문입니다. 따라서 스쿱이 장애 허용 능력을 제공하지 않는다는 설명은 잘못된 것입니다.<br>
<br>
2. 관계형 DB의 데이터를 하둡 분산파일 시스템(HDFS)으로 가져오기 위한 기술이다. <br>
: 스쿱은 관계형 데이터베이스의 데이터를 하둡 분산 파일 시스템(HDFS)으로 가져오기 위한 기술로, 대량의 데이터를 효율적으로 전송할 수 있도록 설계되었습니다. 이는 스쿱의 주요 기능 중 하나로, Import 명령어를 통해 구현됩니다.<br>
<br>
3. 스쿱을 이용하면 관계형 DB의 데이터를 HBase로 옮길 수 있다. <br>
: 스쿱은 관계형 데이터베이스의 데이터를 HBase와 같은 NoSQL 데이터베이스로 옮길 수 있는 기능을 제공합니다. 이는 스쿱이 다양한 데이터 저장소 간의 데이터 전송을 지원하기 때문입니다. 따라서 이 설명은 올바른 설명입니다.<br>
<br>
4. 스쿱은 하둡에서 제공하는 맵 인풋 포맷터를 사용하며, SQL을 통해 테이블에서 데이터를 추출한다. <br>
: 스쿱은 하둡에서 제공하는 맵 인풋 포맷터를 사용하여 SQL을 통해 테이블에서 데이터를 추출합니다. 이는 스쿱이 SQL 쿼리를 사용하여 데이터베이스에서 데이터를 가져오는 방식으로, 하둡의 맵리듀스 작업과 결합하여 데이터를 처리합니다. 따라서 이 설명은 정확합니다.<br>
<br>
정답은 1번입니다. 스쿱은 맵리듀스를 통해 데이터 전송을 처리하며, 이로 인해 장애 허용 능력을 제공합니다. 따라서 '장애 허용 능력을 제공하지 않는다'는 설명은 잘못된 것입니다. 나머지 선지들은 스쿱의 기능과 특성을 정확히 설명하고 있습니다.<br>
<br>
따라서, 정답은 '1. 스쿱은 데이터의 가져오기와 내보내기를 맵리듀스를 통해 처리하여 장애 허용 능력은 제공 하지 않는다.' 입니다.<br>
			</div>
			<div class="t2">
									#스쿱									# Sqoop									# 맵리듀스									# 장애 허용 능력									# 데이터 전송									# HDFS									# RDBMS									# HBase							</div>
		</div>
		
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">2과목</span>
			<span class="g1">대용량의 비정형 데이터 처리방법</span>
			<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">19.</span>
			<span class="tt1t1">
				대용량 비정형 데이터 처리와 관련된 다음의 설명 중 옳지 않은 것은?							</span>
		</strong>
		<span class="tt1t1">
				    </span> 
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			비정형 데이터 수집 시스템은 데이터를 저장소에 저장하는 여러 단계별로 혹은 인접한 단계끼리 신호를 주고받아 이벤트의 유실을 방지하는 방식으로 전송을 보장할 수 있다. 					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			하둡은 여러 대의 컴퓨터를 마치 하나의 시스템인 것처럼 묶어 분산 환경에서 빅데이터를 저장 및 처리할 수 있도록 하는 자바 기반의 오픈소스 프레임워크이다.					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			하둡과 하이브는 대용량 데이터를 배치 처리하는데 최적화 되어있다.					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			비정형 데이터의 예로는 로그 데이터, 오디오, 센서 데이터, 스프레드 시트 등이 있다.					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a19" class="b2 help" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a19" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">4</i>
			<span class="t2t1">
			비정형 데이터의 예로는 로그 데이터, 오디오, 센서 데이터, 스프레드 시트 등이 있다.			</span>
					</div>
        <br>
				<strong class="tt1">해설</strong>
		<div class="t1">
		스프레드 시트는 비정형 데이터에 해당하지 않는다.				</div>
		
				
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				정답은 4번입니다.<br>
<br>
이 문제는 대용량 비정형 데이터 처리에 대한 이해를 평가합니다. 비정형 데이터는 구조화되지 않은 데이터로, 로그 데이터, 오디오, 센서 데이터 등이 포함됩니다. 이러한 데이터를 효과적으로 처리하기 위해 다양한 기술과 시스템이 사용됩니다.<br>
<br>
1. 비정형 데이터 수집 시스템은 데이터를 저장소에 저장하는 여러 단계별로 혹은 인접한 단계끼리 신호를 주고받아 이벤트의 유실을 방지하는 방식으로 전송을 보장할 수 있다. <br>
: 비정형 데이터 수집 시스템은 데이터를 여러 단계로 전송하며, 각 단계에서 신호를 주고받아 데이터 유실을 방지합니다. 이는 데이터 전송의 신뢰성을 높이는 방법으로, 이벤트 기반의 데이터 수집에서 중요한 역할을 합니다.<br>
<br>
2. 하둡은 여러 대의 컴퓨터를 마치 하나의 시스템인 것처럼 묶어 분산 환경에서 빅데이터를 저장 및 처리할 수 있도록 하는 자바 기반의 오픈소스 프레임워크이다. <br>
: 하둡은 여러 대의 컴퓨터를 하나의 시스템처럼 묶어 대용량 데이터를 저장하고 처리할 수 있는 자바 기반의 오픈소스 프레임워크입니다. 하둡은 HDFS와 맵리듀스를 통해 데이터를 분산 저장하고 병렬 처리할 수 있습니다.<br>
<br>
3. 하둡과 하이브는 대용량 데이터를 배치 처리하는데 최적화 되어있다. <br>
: 하둡과 하이브는 대용량 데이터를 배치 처리하는 데 최적화되어 있습니다. 하둡은 데이터를 분산 저장하고 처리하는 데 중점을 두며, 하이브는 SQL과 유사한 쿼리를 통해 데이터를 분석할 수 있도록 지원합니다. 이는 대량의 데이터를 효율적으로 처리할 수 있는 환경을 제공합니다.<br>
<br>
4. 비정형 데이터의 예로는 로그 데이터, 오디오, 센서 데이터, 스프레드 시트 등이 있다. <br>
: 비정형 데이터는 구조화되지 않은 데이터로, 로그 데이터, 오디오, 비디오, 센서 데이터 등이 포함됩니다. 그러나 스프레드시트는 구조화된 데이터로, 비정형 데이터의 예로 적절하지 않습니다.<br>
<br>
선지 4는 비정형 데이터의 예로 스프레드시트를 포함하고 있는데, 스프레드시트는 구조화된 데이터로 분류됩니다. 따라서 비정형 데이터의 예로 적절하지 않습니다. 나머지 선지들은 비정형 데이터 처리와 관련된 기술적 설명으로 옳습니다.<br>
<br>
따라서, 정답은 '4. 비정형 데이터의 예로는 로그 데이터, 오디오, 센서 데이터, 스프레드 시트 등이 있다.' 입니다.<br>
			</div>
			<div class="t2">
									#비정형 데이터									# 하둡									# HDFS									# 맵리듀스									# 하이브									# 배치 처리									# 데이터 유실 방지							</div>
		</div>
		
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">2과목</span>
			<span class="g1">분산 컴퓨팅 기술</span>
			<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">20.</span>
			<span class="tt1t1">
				다음 중 Hadoop MapReduce에 관련된 설명 중 옳지 않은 것은?							</span>
		</strong>
		<span class="tt1t1">
				    </span> 
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			JobTracker는 작업을 다수의 Task로 쪼갠 후 내부적으로 스케줄링해 큐(Queue)에 저장하지만, 그 Task들에 대한 데이터 지역성에는 관여하지 않는다.					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			클라이언트에서 하둡 작업을 실행하면, 프로그램 바이너리와 입출력 디렉터리와 같은 환경 정보들이 JobTracker에게 전송된다.					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			하둡은 네임노드, 데이터노드, JobTracker, TaskTracker로 구성되어 있다.					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			TaskTracker는 Response 메시지의 내용을 분석해 프로세스를 fork해 자기에게 할당된 Task를 처리한다.					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a20" class="b2 help" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a20" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">1</i>
			<span class="t2t1">
			JobTracker는 작업을 다수의 Task로 쪼갠 후 내부적으로 스케줄링해 큐(Queue)에 저장하지만, 그 Task들에 대한 데이터 지역성에는 관여하지 않는다.			</span>
					</div>
        <br>
				<strong class="tt1">해설</strong>
		<div class="t1">
		JobTracker는 작업을 다수의 Task로 쪼갠 후 그 Task들을 어떤 TaskTracker에게 보내면 데이터 지역성을 보장할지도 감안해 내부적으로 스케줄링해 큐(Queue)에 저장한다.				</div>
		
				
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				정답은 1번입니다.<br>
<br>
Hadoop MapReduce는 대량의 데이터를 처리하기 위한 분산 컴퓨팅 모델입니다. 이 시스템은 JobTracker와 TaskTracker라는 두 가지 주요 구성 요소로 나뉩니다. JobTracker는 클러스터의 마스터 역할을 하며, 클라이언트로부터 작업을 받아 이를 여러 개의 Task로 나누고, 각 Task를 적절한 TaskTracker에 할당합니다. 이 과정에서 데이터 지역성을 고려하여 네트워크 부하를 줄이고 성능을 최적화합니다. TaskTracker는 각 노드에서 실제 작업을 수행하는 워커로, JobTracker로부터 할당받은 Task를 실행하고 그 결과를 반환합니다. 이러한 구조는 데이터의 병렬 처리와 장애 허용성을 높여 대규모 데이터 처리에 적합합니다.<br>
<br>
1. JobTracker는 작업을 다수의 Task로 쪼갠 후 내부적으로 스케줄링해 큐(Queue)에 저장하지만, 그 Task들에 대한 데이터 지역성에는 관여하지 않는다. <br>
: JobTracker는 클러스터의 마스터로서 작업을 여러 Task로 나누고, 각 Task를 적절한 TaskTracker에 할당합니다. 이 과정에서 데이터 지역성을 고려하여 네트워크 부하를 줄이고 성능을 최적화합니다. 따라서, 데이터 지역성에 관여하지 않는다는 설명은 잘못된 것입니다.<br>
<br>
2. 클라이언트에서 하둡 작업을 실행하면, 프로그램 바이너리와 입출력 디렉터리와 같은 환경 정보들이 JobTracker에게 전송된다. <br>
: 클라이언트가 하둡 작업을 실행하면, 프로그램 바이너리와 입출력 디렉터리 등의 환경 정보가 JobTracker에 전송됩니다. 이는 JobTracker가 작업을 관리하고 스케줄링하는 데 필요한 정보를 제공하기 위한 절차입니다. 따라서 이 설명은 정확합니다.<br>
<br>
3. 하둡은 네임노드, 데이터노드, JobTracker, TaskTracker로 구성되어 있다. <br>
: 하둡은 네임노드, 데이터노드, JobTracker, TaskTracker로 구성됩니다. 네임노드는 파일 시스템의 메타데이터를 관리하고, 데이터노드는 실제 데이터를 저장합니다. JobTracker와 TaskTracker는 MapReduce 작업을 관리하고 실행합니다. 이 설명은 정확합니다.<br>
<br>
4. TaskTracker는 Response 메시지의 내용을 분석해 프로세스를 fork해 자기에게 할당된 Task를 처리한다. <br>
: TaskTracker는 JobTracker로부터 할당받은 Task를 실행하는 워커입니다. TaskTracker는 할당된 Task를 처리하기 위해 프로세스를 생성하고, 그 결과를 JobTracker에 보고합니다. 따라서 이 설명은 정확합니다.<br>
<br>
선지 1은 JobTracker가 데이터 지역성을 고려하지 않는다고 잘못 설명하고 있습니다. 실제로 JobTracker는 데이터 지역성을 고려하여 Task를 할당합니다. 나머지 선지들은 각각의 역할과 기능을 정확히 설명하고 있습니다.<br>
<br>
따라서, 정답은 '1. JobTracker는 작업을 다수의 Task로 쪼갠 후 내부적으로 스케줄링해 큐(Queue)에 저장하지만, 그 Task들에 대한 데이터 지역성에는 관여하지 않는다.' 입니다.<br>
			</div>
			<div class="t2">
									#Hadoop									# MapReduce									# JobTracker									# TaskTracker									# 데이터 지역성									# 분산 컴퓨팅							</div>
		</div>
		
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">3과목</span>
			<span class="g1">분석 방법론</span>
			<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">21.</span>
			<span class="tt1t1">
				빅데이터 분석 방법론에 대한 설명으로 옳지 않은 것은?							</span>
		</strong>
		<span class="tt1t1">
				    </span> 
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			빅데이터를 분석하기 위한 방법론은 3계층으로 구성된 계층적 프로세스 모델이다. 					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			각 단계는 기준선이 없어 버전 관리 등을 통한 통제만으로 이루어진다. 					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			각 단계는 여러 개의 태스크로 구성된다. 					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			마지막 계층은 스텝(Step)으로 입력자료, 처리 및 도구, 출력자로 구성된 단위 프로세스이다.					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a21" class="b2 help" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a21" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">2</i>
			<span class="t2t1">
			각 단계는 기준선이 없어 버전 관리 등을 통한 통제만으로 이루어진다. 			</span>
					</div>
        <br>
				<strong class="tt1">해설</strong>
		<div class="t1">
		각 단계는 기준선으로 설정되어 관리되어야 하며 버전관리 등을 통해 통제가 이루어진다. 				</div>
		
				
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				정답은 2번입니다.<br>
<br>
빅데이터 분석 방법론은 데이터를 효과적으로 분석하기 위한 체계적인 접근 방식을 제공합니다. 이 방법론은 일반적으로 여러 계층으로 구성되어 있으며, 각 계층은 특정한 분석 목표를 달성하기 위한 단계와 태스크로 나뉩니다. 이러한 구조는 분석 과정의 복잡성을 관리하고, 일관성을 유지하며, 효율성을 높이는 데 기여합니다.<br>
<br>
1. 빅데이터를 분석하기 위한 방법론은 3계층으로 구성된 계층적 프로세스 모델이다.<br>
: 빅데이터 분석 방법론은 일반적으로 여러 계층으로 구성된 구조를 가지고 있습니다. 이러한 계층적 구조는 분석 과정의 복잡성을 관리하고, 각 계층이 특정한 분석 목표를 달성하기 위한 역할을 수행하도록 설계되어 있습니다.<br>
<br>
2. 각 단계는 기준선이 없어 버전 관리 등을 통한 통제만으로 이루어진다.<br>
: 빅데이터 분석 방법론의 각 단계는 일반적으로 명확한 기준선이 설정되어 있으며, 이를 통해 버전 관리와 통제가 이루어집니다. 기준선이 없다는 것은 잘못된 설명입니다.<br>
<br>
3. 각 단계는 여러 개의 태스크로 구성된다.<br>
: 각 단계는 여러 개의 태스크로 구성되어 있으며, 이러한 태스크는 특정한 분석 목표를 달성하기 위한 구체적인 작업을 포함합니다. 이는 분석 과정의 체계적이고 단계적인 접근을 가능하게 합니다.<br>
<br>
4. 마지막 계층은 스텝(Step)으로 입력자료, 처리 및 도구, 출력자로 구성된 단위 프로세스이다.<br>
: 마지막 계층은 일반적으로 스텝(Step)으로 구성되며, 각 스텝은 입력자료, 처리 및 도구, 출력자료로 구성된 단위 프로세스를 포함합니다. 이는 분석 과정의 세부적인 실행 단계를 나타냅니다.<br>
<br>
<br>
두 번째 선택지는 빅데이터 분석 방법론의 각 단계가 기준선 없이 버전 관리만으로 통제된다고 설명하고 있습니다. 그러나 실제로는 각 단계에 명확한 기준선이 설정되어 있어야 하며, 이를 통해 체계적인 관리와 통제가 가능합니다. 따라서 이 설명은 잘못된 것입니다. 다른 선택지들은 빅데이터 분석 방법론의 구조와 구성 요소를 올바르게 설명하고 있습니다.<br>
<br>
따라서, 정답은 '2. 각 단계는 기준선이 없어 버전 관리 등을 통한 통제만으로 이루어진다.' 입니다.<br>
			</div>
			<div class="t2">
									#빅데이터 분석									# 계층적 프로세스									# 기준선									# 태스크									# 스텝							</div>
		</div>
		
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">3과목</span>
			<span class="g1">분석 방법론</span>
			<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">22.</span>
			<span class="tt1t1">
				빅데이터 분석 방법론에서 데이터 분석 단계는 분석용 데이터를 준비해서 텍스트 분석과 탐색적 분석 그리고 모델링 과정을 수행하게 된다. 이때, 모델링 과정에서 수행하는 업무로 적절하지 않은 것은 무엇인가?							</span>
		</strong>
		<span class="tt1t1">
				    </span> 
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			비정형 데이터 분석결과를 통합적으로 활용하여 프로젝트 목적에 맞는 통합 모델링을 수행한다. 					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			분석 데이터셋을 훈련용 데이터와 모델 검증력을 위한 테스트 데이터로 분할한다. 					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			데이터의 기초 통계량(평균, 분석, 표준편차, 최대값, 최소값 등)을 산출한다. 					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			훈련용 데이터를 활용하여 분류, 예측, 군집 등의 모델을 만들고 이를 평가, 검증한다.					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a22" class="b2 help" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a22" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">3</i>
			<span class="t2t1">
			데이터의 기초 통계량(평균, 분석, 표준편차, 최대값, 최소값 등)을 산출한다. 			</span>
					</div>
        <br>
				<strong class="tt1">해설</strong>
		<div class="t1">
		모델링 과정에서는 데이터를 분할하고 모델링을 수행하고 모델 적용 및 운영방안을 작성하고 수립한다. 데이터의 기초통계량을 산출하는 것은 탐색적 분석 단계에서 수행된다. 				</div>
		
				
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				정답은 3번입니다.<br>
<br>
빅데이터 분석 방법론에서 데이터 분석 단계는 크게 데이터 준비, 탐색적 분석, 모델링, 그리고 평가로 나눌 수 있습니다. 모델링 단계에서는 주로 데이터를 훈련용과 테스트용으로 분할하여 다양한 모델을 생성하고, 이를 평가 및 검증하는 과정을 포함합니다. 이 단계에서는 데이터의 기초 통계량을 산출하는 것이 아니라, 모델의 성능을 최적화하고 과적합을 방지하기 위한 작업이 주로 이루어집니다.<br>
<br>
1. 비정형 데이터 분석결과를 통합적으로 활용하여 프로젝트 목적에 맞는 통합 모델링을 수행한다. <br>
: 모델링 과정에서는 비정형 데이터 분석 결과를 포함하여 다양한 데이터를 통합하여 프로젝트 목적에 맞는 모델을 구축하는 것이 중요합니다. 이는 모델의 정확성을 높이고, 다양한 데이터 소스를 활용하여 보다 포괄적인 분석을 가능하게 합니다.<br>
<br>
2. 분석 데이터셋을 훈련용 데이터와 모델 검증력을 위한 테스트 데이터로 분할한다. <br>
: 모델링 단계에서 데이터셋을 훈련용과 테스트용으로 분할하는 것은 필수적인 과정입니다. 이는 모델의 성능을 검증하고, 과적합을 방지하기 위해 필요합니다. 훈련용 데이터는 모델을 학습시키는 데 사용되고, 테스트 데이터는 모델의 예측력을 평가하는 데 사용됩니다.<br>
<br>
3. 데이터의 기초 통계량(평균, 분석, 표준편차, 최대값, 최소값 등)을 산출한다. <br>
: 데이터의 기초 통계량을 산출하는 것은 탐색적 분석 단계에서 수행됩니다. 이 단계에서는 데이터의 분포, 평균, 표준편차 등을 분석하여 데이터의 특성을 이해하고, 이후 모델링에 필요한 인사이트를 얻습니다. 따라서 모델링 과정에서 수행하는 업무로는 적절하지 않습니다.<br>
<br>
4. 훈련용 데이터를 활용하여 분류, 예측, 군집 등의 모델을 만들고 이를 평가, 검증한다. <br>
: 훈련용 데이터를 활용하여 분류, 예측, 군집 등의 모델을 만들고 이를 평가, 검증하는 것은 모델링 과정의 핵심입니다. 이 과정에서 다양한 알고리즘을 적용하여 최적의 모델을 찾고, 이를 통해 예측력을 높이는 것이 목표입니다.<br>
<br>
모델링 과정에서는 주로 데이터를 분할하고, 다양한 모델을 생성하여 평가하는 작업이 이루어집니다. 데이터의 기초 통계량을 산출하는 것은 탐색적 분석 단계에서 수행되는 작업으로, 모델링 과정의 업무와는 직접적인 관련이 없습니다. 따라서 선지 3은 모델링 과정에서 수행하는 업무로 적절하지 않습니다.<br>
따라서, 정답은 '3. 데이터의 기초 통계량(평균, 분석, 표준편차, 최대값, 최소값 등)을 산출한다.' 입니다.<br>
			</div>
			<div class="t2">
									#모델링									# 데이터 분할									# 훈련용 데이터									# 테스트 데이터									# 기초 통계량									# 탐색적 분석							</div>
		</div>
		
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">3과목</span>
			<span class="g1">분석 과제 발굴</span>
			<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">23.</span>
			<span class="tt1t1">
				거시적 관점의 메가트렌드에서 현재 조직 및 해당 산업에 폭 넓게 영향을 미치는 요인 STEEP가 아닌 것은?							</span>
		</strong>
		<span class="tt1t1">
				    </span> 
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			사회영역(Social)					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			기술영역(Technological)					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			경제영역(Economic)					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			공공영역(Public)					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a23" class="b2 help" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a23" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">4</i>
			<span class="t2t1">
			공공영역(Public)			</span>
					</div>
        <br>
				<strong class="tt1">해설</strong>
		<div class="t1">
		STEEP은 Social(사회영역), Technological(기술영역), Economic(경제영역), Environment(환경영역), Political(정치영역)으로 구성된다.				</div>
		
				
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				정답은 4번입니다.<br>
<br>
STEEP 분석은 사회(Social), 기술(Technological), 경제(Economic), 환경(Environmental), 정치(Political) 요인을 고려하여 조직 및 산업에 영향을 미치는 외부 요인을 분석하는 방법입니다. 이 분석은 기업이 외부 환경 변화에 적응하고 전략을 수립하는 데 도움을 줍니다.<br>
<br>
1. 사회영역(Social)<br>
: 사회적 요인은 인구 통계, 문화적 변화, 사회적 가치와 같은 요소를 포함하며, 조직의 운영과 전략에 큰 영향을 미칩니다. 예를 들어, 인구 고령화는 특정 산업에 새로운 기회를 제공할 수 있습니다.<br>
<br>
2. 기술영역(Technological)<br>
: 기술적 요인은 기술 발전과 혁신을 포함하며, 이는 제품 개발, 생산성 향상, 시장 경쟁력 강화에 중요한 역할을 합니다. 기술의 빠른 발전은 기업이 지속적으로 적응해야 하는 도전 과제를 제공합니다.<br>
<br>
3. 경제영역(Economic)<br>
: 경제적 요인은 경제 성장률, 인플레이션, 실업률 등과 같은 경제 환경을 포함합니다. 이러한 요인은 기업의 수익성, 비용 구조, 투자 결정에 직접적인 영향을 미칩니다.<br>
<br>
4. 공공영역(Public)<br>
: 공공 영역은 일반적으로 STEEP 분석의 범주에 포함되지 않습니다. 대신, 정치적 요인이 포함되며, 이는 정부 정책, 법률, 규제와 같은 요소를 다룹니다. 공공 영역은 특정한 맥락에서 중요할 수 있지만, STEEP의 전통적인 구성 요소는 아닙니다.<br>
<br>
<br>
STEEP 분석의 전통적인 구성 요소는 사회, 기술, 경제, 환경, 정치입니다. 공공 영역은 이 분석의 범주에 포함되지 않으며, 따라서 정답은 4번입니다. 다른 선택지들은 모두 STEEP 분석의 구성 요소에 해당합니다.<br>
<br>
따라서, 정답은 '4. 공공영역(Public)' 입니다.<br>
			</div>
			<div class="t2">
									#STEEP									# 사회적 요인									# 기술적 요인									# 경제적 요인									# 정치적 요인							</div>
		</div>
		
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">3과목</span>
			<span class="g1">분석 과제 발굴</span>
			<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">24.</span>
			<span class="tt1t1">
				빅데이터 분석환경에서 프로토타이핑의 필요성이 아닌 것은?							</span>
		</strong>
		<span class="tt1t1">
				    </span> 
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			문제에 대한 인식수준					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			필요 데이터 존재 여부의 불확실성					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			데이터 사용 목적의 가변성 					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			분석가의 한계					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a24" class="b2 help" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a24" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">4</i>
			<span class="t2t1">
			분석가의 한계			</span>
					</div>
        <br>
				<strong class="tt1">해설</strong>
		<div class="t1">
		빅데이터 분석환경에서 프로토타이핑의 필요성은 문제에 대한 인식수준, 필요 데이터 존재 여부의 불확실성, 데이터 사용 목적의 가변성에 따라 존재한다.				</div>
		
				
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				정답은 1번입니다.<br>
<br>
빅데이터 분석환경에서 프로토타이핑은 불확실한 요소를 탐색하고, 데이터 분석의 방향성을 설정하는 데 중요한 역할을 합니다. 프로토타이핑은 빠른 피드백을 통해 문제를 명확히 하고, 데이터의 가용성과 분석 목적의 변화를 수용할 수 있는 유연성을 제공합니다.<br>
<br>
1. 문제에 대한 인식수준<br>
: 빅데이터 분석에서 문제에 대한 인식수준은 프로토타이핑의 필요성과 직접적인 관련이 없습니다. 이는 분석의 초기 단계에서 문제를 정의하는 데 더 관련이 있습니다.<br>
<br>
2. 필요 데이터 존재 여부의 불확실성<br>
: 필요 데이터의 존재 여부가 불확실할 때, 프로토타이핑은 데이터를 탐색하고 수집하는 과정에서 유용합니다.<br>
<br>
3. 데이터 사용 목적의 가변성<br>
: 데이터 사용 목적이 가변적일 때, 프로토타이핑은 다양한 목적에 맞춰 분석 방향을 조정할 수 있는 유연성을 제공합니다.<br>
<br>
4. 분석가의 한계<br>
: 분석가의 한계는 프로토타이핑의 필요성과 직접적인 관련이 없습니다. 이는 분석가의 기술적 능력이나 경험과 관련이 있습니다.<br>
<br>
<br>
문제에 대한 인식수준은 프로토타이핑의 필요성과 직접적인 관련이 없습니다. 프로토타이핑은 주로 데이터의 불확실성이나 목적의 가변성에 대응하기 위한 방법입니다. 따라서, 다른 선택지들은 프로토타이핑의 필요성을 설명하는 반면, 1번 선택지는 그렇지 않습니다.<br>
<br>
따라서, 정답은 '1. 문제에 대한 인식수준' 입니다.<br>
			</div>
			<div class="t2">
									#프로토타이핑									# 불확실성									# 데이터 가용성									# 분석 목적							</div>
		</div>
		
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">3과목</span>
			<span class="g1">분석 프로젝트 관리 방안</span>
			<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">25.</span>
			<span class="tt1t1">
				분석 프로젝트의 특성으로 옳은 것은?							</span>
		</strong>
		<span class="tt1t1">
				    </span> 
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			분석과제를 구현하기 위해서 개별적으로 분석업무를 수행하는 것이 중요하다. 					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			분석가는 영역별로 조율하는 조정자이며 프로젝트의 관리자이기도하다. 					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			프로젝트는 도출된 결과가 재해석을 거치지 않고 수행되는 경우가 대부분이다. 					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			분석과제 정의서와 비슷하지 않게 프로젝트를 시작해야한다.					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a25" class="b2 help" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a25" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">2</i>
			<span class="t2t1">
			분석가는 영역별로 조율하는 조정자이며 프로젝트의 관리자이기도하다. 			</span>
					</div>
        <br>
				<strong class="tt1">해설</strong>
		<div class="t1">
		분석가는 데이터 원천을 다루는 데이터 영역과 결과를 활용할 비즈니스 영역의 중간에서 분석 모델을 통한 조율을 수행하는 조정자이며 해당 프로젝트의 관리까지 겸임하게 되는 경우가 대부분이다.				</div>
		
				
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				정답은 2번입니다.<br>
<br>
분석 프로젝트는 단순히 데이터를 분석하는 것에 그치지 않고, 분석 결과를 통해 비즈니스 목표를 달성하는 것을 목적으로 합니다. 이를 위해 분석가는 데이터 영역과 비즈니스 영역을 조율하는 조정자 역할을 수행하며, 프로젝트 관리자로서의 역할도 중요합니다. 분석 프로젝트는 다양한 데이터와 복잡한 분석 기법을 다루기 때문에, 범위, 일정, 품질, 리스크, 의사소통 등 여러 영역에서의 관리가 필요합니다. 또한, 분석과제는 사전에 명확히 정의되고, 이를 기반으로 프로젝트가 체계적으로 수행되어야 합니다.<br>
<br>
1. 분석과제를 구현하기 위해서 개별적으로 분석업무를 수행하는 것이 중요하다. <br>
: 분석 프로젝트에서는 개별적인 분석 업무 수행도 중요하지만, 전체 프로젝트의 관점에서 관리가 필요합니다. 분석가는 프로젝트의 전반적인 과정을 고려하여, 분석과제를 잘 구현하고 원하는 결과를 얻을 수 있도록 해야 합니다. 따라서 개별적으로 분석 업무를 수행하는 것만으로는 충분하지 않습니다.<br>
<br>
2. 분석가는 영역별로 조율하는 조정자이며 프로젝트의 관리자이기도하다. <br>
: 분석가는 데이터 영역과 비즈니스 영역을 조율하는 조정자 역할을 하며, 프로젝트의 관리자 역할도 수행합니다. 이는 분석가가 데이터의 원천과 비즈니스의 요구를 이해하고, 분석의 정확도와 결과의 가치를 전달하는 데 중요한 역할을 하기 때문입니다. 따라서 이 선지는 분석 프로젝트의 특성을 잘 설명하고 있습니다.<br>
<br>
3. 프로젝트는 도출된 결과가 재해석을 거치지 않고 수행되는 경우가 대부분이다. <br>
: 프로젝트는 도출된 결과가 재해석 없이 수행되는 경우가 대부분이라는 것은 잘못된 설명입니다. 분석 프로젝트에서는 도출된 결과를 지속적으로 모니터링하고, 필요에 따라 개선하는 절차가 중요합니다. 따라서 결과가 재해석 없이 그대로 수행되는 경우는 드뭅니다.<br>
<br>
4. 분석과제 정의서와 비슷하지 않게 프로젝트를 시작해야한다. <br>
: 분석과제 정의서와 비슷하지 않게 프로젝트를 시작해야 한다는 것은 잘못된 설명입니다. 분석 프로젝트는 사전에 명확히 정의된 분석과제를 기반으로 체계적으로 수행되어야 합니다. 따라서 분석과제 정의서와 일치하는 방향으로 프로젝트를 시작하는 것이 중요합니다.<br>
<br>
정답은 2번입니다. 분석가는 데이터와 비즈니스 영역을 조율하는 조정자 역할을 하며, 프로젝트의 관리자 역할도 수행합니다. 이는 분석 프로젝트의 특성을 잘 설명하고 있습니다. 1번은 개별적인 분석 업무 수행만을 강조하여 전체적인 프로젝트 관리의 중요성을 간과하고 있습니다. 3번은 결과가 재해석 없이 수행된다는 잘못된 설명을 하고 있으며, 4번은 분석과제 정의서와 일치하지 않게 프로젝트를 시작해야 한다는 잘못된 설명을 하고 있습니다.<br>
따라서, 정답은 '2. 분석가는 영역별로 조율하는 조정자이며 프로젝트의 관리자이기도하다.' 입니다.<br>
			</div>
			<div class="t2">
									#분석 프로젝트									# 조정자 역할									# 프로젝트 관리									# 데이터 영역									# 비즈니스 영역							</div>
		</div>
		
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">3과목</span>
			<span class="g1">분석 거버넌스 체계 수립</span>
			<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">26.</span>
			<span class="tt1t1">
				분석 성숙도 모델 중 빅데이터 관리를 위한 환경이 갖추어지고, 전사 차원에서 분석을 관리하고 공유하며, 이를 위해 분석 전문 조직을 운영하는 수준의 성숙단계는?							</span>
		</strong>
		<span class="tt1t1">
				    </span> 
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			도입 단계					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			활용 단계					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			확산 단계					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			최적화 단계					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a26" class="b2 help" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a26" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">3</i>
			<span class="t2t1">
			확산 단계			</span>
					</div>
        <br>
				<strong class="tt1">해설</strong>
		<div class="t1">
		분석 성숙도는 비즈니스 부문, 조직·역량 부분, IT부문 등 3개 부문 등 3개 부문을 대상으로 성숙도 수준에 따라 도입단계, 활용단계, 확산단계, 최적화 단계로 구분해 살펴 볼 수 있다. 도입단계는 분석에 필요한 환경과 시스템을 갖추기 시작하는 단계로 일부 부서 중심으로 실적 분석 및 통계업무 위주의 분석이 수행된다. 활용단계는 분석 결과를 실제 업무에 적용하는 단계로 분석을 전문 담당부서에서 수행하며 미래 결과예측 및 시뮬레이션 분석을 수행하는 단계이다. 확산단계는 빅데이터 관리를 위한 환경이 갖추어 지고, 전사 모든 부서에서 분석을 수행하되, 전사차원에서 분석을 관리하고 공유하며, 이를 위한 분석 전문 조직을 운영하는 수준의 단계이다. 최적화 단계는 전사내 분석 협업 환경이 갖추어 지고, 실시간 분석이 가능하여 분석을 업무 프로세스에 내재화  하는 등 분석을 진화시켜 혁신 및 성과 향상에 기여하는 단계이다.				</div>
		
				
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				정답은 3번입니다.<br>
<br>
분석 성숙도 모델은 기업이 데이터 분석을 얼마나 잘 활용하고 있는지를 평가하는 도구입니다. 이 모델은 도입 단계, 활용 단계, 확산 단계, 최적화 단계로 나뉘며, 각 단계는 기업의 분석 역량과 데이터 활용 수준을 나타냅니다. 도입 단계는 분석 환경과 시스템을 구축하기 시작하는 초기 단계입니다. 활용 단계에서는 분석 결과를 실제 업무에 적용하여 미래 예측과 시뮬레이션을 수행합니다. 확산 단계는 빅데이터 관리 환경이 갖추어지고, 전사적으로 분석을 관리하고 공유하며, 이를 위해 분석 전문 조직을 운영하는 단계입니다. 최적화 단계는 분석이 실시간으로 이루어지고, 업무 프로세스에 내재화되어 혁신과 성과 향상에 기여하는 단계입니다.<br>
<br>
1. 도입 단계 <br>
: 도입 단계는 분석을 시작하기 위한 환경과 시스템을 구축하는 초기 단계입니다. 이 단계에서는 일부 부서 중심으로 실적 분석과 통계 업무 위주의 분석이 수행됩니다. 따라서 전사 차원에서 분석을 관리하고 공유하는 수준에는 이르지 못합니다.<br>
<br>
2. 활용 단계 <br>
: 활용 단계는 분석 결과를 실제 업무에 적용하는 단계로, 분석을 전문 담당 부서에서 수행하며 미래 결과 예측 및 시뮬레이션 분석을 수행합니다. 그러나 이 단계는 여전히 전사 차원에서의 관리와 공유보다는 특정 부서 중심의 활용에 초점이 맞춰져 있습니다.<br>
<br>
3. 확산 단계 <br>
: 확산 단계는 빅데이터 관리를 위한 환경이 갖추어지고, 전사 모든 부서에서 분석을 수행하며, 전사 차원에서 분석을 관리하고 공유하는 단계입니다. 이 단계에서는 분석 전문 조직을 운영하여 전사적인 분석 역량을 강화합니다.<br>
<br>
4. 최적화 단계 <br>
: 최적화 단계는 분석이 전사 내에서 실시간으로 이루어지고, 업무 프로세스에 내재화되어 혁신과 성과 향상에 기여하는 단계입니다. 이 단계는 이미 전사 차원에서의 관리와 공유를 넘어 분석을 통해 지속적인 혁신을 추구합니다.<br>
<br>
문제에서 묻는 성숙 단계는 '빅데이터 관리를 위한 환경이 갖추어지고, 전사 차원에서 분석을 관리하고 공유하며, 이를 위해 분석 전문 조직을 운영하는 수준'입니다. 이는 확산 단계의 정의와 일치합니다. 도입 단계는 초기 환경 구축, 활용 단계는 분석 결과의 업무 적용, 최적화 단계는 분석의 실시간화와 혁신 기여에 중점을 두고 있어 문제의 조건과 맞지 않습니다.<br>
따라서, 정답은 '3. 확산 단계' 입니다.<br>
			</div>
			<div class="t2">
									#분석 성숙도									# 도입 단계									# 활용 단계									# 확산 단계									# 최적화 단계									# 빅데이터 관리									# 전사 차원									# 분석 전문 조직							</div>
		</div>
		
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">3과목</span>
			<span class="g1">분석 거버넌스 체계 수립</span>
			<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">27.</span>
			<span class="tt1t1">
				다음 중 분석 프로젝트 관리에 대한 설명으로 가장 부적절한 것은?							</span>
		</strong>
		<span class="tt1t1">
				    </span> 
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			데이터 분석 모델의 품질을 평가하기 위해서 SPICE를 활용할 수 있다. 					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			분석 프로젝트 관리는 KSA ISO 215002013을 가이드로 활용할 수 있다.					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			분석 프로젝트의 일정계획 수립시 데이터 수집에 대한 철저한 통제와 관리가 필요하다. 					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			분석 프로젝트의 최종 산출물이 보고서 또는 시스템인지에 따라 프로젝트 관리에 차이가 있다.					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a27" class="b2 help" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a27" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">3</i>
			<span class="t2t1">
			분석 프로젝트의 일정계획 수립시 데이터 수집에 대한 철저한 통제와 관리가 필요하다. 			</span>
					</div>
        <br>
				<strong class="tt1">해설</strong>
		<div class="t1">
		분석 프로젝트 관리에서 일정계획 수립시 데이터 수집에 대한 철저한 통제와 관리보다 분석 범위가 빈번하게 변경되므로 시간이 소요될 수도 있다. 따라서 Time Boxing 기법과 같은 방법으로 일정관리를 진행하는 것이 필요하다.				</div>
		
				
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				정답은 3번입니다.<br>
<br>
분석 프로젝트 관리는 프로젝트의 목표 달성을 위해 다양한 방법론과 표준을 활용하여 체계적으로 진행됩니다. 각 단계에서의 관리와 통제는 프로젝트의 성공적인 완료를 위해 필수적입니다.<br>
<br>
1. 데이터 분석 모델의 품질을 평가하기 위해서 SPICE를 활용할 수 있다.<br>
: SPICE는 소프트웨어 프로세스 개선 및 능력 평가를 위한 국제 표준으로, 데이터 분석 모델의 품질을 평가하는 데 활용될 수 있습니다. 이는 프로세스의 성숙도를 평가하고 개선하는 데 도움을 줍니다.<br>
<br>
2. 분석 프로젝트 관리는 KSA ISO 215002013을 가이드로 활용할 수 있다.<br>
: KSA ISO 21500은 프로젝트 관리에 대한 국제 표준으로, 프로젝트의 전반적인 관리에 대한 가이드를 제공합니다. 이는 분석 프로젝트 관리에도 적용될 수 있습니다.<br>
<br>
3. 분석 프로젝트의 일정계획 수립시 데이터 수집에 대한 철저한 통제와 관리가 필요하다.<br>
: 데이터 수집은 분석 프로젝트의 중요한 부분이지만, 일정 계획 수립 시 지나치게 엄격한 통제와 관리가 오히려 유연성을 저해할 수 있습니다. 따라서 적절한 수준의 관리가 필요합니다.<br>
<br>
4. 분석 프로젝트의 최종 산출물이 보고서 또는 시스템인지에 따라 프로젝트 관리에 차이가 있다.<br>
: 프로젝트의 최종 산출물이 보고서인지 시스템인지에 따라 관리 방식이 달라질 수 있습니다. 이는 프로젝트의 목표와 결과물의 특성에 따라 관리 전략이 달라지기 때문입니다.<br>
<br>
<br>
데이터 수집에 대한 지나친 통제와 관리는 프로젝트의 유연성을 저해할 수 있으며, 이는 프로젝트 관리의 일반적인 원칙에 부합하지 않습니다. 다른 선택지들은 각각의 설명에 맞는 표준과 방법론을 적절히 활용하고 있습니다.<br>
<br>
따라서, 정답은 '3. 분석 프로젝트의 일정계획 수립시 데이터 수집에 대한 철저한 통제와 관리가 필요하다.' 입니다.<br>
			</div>
			<div class="t2">
									#프로젝트 관리									# SPICE									# ISO 21500									# 데이터 수집							</div>
		</div>
		
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">3과목</span>
			<span class="g1">분석 프로젝트 관리 방안</span>
			<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">28.</span>
			<span class="tt1t1">
				분석 조직을 갖추는 과정에서 조직 구성원의 역량을 고르게 갖추는 것이 무엇보다 중요하다. 이로 인해 분석 조직에서 필요한 인력 중 반드시 필요한 인력이 아닌 것을 고르시오.							</span>
		</strong>
		<span class="tt1t1">
				    </span> 
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			해당 비즈니스를 잘 이해하고 분석 요소를 찾고 협의할 수 있는 비즈니스 인력 					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			분석에 필요한 IT기술 동향을 파악하고, 필요한 기술 아키텍처를 수립할 수 있는 IT 기술 인력 					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			고급 통계 분석 기법을 이해하고 다양한 예측 모델링을 설계/검증 할 수 있는 분석 전문 인력 					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			분석 조직에게 다양한 분석 기법에 대한 심도있는 교육을 할 수 있는 교육담당 인력					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a28" class="b2 help" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a28" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">4</i>
			<span class="t2t1">
			분석 조직에게 다양한 분석 기법에 대한 심도있는 교육을 할 수 있는 교육담당 인력			</span>
					</div>
        <br>
				<strong class="tt1">해설</strong>
		<div class="t1">
		분석 조직을 갖추기 위해 반드시 필요한 인력은 비즈니스 인력, IT기술 인력, 분석전문 인력이다. 그 외에 변화관리 인력과 교육담당 인력은 겸직이 가능한 인력들이다.				</div>
		
				
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				정답은 4번입니다.<br>
<br>
분석 조직을 구성할 때는 다양한 전문 역량을 가진 인재들이 필요합니다. 비즈니스 인력은 비즈니스의 이해와 분석 요소를 찾는 역할을 하며, IT 기술 인력은 최신 기술 동향을 파악하고 기술 아키텍처를 수립합니다. 분석 전문 인력은 고급 통계 분석 기법과 예측 모델링을 다루며, 변화관리 인력은 조직 내 분석 문화 확산을 담당합니다. 교육담당 인력은 조직 구성원들에게 분석 기법을 교육합니다. 이러한 인력들은 분석 조직의 경쟁력을 극대화하는 데 필수적입니다.<br>
<br>
1. 해당 비즈니스를 잘 이해하고 분석 요소를 찾고 협의할 수 있는 비즈니스 인력 <br>
: 비즈니스 인력은 분석 조직에서 필수적인 역할을 합니다. 이들은 비즈니스의 전반적인 이해를 바탕으로 분석 요소를 식별하고, 이를 통해 조직의 목표를 달성하는 데 기여합니다. 비즈니스 인력이 없다면, 분석 결과를 실제 비즈니스에 적용하는 데 어려움이 있을 수 있습니다.<br>
<br>
2. 분석에 필요한 IT기술 동향을 파악하고, 필요한 기술 아키텍처를 수립할 수 있는 IT 기술 인력 <br>
: IT 기술 인력은 분석에 필요한 기술적 기반을 제공합니다. 이들은 최신 IT 기술 동향을 파악하고, 분석에 필요한 기술 아키텍처를 설계합니다. 이러한 기술적 지원이 없다면, 분석 작업의 효율성과 정확성이 떨어질 수 있습니다.<br>
<br>
3. 고급 통계 분석 기법을 이해하고 다양한 예측 모델링을 설계/검증 할 수 있는 분석 전문 인력 <br>
: 분석 전문 인력은 고급 통계 분석 기법과 예측 모델링을 통해 데이터를 해석하고, 의미 있는 인사이트를 도출합니다. 이들의 전문성은 분석의 정확도와 신뢰성을 높이는 데 필수적입니다.<br>
<br>
4. 분석 조직에게 다양한 분석 기법에 대한 심도있는 교육을 할 수 있는 교육담당 인력 <br>
: 교육담당 인력은 분석 조직 내에서 다양한 분석 기법에 대한 교육을 담당합니다. 그러나 이 역할은 다른 인력들이 겸직할 수 있는 부분으로, 필수적인 인력은 아닙니다. 따라서 분석 조직의 필수 인력으로 보기 어렵습니다.<br>
<br>
분석 조직에서 비즈니스 인력, IT 기술 인력, 분석 전문 인력은 각각의 전문성을 통해 조직의 분석 역량을 강화하는 데 필수적입니다. 반면, 교육담당 인력은 분석 기법에 대한 교육을 제공하지만, 이는 다른 인력들이 겸직할 수 있는 역할로, 필수적이지 않습니다. 따라서 교육담당 인력이 반드시 필요한 인력은 아닙니다.<br>
따라서, 정답은 '4. 분석 조직에게 다양한 분석 기법에 대한 심도있는 교육을 할 수 있는 교육담당 인력' 입니다.<br>
			</div>
			<div class="t2">
									#분석 조직									# 비즈니스 인력									# IT 기술 인력									# 분석 전문 인력									# 교육담당 인력							</div>
		</div>
		
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">3과목</span>
			<span class="g1">분석 거버넌스 체계 수립</span>
			<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">29.</span>
			<span class="tt1t1">
				하향식 접근법의 문제탐색 단계의 도구로 부적절한 것은 무엇인가?							</span>
		</strong>
		<span class="tt1t1">
				    </span> 
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			탐색적 문제 발견					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			외부 참조 모델 기반 문제탐색 					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			비즈니스 모델 기반 문제탐색 					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			분석 유즈 케이스 					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a29" class="b2 help" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a29" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">1</i>
			<span class="t2t1">
			탐색적 문제 발견			</span>
					</div>
        <br>
				<strong class="tt1">해설</strong>
		<div class="t1">
		하향식 접근법의 문제탐색 단계의 도구는 비즈니스 모델 기반 문제 탐색, 외부 참조 모델 기반 문제탐색, 분석 유즈 케이스 등이 있다.				</div>
		
				
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				정답은 1번입니다.<br>
<br>
하향식 접근법의 문제 탐색 단계는 문제를 체계적으로 식별하고 정의하는 과정입니다. 이 단계에서는 기업의 비즈니스 모델과 외부 참조 모델을 활용하여 문제를 도출합니다. <br>
<br>
1. 탐색적 문제 발견 <br>
: 탐색적 문제 발견은 주로 상향식 접근법에서 사용됩니다. 이는 문제를 명확히 정의하지 않고 데이터를 통해 문제를 발견하는 방식입니다. 하향식 접근법에서는 이미 정의된 문제를 해결하는 데 중점을 두기 때문에 탐색적 문제 발견은 부적절합니다. 예를 들어, 새로운 시장 기회를 찾기 위해 데이터를 분석하는 과정이 탐색적 문제 발견에 해당합니다.<br>
<br>
2. 외부 참조 모델 기반 문제탐색 <br>
: 외부 참조 모델 기반 문제탐색은 하향식 접근법에서 사용되는 도구입니다. 이는 벤치마킹을 통해 다른 기업이나 산업의 사례를 참고하여 문제를 식별하는 방식입니다. 예를 들어, 경쟁사의 성공적인 전략을 분석하여 자사의 문제를 도출하는 것이 이에 해당합니다.<br>
<br>
3. 비즈니스 모델 기반 문제탐색 <br>
: 비즈니스 모델 기반 문제탐색은 하향식 접근법의 핵심 도구 중 하나입니다. 이는 기업의 내부 및 외부 환경을 포괄하는 비즈니스 모델을 활용하여 문제를 도출하는 방식입니다. 예를 들어, 기업의 가치 사슬을 분석하여 개선이 필요한 부분을 찾는 것이 이에 해당합니다.<br>
<br>
4. 분석 유즈 케이스 <br>
: 분석 유즈 케이스는 문제를 구체적인 분석 과제로 전환하는 데 사용됩니다. 이는 하향식 접근법에서 문제를 해결하기 위한 구체적인 방법론을 정의하는 데 유용합니다. 예를 들어, 고객 이탈 문제를 해결하기 위한 분석 유즈 케이스를 정의하는 것이 이에 해당합니다.<br>
<br>
탐색적 문제 발견은 하향식 접근법의 문제 탐색 단계에서 부적절한 도구입니다. 하향식 접근법은 이미 정의된 문제를 해결하는 데 중점을 두기 때문에, 문제를 새롭게 발견하는 탐색적 접근은 맞지 않습니다. 반면, 외부 참조 모델 기반 문제탐색, 비즈니스 모델 기반 문제탐색, 분석 유즈 케이스는 모두 하향식 접근법에서 문제를 체계적으로 식별하고 정의하는 데 적합한 도구입니다.<br>
<br>
따라서, 정답은 '1. 탐색적 문제 발견' 입니다.<br>
			</div>
			<div class="t2">
									#하향식 접근법									# 문제 탐색									# 비즈니스 모델									# 외부 참조 모델									# 탐색적 문제 발견							</div>
		</div>
		
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">3과목</span>
			<span class="g1">분석 과제 발굴</span>
			<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">30.</span>
			<span class="tt1t1">
				“장기적인 마스터 플랜 방식”에 비하여 “과제 중심적인 접근 방식”의 특징으로 적절하지 못한 것은?							</span>
		</strong>
		<span class="tt1t1">
				    </span> 
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			Speed&amp;Test					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			Problem Solving 					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			Problem Definition					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			Quick&amp;Win					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a30" class="b2 help" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a30" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">3</i>
			<span class="t2t1">
			Problem Definition			</span>
					</div>
        <br>
				<strong class="tt1">해설</strong>
		<div class="t1">
		과제 중심적인 접근 방식의 특징은 Speed &amp;Test, Quick &amp; Win, Problem Solving이다.				</div>
		
				
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				정답은 3번입니다.<br>
<br>
과제 중심적인 접근 방식은 주로 단기적인 목표를 빠르게 달성하기 위한 방법론입니다. 이 방식은 문제를 빠르게 해결하고, 즉각적인 결과를 얻는 데 중점을 둡니다. 반면, 장기적인 마스터 플랜 방식은 장기적인 목표를 설정하고, 체계적으로 문제를 정의하고 해결하는 데 중점을 둡니다. 이러한 두 접근 방식의 차이를 이해하는 것이 중요합니다. 과제 중심적인 접근 방식은 빠른 실행과 테스트, 즉각적인 성과를 중시하며, 문제 해결에 초점을 맞춥니다. 반면, 마스터 플랜 방식은 문제 정의와 장기적인 관점에서의 계획 수립을 중시합니다.<br>
<br>
1. Speed&amp;Test <br>
: Speed&amp;Test는 과제 중심적인 접근 방식의 핵심 요소입니다. 이 방식은 빠른 실행과 테스트를 통해 즉각적인 피드백을 얻고, 이를 바탕으로 문제를 해결하는 데 중점을 둡니다. 예를 들어, 소프트웨어 개발에서 애자일 방법론은 빠른 프로토타입 제작과 테스트를 통해 제품을 개선하는 방식으로, 과제 중심적인 접근 방식의 좋은 예입니다.<br>
<br>
2. Problem Solving <br>
: Problem Solving은 과제 중심적인 접근 방식의 또 다른 특징입니다. 이 방식은 주어진 문제를 빠르게 해결하는 데 중점을 두며, 문제 해결을 통해 즉각적인 성과를 얻고자 합니다. 예를 들어, 고객 불만을 해결하기 위해 즉각적인 조치를 취하는 것이 이에 해당합니다.<br>
<br>
3. Problem Definition <br>
: Problem Definition은 장기적인 마스터 플랜 방식의 특징입니다. 이 방식은 문제를 명확히 정의하고, 이를 바탕으로 장기적인 계획을 수립하는 데 중점을 둡니다. 문제를 정의하는 과정은 문제의 원인을 분석하고, 이를 해결하기 위한 체계적인 접근 방식을 개발하는 것을 포함합니다. 따라서, 과제 중심적인 접근 방식과는 다소 거리가 있습니다.<br>
<br>
4. Quick&amp;Win <br>
: Quick&amp;Win은 과제 중심적인 접근 방식의 또 다른 특징입니다. 이 방식은 빠른 성과를 얻기 위해 작은 승리를 쌓아가는 전략을 사용합니다. 예를 들어, 작은 프로젝트를 성공적으로 완료하여 팀의 사기를 높이고, 이를 통해 더 큰 프로젝트로 나아가는 방식입니다.<br>
<br>
과제 중심적인 접근 방식은 빠른 실행과 즉각적인 성과를 중시하는 반면, 문제 정의는 장기적인 마스터 플랜 방식의 특징입니다. 따라서, 선지 3은 과제 중심적인 접근 방식의 특징으로 적절하지 않습니다. 다른 선지들은 모두 과제 중심적인 접근 방식의 특징을 잘 설명하고 있습니다.<br>
따라서, 정답은 '3. Problem Definition' 입니다.<br>
			</div>
			<div class="t2">
									#과제 중심									# 마스터 플랜									# 문제 해결									# 문제 정의									# 빠른 실행							</div>
		</div>
		
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">3과목</span>
			<span class="g1">분석 기획 방향성 도출</span>
			<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">31.</span>
			<span class="tt1t1">
				다음 중 측정 방법에 대한 설명으로 가장 부적절한 것은?							</span>
		</strong>
		<span class="tt1t1">
				    </span> 
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			순서척도 - 측정 대상이 서열관계를 가지고 있다. 					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			비율척도 - 절대적 기준인 0값이 존재하고 모든 사칙연산이 가능하다. 					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			명목척도 - 측정 대상이 어느 집단에 속하는지 분류할 때 사용하는 척도이다. 					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			구간척도 - 측정 대상이 갖고 있는 속성의 질을 측정하는 것이다.					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a31" class="b2 help" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a31" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">4</i>
			<span class="t2t1">
			구간척도 - 측정 대상이 갖고 있는 속성의 질을 측정하는 것이다.			</span>
					</div>
        <br>
				<strong class="tt1">해설</strong>
		<div class="t1">
		구간척도는 측정 대상이 갖고 있는 속성의 양을 측정하는 데이터 형태이다.				</div>
		
				
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				정답은 4번입니다.<br>
<br>
문제는 측정 척도의 종류와 그 특성을 이해하는 것을 요구합니다. 측정 척도는 명목척도, 순서척도, 구간척도, 비율척도로 나뉘며 각각의 특성이 다릅니다.<br>
<br>
1. 순서척도 - 측정 대상이 서열관계를 가지고 있다.<br>
: 순서척도는 대상 간의 서열 관계를 나타내며, 순위만을 비교할 수 있습니다. 예를 들어, 1등, 2등과 같은 순위가 이에 해당합니다.<br>
<br>
2. 비율척도 - 절대적 기준인 0값이 존재하고 모든 사칙연산이 가능하다.<br>
: 비율척도는 절대적 기준인 0이 존재하며, 모든 사칙연산이 가능합니다. 예를 들어, 길이, 무게 등이 이에 해당합니다.<br>
<br>
3. 명목척도 - 측정 대상이 어느 집단에 속하는지 분류할 때 사용하는 척도이다.<br>
: 명목척도는 대상이 어느 집단에 속하는지를 분류하는 데 사용됩니다. 예를 들어, 성별, 혈액형 등이 이에 해당합니다.<br>
<br>
4. 구간척도 - 측정 대상이 갖고 있는 속성의 질을 측정하는 것이다.<br>
: 구간척도는 대상의 속성 간의 차이를 측정할 수 있지만, 절대적 0이 없고 비율 계산이 불가능합니다. 예를 들어, 온도(섭씨, 화씨) 등이 이에 해당합니다.<br>
<br>
<br>
구간척도는 속성의 질을 측정하는 것이 아니라, 속성 간의 차이를 측정하는 것입니다. 따라서 '구간척도 - 측정 대상이 갖고 있는 속성의 질을 측정하는 것이다.'라는 설명은 부적절합니다. 다른 선택지들은 각각의 척도에 대한 올바른 설명을 제공하고 있습니다.<br>
<br>
따라서, 정답은 '4. 구간척도 - 측정 대상이 갖고 있는 속성의 질을 측정하는 것이다.' 입니다.<br>
			</div>
			<div class="t2">
									#명목척도									# 순서척도									# 구간척도									# 비율척도							</div>
		</div>
		
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">4과목</span>
			<span class="g1">통계분석 방법론</span>
			<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">32.</span>
			<span class="tt1t1">
				기술 통계의 산포를 나타내는 도구의 설명이 틀린 것은? 							</span>
		</strong>
		<span class="tt1t1">
				    </span> 
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			평균(mean) - 데이터의 전체 합을 전체 개수로 나누어 산출하는 대표 값 					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			중위수(median) - 데이터를 입력순서에 따라 나열하여 가장 중앙에 위치하는 값 					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			사분위수(quantile) - 데이터를 작은 수부터 큰 수까지 배열했을 때 전체 관측값을 n등분하는 위치에 오는 값을 n 사분위수라 함 					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			백분위수(percentile) - 크기가 있는 값들로 이루어진 자료를 순서대로 나열했을 때 전체 데이터 개수의 p%에 위치하 는 값을 P 백분위 값이라고 함					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a32" class="b2 help" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a32" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">2</i>
			<span class="t2t1">
			중위수(median) - 데이터를 입력순서에 따라 나열하여 가장 중앙에 위치하는 값 			</span>
					</div>
        <br>
				<strong class="tt1">해설</strong>
		<div class="t1">
		기술통계의 산포를 나타내는 도구를 묻는 문제로 데이터를 크기순서에 따라 나열하여 가장 중앙에 위치하는 값이 중앙값이다.				</div>
		
				
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				정답은 2번입니다.<br>
<br>
기술 통계에서 산포를 나타내는 도구는 데이터의 분포와 변동성을 이해하는 데 필수적입니다. 산포는 데이터가 평균을 중심으로 얼마나 퍼져 있는지를 나타내며, 이를 통해 데이터의 변동성을 파악할 수 있습니다. 대표적인 산포의 측도로는 분산, 표준편차, 범위, 사분위수 범위 등이 있습니다. 이러한 측도들은 데이터의 중심 경향과 함께 분석되어 데이터의 특성을 종합적으로 이해하는 데 도움을 줍니다.<br>
<br>
1. 평균(mean) - 데이터의 전체 합을 전체 개수로 나누어 산출하는 대표 값 <br>
: 평균은 데이터의 전체 합을 데이터의 개수로 나눈 값으로, 데이터의 중심 경향을 나타내는 대표적인 값입니다. 평균은 모든 데이터 값을 고려하여 계산되므로, 데이터의 변동성을 직접적으로 나타내지는 않지만, 데이터의 중심 위치를 파악하는 데 유용합니다. 평균은 극단값에 민감하여 데이터의 분포가 비대칭일 경우 왜곡될 수 있습니다.<br>
<br>
2. 중위수(median) - 데이터를 입력순서에 따라 나열하여 가장 중앙에 위치하는 값 <br>
: 중위수는 데이터를 크기순으로 나열했을 때 중앙에 위치하는 값으로, 데이터의 중심 경향을 나타냅니다. 중위수는 데이터의 분포가 비대칭일 때 평균보다 더 적절한 중심 경향의 측도로 사용됩니다. 중위수는 산포를 나타내는 도구가 아니라 중심 경향을 나타내는 도구입니다. 따라서 이 선지는 틀린 설명입니다.<br>
<br>
3. 사분위수(quantile) - 데이터를 작은 수부터 큰 수까지 배열했을 때 전체 관측값을 n등분하는 위치에 오는 값을 n 사분위수라 함 <br>
: 사분위수는 데이터를 작은 수부터 큰 수까지 배열했을 때 전체 관측값을 n등분하는 위치에 오는 값을 의미합니다. 예를 들어, 1사분위수(Q1)는 데이터의 하위 25% 지점, 3사분위수(Q3)는 상위 25% 지점을 나타냅니다. 사분위수는 데이터의 분포를 이해하고, 극단값의 영향을 줄이기 위해 사용됩니다. 사분위수 범위(IQR)는 Q3에서 Q1을 뺀 값으로, 데이터의 중간 50%의 범위를 나타내어 산포를 측정합니다.<br>
<br>
4. 백분위수(percentile) - 크기가 있는 값들로 이루어진 자료를 순서대로 나열했을 때 전체 데이터 개수의 p%에 위치하 는 값을 P 백분위 값이라고 함 <br>
: 백분위수는 데이터를 순서대로 나열했을 때 특정 백분위에 해당하는 값을 의미합니다. 예를 들어, 90백분위수는 데이터의 상위 10%에 해당하는 값을 나타냅니다. 백분위수는 데이터의 상대적 위치를 파악하는 데 유용하며, 특히 대규모 데이터셋에서 개별 데이터의 위치를 이해하는 데 사용됩니다. 백분위수는 산포를 직접적으로 나타내기보다는 데이터의 분포를 이해하는 데 도움을 줍니다.<br>
<br>
문제에서 산포를 나타내는 도구를 묻고 있습니다. 산포는 데이터의 변동성을 나타내는 측도로, 분산, 표준편차, 사분위수 범위 등이 이에 해당합니다. 중위수는 데이터의 중심 경향을 나타내는 값으로, 산포를 나타내는 도구가 아닙니다. 따라서 중위수에 대한 설명이 틀렸습니다. 다른 선지들은 각각 평균, 사분위수, 백분위수에 대한 설명으로, 이들은 각각 데이터의 중심 경향과 분포를 이해하는 데 사용됩니다.<br>
따라서, 정답은 '2. 중위수(median) - 데이터를 입력순서에 따라 나열하여 가장 중앙에 위치하는 값' 입니다.<br>
			</div>
			<div class="t2">
									#기술 통계									# 산포									# 평균									# 중위수									# 사분위수									# 백분위수							</div>
		</div>
		
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">4과목</span>
			<span class="g1">R 기초</span>
			<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">33.</span>
			<span class="tt1t1">
				변수 A안에 벡터 ("a", "b", "c") 이 있다고 하면 결과값이 ""a d"" ""b e"" ""c d""라고 나오게 하는 결과가 나오는 함수는 무엇인가?							</span>
		</strong>
		<span class="tt1t1">
				    </span> 
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			paste(A, d, e, d) 					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			paste(A, c("d", "e")) 					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			paste(A, c("d"), c("e")) 					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			A+d+e					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a33" class="b2 help" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a33" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">2</i>
			<span class="t2t1">
			paste(A, c("d", "e")) 			</span>
					</div>
        <br>
				<strong class="tt1">해설</strong>
		<div class="t1">
		paste("붙일 내용","붙일 내용", sep="") paste 함수 안에는 붙일 내용 2개와 옵션을 줄 수 있다. 여기에 붙일 내용 3가지 이상 들어가면 오류가 나타나게 된다. ①, ③번은 붙일 내용이 3개 이상임으로 오류가 나오고 ④번은 문법에 맞지 않는 문장이다.				</div>
		
				
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				이 문제는 R 프로그래밍 언어에서 벡터와 문자열을 다루는 방법에 관한 것입니다. 주어진 벡터 A에 "d"와 "e"를 추가하여 원하는 결과를 얻기 위해서는 `paste` 함수를 사용해야 합니다. <br>
<br>
- 1번 선택지는 함수의 사용법이 잘못되었습니다. `paste` 함수는 벡터와 문자열을 결합하는 데 사용되지만, "," 기호는 사용되 <br>
  지 않습니다.<br>
<br>
- 2번 선택지는 `paste` 함수와 `c` 함수를 올바르게 사용하여 벡터 A와 "d", "e"를 결합합니다. 따라서 결과 값이 "a d", "b e", <br>
  "c d"가 됩니다.<br>
<br>
- 3번 선택지는 `paste` 함수와 `c` 함수를 사용하지만, 두 개의 `c` 함수를 사용하여 벡터를 분리하는 방식이 잘못되었습니다.<br>
<br>
- 4번 선택지는 R에서 벡터와 문자열을 결합하는 올바른 방법이 아닙니다.<br>
<br>
			</div>
			<div class="t2">
									# R 프로그래밍									# 벡터									# paste 함수									# c 함수									# 문자열 결합									# R 출력 결과							</div>
		</div>
		
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">4과목</span>
			<span class="g1">통계분석의 이해</span>
			<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">34.</span>
			<span class="tt1t1">
				다음 중 아래 내용을 검정할 때 활용할 수 있는 분포로 가장 적절한 것은?					
					<span class="tt1t1">
						두 개의 처리를 비교하는 문제를 생각해 보라. 예를 들어, 콜레스테롤 수치를 낮추기 위한 약으로 A와 B가 있다고 하자. 약 A의 효과와 약 B의 효과에 대하여 평균을 비교하고자 한다.  이를 위해 총 8명의 실험 개체를 확보하여 비교 실험에 들어간다고 하자. 두 집단의 평균이 같은지를 결정하기 위하여 먼저 두 집단의 분산이 같은지를 결정해야 한다.					</span>
							</span>
		</strong>
		<span class="tt1t1">
				    </span> 
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			t-분포					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			z-분포					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			F-분포					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			포아송분포					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a34" class="b2 help" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a34" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">1</i>
			<span class="t2t1">
			t-분포			</span>
					</div>
        <br>
				<strong class="tt1">해설</strong>
		<div class="t1">
		해당 문제는 독립표본 t-검정으로 문제를 해결할 수 있다. 그러므로 t분포를 활용한다.				</div>
		
				
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				1. t-분포는 표본의 크기가 작을 때 (일반적으로 30 이하) 평균을 비교하기 위해 사용하는 분포입니다. 두 집단의 평균을 비교하는 t-검정에서는 특히 독립표본 t-검정과 대응표본 t-검정에서 t-분포를 사용합니다. 따라서 약 A와 약 B의 효과를 비교하기 위한 두 집단의 평균을 비교할 때 t-분포가 적절합니다.<br>
<br>
2. z-분포는 일반적으로 표본의 크기가 충분히 큰 경우 (30 이상) 또는 모집단의 분산을 알고 있을 때 사용하는 분포입니다. 또한, z-검정은 주로 단일 표본 평균을 비교하거나 비율을 비교할 때 사용됩니다. 그러나 이 문제에서 주어진 표본 크기가 작기 때문에 z-분포는 적절하지 않습니다<br>
<br>
3. F-분포는 두 개 이상의 집단 간의 분산을 비교할 때 사용됩니다. 예를 들어, 분산분석(ANOVA)에서 여러 집단의 평균을 비교하기 전에 집단 간 분산이 같은지를 검정할 때 F-검정을 사용합니다. 이 문제에서 두 집단의 평균을 비교하기 전에 분산을 검정하는 단계에서는 F-분포를 사용할 수 있지만, 최종적으로 평균을 비교할 때는 t-분포를 사용해야 합니다.<br>
<br>
4. 포아송분포는 단위 시간 또는 단위 공간 내에 발생하는 사건의 수를 모델링할 때 사용됩니다. 예를 들어, 특정 시간 동안 발생하는 교통사고의 수, 특정 지역 내 발생하는 병원의 응급환자 수 등을 예측할 때 사용됩니다. 이 문제에서는 평균을 비교하는 것이므로 포아송분포는 적절하지 않습니다.<br>
			</div>
			<div class="t2">
									# 두 집단 평균 비교									# 분산 비교									# F-분포									# 분산분석									# ANOVA									#  t-분포									# z-분포									# 포아송분포							</div>
		</div>
		
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">4과목</span>
			<span class="g1">R 기초</span>
			<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">35.</span>
			<span class="tt1t1">
				아래의 자료 X 값과 보기의 R 코드 결과가 다른 것은?					
					<span class="tt1t1">
						X&lt;-c(3, 2, 1, 4, 5)					</span>
							</span>
		</strong>
		<span class="tt1t1">
				    </span> 
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			sum(x)					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			x[5]*x[1]					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			mean(x)*length(x)					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			mean(x)*min(x)*range(x)[1]					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a35" class="b2 help" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a35" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">4</i>
			<span class="t2t1">
			mean(x)*min(x)*range(x)[1]			</span>
					</div>
        <br>
				<strong class="tt1">해설</strong>
		<div class="t1">
		각 코드를 실행한 결과는 아래와 같다.<br>
&gt; sum(x)     <br>
[1] 15<br>
&gt; x[5]*x[1] <br>
[1] 15<br>
&gt; mean(x)*length(x) <br>
[1] 15<br>
&gt; mean(x)*min(x)*range(x)[1] <br>
[1] 3				</div>
		
				
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				- 주어진 X 값은 `X &lt;- c(3, 2, 1, 4, 5)`입니다.<br>
  각 보기의 R 코드 결과를 계산해보면 다음과 같습니다:<br>
<br>
1. `sum(x)`는 벡터 x의 합을 구하는 함수입니다. `3 + 2 + 1 + 4 + 5 = 15`<br>
     <br>
2. `x[5]*x[1]`는 벡터 x의 5번째 요소와 1번째 요소를 곱하는 것입니다. `5 * 3 = 15`<br>
     <br>
3. `mean(x)*length(x)`는 벡터 x의 평균 값에 길이를 곱하는 것입니다. `mean(x)`는 `(3 + 2 + 1 + 4 + 5) / 5 = 3`, <br>
    `length(x)`는 `5`이므로 `3 * 5 = 15`<br>
     <br>
4. `mean(x)*min(x)*range(x)[1]`는 벡터 x의 평균 값에 최소 값과 범위의 첫 번째 값을 곱하는 것입니다. `mean(x)`는 `3`, <br>
   `min(x)`는 `1`, `range(x)[1]`는 `1`이므로 `3 * 1 * 1 = 3`<br>
<br>
따라서, 다른 결과를 가지는 것은 4번입니다.<br>
			</div>
			<div class="t2">
									# R 코드									# 벡터									# 합									# 곱									# 평균									# 길이									# 최소값									# 범위									# R 출력결과							</div>
		</div>
		
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">4과목</span>
			<span class="g1">회귀분석</span>
			<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">36.</span>
			<span class="tt1t1">
				다음 중 상관분석의 정의로 틀린 것은?							</span>
		</strong>
		<span class="tt1t1">
				    </span> 
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			데이터의 두 변수 간의 관계를 알아보기 위한 분석방법이다. 					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			두 변수의 상관관계를 알아보기 위해 상관계수를 이용한다. 					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			상관계수가 0일 때는 데이터 간의 상관관계를 정의할 수 없다. 					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			상관계수가 1에 가까울수록 데이터가 강한 양의 상관관계를 갖는다.					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a36" class="b2 help" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a36" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">3</i>
			<span class="t2t1">
			상관계수가 0일 때는 데이터 간의 상관관계를 정의할 수 없다. 			</span>
					</div>
        <br>
				<strong class="tt1">해설</strong>
		<div class="t1">
		상관계수가 0인 경우 데이터 간의 관계가 없다. 				</div>
		
				
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				정답은 3번입니다.<br>
<br>
상관분석은 두 변수 간의 관계의 정도를 파악하기 위한 통계적 방법입니다. 이 분석은 두 변수 간의 상관관계를 수치적으로 나타내는 상관계수를 사용하여 수행됩니다. 상관계수는 -1에서 1 사이의 값을 가지며, 1에 가까울수록 강한 양의 상관관계, -1에 가까울수록 강한 음의 상관관계를 나타냅니다. 0에 가까운 상관계수는 두 변수 간에 선형적 관계가 거의 없음을 의미합니다. 상관분석은 관계의 정도를 파악하는 데 유용하지만, 인과관계를 설명하지는 못합니다.<br>
<br>
1. 데이터의 두 변수 간의 관계를 알아보기 위한 분석방법이다. <br>
: 상관분석은 두 변수 간의 관계를 파악하는 데 사용됩니다. 이는 두 변수 간의 상관관계를 수치적으로 나타내는 상관계수를 통해 수행됩니다. 예를 들어, 키와 몸무게 간의 관계를 분석할 때 상관분석을 사용하여 두 변수 간의 관계의 강도를 파악할 수 있습니다.<br>
<br>
2. 두 변수의 상관관계를 알아보기 위해 상관계수를 이용한다. <br>
: 상관계수는 두 변수 간의 상관관계를 수치적으로 나타내는 지표입니다. 상관계수는 -1에서 1 사이의 값을 가지며, 1에 가까울수록 강한 양의 상관관계, -1에 가까울수록 강한 음의 상관관계를 나타냅니다. 상관계수를 통해 두 변수 간의 관계의 강도를 정량적으로 평가할 수 있습니다.<br>
<br>
3. 상관계수가 0일 때는 데이터 간의 상관관계를 정의할 수 없다. <br>
: 상관계수가 0일 때는 두 변수 간에 선형적 상관관계가 없음을 의미합니다. 그러나 이는 두 변수 간에 전혀 관계가 없다는 것을 의미하지는 않습니다. 비선형적 관계가 존재할 수 있으며, 상관계수는 이러한 비선형적 관계를 포착하지 못합니다. 따라서 상관계수가 0이라고 해서 두 변수 간의 관계를 정의할 수 없다는 것은 틀린 설명입니다.<br>
<br>
4. 상관계수가 1에 가까울수록 데이터가 강한 양의 상관관계를 갖는다. <br>
: 상관계수가 1에 가까울수록 두 변수 간의 강한 양의 상관관계를 나타냅니다. 이는 두 변수 간의 관계가 선형적이며, 한 변수가 증가할 때 다른 변수도 증가하는 경향이 강하다는 것을 의미합니다. 예를 들어, 공부 시간과 시험 점수 간의 상관관계가 1에 가까운 경우, 공부 시간이 증가할수록 시험 점수도 증가하는 경향이 강하다는 것을 의미합니다.<br>
<br>
선지 3은 상관계수가 0일 때 두 변수 간의 상관관계를 정의할 수 없다고 설명하고 있습니다. 그러나 상관계수가 0이라는 것은 두 변수 간에 선형적 관계가 없음을 의미할 뿐, 비선형적 관계가 존재할 가능성을 배제하지 않습니다. 따라서 상관계수가 0일 때 두 변수 간의 관계를 정의할 수 없다는 설명은 틀린 것입니다. 다른 선지들은 상관분석의 정의와 상관계수의 특성을 올바르게 설명하고 있습니다.<br>
따라서, 정답은 '3. 상관계수가 0일 때는 데이터 간의 상관관계를 정의할 수 없다.' 입니다.<br>
			</div>
			<div class="t2">
									#상관분석									# 상관계수									# 선형관계									# 비선형관계									# 통계적 방법							</div>
		</div>
		
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">4과목</span>
			<span class="g1">고급회귀분석</span>
			<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">37.</span>
			<span class="tt1t1">
				선형회귀분석을 실행하기 위해서는 데이터가 가지고 있는 특정 가정을 만족해야 의미가 있다고 할 수 있다. 선형회귀분석에서 전제로 하는 가정이 아닌 것을 고르시오.							</span>
		</strong>
		<span class="tt1t1">
				    </span> 
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			선형성 					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			일치성					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			정규성					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			등분산성					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a37" class="b2 help" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a37" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">2</i>
			<span class="t2t1">
			일치성			</span>
					</div>
        <br>
				<strong class="tt1">해설</strong>
		<div class="t1">
		선형회귀분석의 가정에는 선형성, 등분산성, 독립성, 비상관성, 정상성(정규성)이 있다.				</div>
		
				
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				정답은 2번입니다.<br>
<br>
선형회귀분석은 독립변수와 종속변수 간의 관계를 선형적으로 모델링하는 통계 기법입니다. 이를 통해 독립변수가 종속변수에 미치는 영향을 추정할 수 있습니다. 선형회귀분석이 유의미하려면 몇 가지 가정을 만족해야 합니다. 첫째, 선형성 가정은 독립변수와 종속변수 간의 관계가 선형적이어야 한다는 것입니다. 둘째, 등분산성 가정은 독립변수의 값에 관계없이 오차의 분산이 일정해야 한다는 것입니다. 셋째, 정규성 가정은 오차항이 정규분포를 따라야 한다는 것입니다. 마지막으로, 독립성 가정은 오차항들이 서로 독립적이어야 한다는 것입니다. 이러한 가정들이 충족될 때, 회귀모형은 신뢰할 수 있는 예측을 제공합니다.<br>
<br>
1. 선형성 <br>
: 선형성은 회귀분석에서 가장 기본적인 가정으로, 독립변수와 종속변수 간의 관계가 직선 형태로 나타나야 한다는 것입니다. 이는 산점도를 통해 확인할 수 있으며, 선형적이지 않다면 회귀모형이 적합하지 않을 수 있습니다.<br>
<br>
2. 일치성 <br>
: 일치성은 선형회귀분석의 가정에 포함되지 않습니다. 이는 데이터의 일관성을 의미할 수 있지만, 회귀분석의 전제 조건으로는 사용되지 않습니다. 따라서 이 선지는 회귀분석의 가정과 관련이 없습니다.<br>
<br>
3. 정규성 <br>
: 정규성은 회귀분석에서 오차항이 정규분포를 따라야 한다는 가정입니다. 이는 Q-Q Plot을 통해 확인할 수 있으며, 오차항이 정규분포를 따를 때 회귀모형의 예측이 신뢰할 수 있습니다.<br>
<br>
4. 등분산성 <br>
: 등분산성은 독립변수의 값에 관계없이 오차의 분산이 일정해야 한다는 가정입니다. 이는 잔차의 산점도를 통해 확인할 수 있으며, 등분산성이 만족되지 않으면 회귀모형의 예측이 왜곡될 수 있습니다.<br>
<br>
선형회귀분석의 가정에는 선형성, 정규성, 등분산성, 독립성이 포함됩니다. '일치성'은 회귀분석의 가정에 포함되지 않으며, 따라서 이 선지가 정답입니다. 나머지 선지들은 모두 회귀분석의 필수 가정에 해당합니다.<br>
따라서, 정답은 '2. 일치성' 입니다.<br>
			</div>
			<div class="t2">
									#선형회귀분석									# 선형성									# 정규성									# 등분산성									# 독립성									# 가정							</div>
		</div>
		
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">4과목</span>
			<span class="g1">고급회귀분석</span>
			<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">38.</span>
			<span class="tt1t1">
				아래 표는 R을 통해 다중회귀분석을 한 결과이다. 결과에 대한 해석이 잘못된 것은?							</span>
		</strong>
		<span class="tt1t1">
						<a href="exam1view1img1.php?img=15f6a970-f6cf-7747-29a8-9d3f7517eab1.png" target="_blank" rel="noopener" title="새 창" class="p1">
				<img src="/data/img/question/15f6a970-f6cf-7747-29a8-9d3f7517eab1.png" alt="문제에 포함된 이미지">
			</a>
				    </span> 
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			회귀식은 종속변수 Y와 독립변수 x1, x2, x4로 모형을 추정하였다.					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			F-통계량은 166.8이고 p값이 유의수준 5%하에서 추정된 회귀모형이 통계적으로 매우 유의함을 볼 수 있다. 					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			수정된 결정계수가 0.9764로 아주 높아 회귀식이 데이터를 적절하게 설명하고 있음을 확인 할 수 있다. 					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			x4의 T값과 p값이 유의수준 5%하에서 유의하지 않고 회귀모형이 통계적으로 유의하므로 최종 회귀모형은 Y=71.6483+1.4519x1+0.4161x2으로 결정된다. 					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a38" class="b2 help" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a38" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">4</i>
			<span class="t2t1">
			x4의 T값과 p값이 유의수준 5%하에서 유의하지 않고 회귀모형이 통계적으로 유의하므로 최종 회귀모형은 Y=71.6483+1.4519x1+0.4161x2으로 결정된다. 			</span>
					</div>
        <br>
				<strong class="tt1">해설</strong>
		<div class="t1">
		x4의 T값과 p값이 유의수준 5% 하에서 유의하지 않으므로 x4를 제외하고 다시 한 번 더 회귀분석을 실시해서 모든 독립변수가 유의수준 5% 하에서 유의하고 회귀모형의 F값과 p값이 유의할 경우 회귀식을 결정하고 회귀분석을 종료할 수 있다.				</div>
		
				
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				4번 항목의 내용은 잘못된 해석입니다. x4의 T값과 p값이 유의수준 5% 하에서 유의하지 않다는 것은 맞습니다. 그러나 최종 회귀모형을 결정할 때, 단순히 유의하지 않은 변수를 제외하고 나머지 변수들만을 포함하는 것은 잘못된 해석입니다. 회귀모형을 수정할 때는 변수 선택 방법론(예: 단계적 선택법, 후진제거법 등)을 사용하거나, 이론적 배경을 고려하여 변수를 선택해야 합니다. 따라서, x4가 유의하지 않다고 해서 바로 제외하고 회귀식을 결정하는 것은 옳지 않습니다.<br>
			</div>
			<div class="t2">
									# 회귀식									# F통계량									# p값									# 수정된 결정계수									# T값									# 유의수준									# 회귀모형									# R프로그램 결과해석									# 다중회귀분석							</div>
		</div>
		
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">4과목</span>
			<span class="g1">시계열분석</span>
			<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">39.</span>
			<span class="tt1t1">
				다음은 시계열 분석에 대한 설명이다. 설명이 잘못된 것은?							</span>
		</strong>
		<span class="tt1t1">
				    </span> 
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			시계열분석에서 사용되는 모형은 크게 자기회귀모형(AR모형)과 이동평균모형(MA모형)으로 나눈다.					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			자기회귀모형에서 자기상관함수(ACF)는 빠르게 감소하고, 부분자기함수(PACF)는 어느 시점에서 절단점을 갖게된다.					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			이동평균모형에서 자기상관함수(ACF)는 절단점을 갖고, 부분자기상관함수(PACF)가 빠르게 감소함을 볼 수 있다.					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			자기회귀누적이동평균모형(ARIMA)은 정상시계열모형으로 차분이나 변환을 통해 AR모형이나 MA모형으로, 둘을 합친 ARMA모형으로 비정상화 할 수 있다.					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a39" class="b2 help" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a39" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">4</i>
			<span class="t2t1">
			자기회귀누적이동평균모형(ARIMA)은 정상시계열모형으로 차분이나 변환을 통해 AR모형이나 MA모형으로, 둘을 합친 ARMA모형으로 비정상화 할 수 있다.			</span>
					</div>
        <br>
				<strong class="tt1">해설</strong>
		<div class="t1">
		자기회귀누적이동평균모형(ARIMA)은 비정상시계열모형으로 차분이나 변환을 통해 AR모형이나 MA모형으로, 둘을 합친 ARMA모형으로 정상화 할 수 있다.				</div>
		
				
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				정답은 4번입니다.<br>
<br>
시계열 분석은 시간에 따라 변화하는 데이터를 분석하는 방법으로, 주로 미래의 값을 예측하거나 데이터의 패턴을 이해하는 데 사용됩니다. 시계열 분석에서 중요한 개념은 자기회귀모형(AR), 이동평균모형(MA), 그리고 이 둘을 결합한 ARMA 모형입니다. AR 모형은 과거의 데이터가 현재 데이터에 영향을 미치는 방식으로, 자기상관함수(ACF)와 부분자기상관함수(PACF)를 통해 분석됩니다. MA 모형은 과거의 예측 오차가 현재 데이터에 영향을 미치는 방식입니다. ARIMA 모형은 비정상 시계열 데이터를 정상 시계열로 변환하여 분석하는 방법으로, 차분을 통해 정상성을 확보합니다.<br>
<br>
1. 시계열분석에서 사용되는 모형은 크게 자기회귀모형(AR모형)과 이동평균모형(MA모형)으로 나눈다. <br>
: 시계열 분석에서 AR 모형과 MA 모형은 기본적인 두 가지 모형입니다. AR 모형은 과거의 데이터가 현재 데이터에 영향을 미치는 방식으로, 자기상관성을 기반으로 합니다. MA 모형은 과거의 예측 오차가 현재 데이터에 영향을 미치는 방식입니다. 이 두 모형은 시계열 분석의 기초를 이루며, ARMA 모형으로 결합될 수 있습니다.<br>
<br>
2. 자기회귀모형에서 자기상관함수(ACF)는 빠르게 감소하고, 부분자기함수(PACF)는 어느 시점에서 절단점을 갖게된다. <br>
: AR 모형에서는 ACF가 빠르게 감소하고, PACF는 특정 시점에서 절단점을 갖습니다. 이는 AR 모형의 특성으로, 과거의 특정 시점까지의 데이터가 현재에 영향을 미친다는 것을 의미합니다. 예를 들어, AR(2) 모형에서는 두 시점 전의 데이터까지가 현재에 영향을 미칩니다.<br>
<br>
3. 이동평균모형에서 자기상관함수(ACF)는 절단점을 갖고, 부분자기상관함수(PACF)가 빠르게 감소함을 볼 수 있다. <br>
: MA 모형에서는 ACF가 특정 시점에서 절단점을 갖고, PACF는 빠르게 감소합니다. 이는 MA 모형의 특성으로, 과거의 예측 오차가 현재 데이터에 영향을 미친다는 것을 의미합니다. 예를 들어, MA(1) 모형에서는 한 시점 전의 예측 오차가 현재에 영향을 미칩니다.<br>
<br>
4. 자기회귀누적이동평균모형(ARIMA)은 정상시계열모형으로 차분이나 변환을 통해 AR모형이나 MA모형으로, 둘을 합친 ARMA모형으로 비정상화 할 수 있다. <br>
: ARIMA 모형은 비정상 시계열 데이터를 정상 시계열로 변환하여 분석하는 방법입니다. ARIMA 모형은 차분을 통해 정상성을 확보하며, AR 모형이나 MA 모형, 또는 ARMA 모형으로 변환할 수 있습니다. 그러나 ARIMA 모형 자체는 비정상 시계열 모형이며, 정상화 과정을 통해 분석이 이루어집니다. 따라서 선지 4의 설명은 잘못되었습니다.<br>
<br>
선지 4는 ARIMA 모형이 정상 시계열 모형이라고 설명하고 있지만, 실제로 ARIMA 모형은 비정상 시계열 모형입니다. ARIMA 모형은 차분이나 변환을 통해 정상 시계열로 변환하여 분석하는 방법입니다. 따라서 선지 4의 설명은 잘못되었으며, 정답입니다. 다른 선지들은 각각 AR 모형과 MA 모형의 특성을 올바르게 설명하고 있습니다.<br>
따라서, 정답은 '4. 자기회귀누적이동평균모형(ARIMA)은 정상시계열모형으로 차분이나 변환을 통해 AR모형이나 MA모형으로, 둘을 합친 ARMA모형으로 비정상화 할 수 있다.' 입니다.<br>
			</div>
			<div class="t2">
									#시계열 분석									# 자기회귀모형									# 이동평균모형									# ARIMA 모형									# 정상 시계열							</div>
		</div>
		
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">4과목</span>
			<span class="g1">데이터 마이닝 개요</span>
			<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">40.</span>
			<span class="tt1t1">
				다음 중 모델링 목적에 따라 목적 변수를 정의하고 필요한 데이터를 적합한 형태로 변환하는 데이터 마이닝 단계는 무엇인가?							</span>
		</strong>
		<span class="tt1t1">
				    </span> 
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			데이터 준비					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			검증					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			데이터 가공					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			데이터 마이닝 기법의 적용					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a40" class="b2 help" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a40" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">3</i>
			<span class="t2t1">
			데이터 가공			</span>
					</div>
        <br>
				<strong class="tt1">해설</strong>
		<div class="t1">
		데이터 가공은 모델링 목적에 따라 목적 변수를 정의하고 필요한 데이터를 데이터마이닝 소프트웨어에 적용할 수 있도록 적합한 형식으로 가공한다.				</div>
		
				
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				정답은 3번입니다.<br>
<br>
데이터 마이닝은 대용량 데이터에서 의미 있는 패턴을 파악하거나 예측하여 의사결정에 활용하는 방법입니다. 이 과정은 여러 단계로 나뉘며, 각 단계는 특정한 목적을 가지고 있습니다. 데이터 준비 단계에서는 분석을 위해 데이터를 수집하고, 데이터의 품질을 확인하며, 분석 기법에 적합한 형태로 데이터를 변환합니다. 데이터 가공 단계는 모델링 목적에 따라 데이터를 정리하고, 필요한 데이터를 데이터 마이닝 소프트웨어에 적용할 수 있도록 준비하는 단계입니다. 이 단계에서는 목적 변수를 정의하고 데이터를 적합한 형태로 변환하는 작업이 포함됩니다.<br>
<br>
1. 데이터 준비 <br>
: 데이터 준비 단계는 데이터 수집, 데이터 탐색, 데이터 품질 확인 등의 작업을 포함합니다. 이 단계는 분석에 필요한 데이터를 수집하고, 데이터의 품질을 확인하여 분석에 적합한 데이터를 준비하는 과정입니다. 그러나 이 단계는 목적 변수를 정의하거나 데이터를 변환하는 작업보다는 데이터의 수집과 품질 확인에 중점을 둡니다.<br>
<br>
2. 검증 <br>
: 검증 단계는 모델링 결과가 프로젝트 목적에 부합하는지 평가하는 단계입니다. 이 단계에서는 데이터 마이닝 결과를 최종적으로 수용할 것인지 판단하며, 모델의 성능을 평가합니다. 따라서 검증 단계는 목적 변수를 정의하거나 데이터를 변환하는 단계와는 다릅니다.<br>
<br>
3. 데이터 가공 <br>
: 데이터 가공 단계는 모델링 목적에 따라 목적 변수를 정의하고, 필요한 데이터를 데이터 마이닝 소프트웨어에 적용할 수 있도록 준비하는 단계입니다. 이 단계에서는 데이터를 적합한 형태로 변환하여 모델링에 필요한 데이터를 준비합니다. 따라서 이 단계가 문제에서 묻는 데이터 마이닝 단계에 해당합니다.<br>
<br>
4. 데이터 마이닝 기법의 적용 <br>
: 데이터 마이닝 기법의 적용 단계는 다양한 모델링 기법과 알고리즘을 선택하고, 모델링 과정에서 사용되는 파라미터를 최적화하는 단계입니다. 이 단계는 이미 준비된 데이터를 사용하여 모델을 구축하고 평가하는 과정으로, 목적 변수를 정의하거나 데이터를 변환하는 작업과는 다릅니다.<br>
<br>
문제에서 묻는 데이터 마이닝 단계는 모델링 목적에 따라 목적 변수를 정의하고 데이터를 변환하는 단계입니다. 이는 데이터 가공 단계의 주요 작업으로, 데이터를 분석에 적합한 형태로 준비하는 과정입니다. 다른 선지들은 데이터 준비, 검증, 데이터 마이닝 기법의 적용과 관련된 단계로, 목적 변수 정의 및 데이터 변환과는 직접적인 관련이 없습니다.<br>
따라서, 정답은 '3. 데이터 가공' 입니다.<br>
			</div>
			<div class="t2">
									#데이터 마이닝									# 데이터 가공									# 목적 변수									# 데이터 변환									# 모델링							</div>
		</div>
		
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">4과목</span>
			<span class="g1">데이터변경 및 요약</span>
			<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">41.</span>
			<span class="tt1t1">
				데이터를 분리하고 처리한 다음, 다시 결합하는 등 가장 필수적인 데이터 처리기능을 제공하는 패키지로 apply함수를 기반으로 데이터와 출력변수를 동시에 배열로 치환하여 처리하는 패키지는 무엇인가?							</span>
		</strong>
		<span class="tt1t1">
				    </span> 
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			MySql					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			sqldf					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			OLAP					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			plyr					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a41" class="b2 help" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a41" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">4</i>
			<span class="t2t1">
			plyr			</span>
					</div>
        <br>
				<strong class="tt1">해설</strong>
		<div class="t1">
		plyr 함수는 apply 함수에 기반해 데이터와 출력변수를 동시에 배열로 치환하여 처리한다.				</div>
		
				
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				정답은 4번입니다.<br>
<br>
데이터 분석에서 데이터를 분리하고 처리한 다음, 다시 결합하는 과정은 매우 중요합니다. 이를 효과적으로 수행하기 위해 R에서는 다양한 패키지를 제공합니다. 그 중 'plyr' 패키지는 'split-apply-combine' 전략을 사용하여 데이터를 처리합니다. 이 패키지는 데이터를 분리(split)하고, 특정 함수를 적용(apply)한 후, 결과를 결합(combine)하는 과정을 지원합니다. 특히, 'plyr'은 'apply' 함수에 기반하여 데이터와 출력 변수를 동시에 배열로 치환하여 처리할 수 있는 기능을 제공합니다. 이는 데이터 프레임, 리스트, 배열 등 다양한 데이터 구조에 적용할 수 있어 유연한 데이터 처리가 가능합니다.<br>
<br>
1. MySql <br>
: MySql은 데이터베이스 관리 시스템(DBMS)으로, 주로 데이터 저장 및 관리에 사용됩니다. 데이터 처리보다는 데이터베이스 내에서 데이터를 저장하고 쿼리하는 데 중점을 둡니다. 따라서 데이터의 분리, 처리, 결합을 위한 R의 'plyr' 패키지와는 다른 목적을 가지고 있습니다.<br>
<br>
2. sqldf <br>
: sqldf는 R에서 SQL 명령어를 사용할 수 있게 해주는 패키지입니다. 이는 SQL 쿼리를 통해 데이터 프레임을 조작할 수 있도록 도와주지만, 'split-apply-combine' 전략을 기반으로 데이터를 처리하는 기능은 제공하지 않습니다. 따라서 'plyr' 패키지와는 다른 기능을 수행합니다.<br>
<br>
3. OLAP <br>
: OLAP(Online Analytical Processing)은 다차원 데이터 분석을 지원하는 기술로, 주로 데이터 웨어하우스에서 대량의 데이터를 분석하는 데 사용됩니다. 이는 데이터의 집계 및 분석에 중점을 두며, R의 'plyr' 패키지처럼 데이터를 분리하고 처리한 후 결합하는 기능을 직접적으로 제공하지 않습니다.<br>
<br>
4. plyr <br>
: plyr은 R에서 데이터를 분리하고 처리한 다음, 다시 결합하는 기능을 제공하는 패키지입니다. 'apply' 함수에 기반하여 데이터를 처리하며, 다양한 데이터 구조에 적용할 수 있는 유연성을 제공합니다. 이는 문제에서 요구하는 데이터 처리 기능과 일치합니다.<br>
<br>
정답은 'plyr'입니다. 'plyr' 패키지는 R에서 데이터를 분리하고 처리한 다음, 다시 결합하는 기능을 제공하며, 'apply' 함수에 기반하여 데이터를 처리합니다. 다른 선지들은 각각 데이터베이스 관리, SQL 쿼리 사용, 다차원 데이터 분석에 중점을 두고 있어 문제에서 요구하는 기능과는 다릅니다.<br>
따라서, 정답은 '4. plyr' 입니다.<br>
			</div>
			<div class="t2">
									#plyr									# split-apply-combine									# 데이터 처리									# R 패키지									# apply 함수							</div>
		</div>
		
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">4과목</span>
			<span class="g1">데이터변경 및 요약</span>
			<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">42.</span>
			<span class="tt1t1">
				데이터셋에서 결측치(Missing value)가 있는 경우, 처리하는 방법 중 가장 타당하지 않는 것은 어느 것인가?							</span>
		</strong>
		<span class="tt1t1">
				    </span> 
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			빅데이터 분석에서 결측치 처리는 먼저 결측치가 많은 변수를 처리하고 결측치가 포함된 레코드를 처리한다. 					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			결측치가 포함된 레코드는 모델링에서 다른 변수와의 영향도를 분석시 예상치 못한 결과를 생산하므로 무조건 삭제하고 전처리한다. 					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			데이터마이닝 모델링을 위한 데이터셋에서 결측치가 포함하지 않는 레코드 수가 10,000이상일 경우는 삭제한다. 					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			회귀분석을 활용한 통계 분석에서 데이터셋에 결측치가 포함된 레코드는 결측치가 많은 변수부터 삭제하는 것이 효과적이다.					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a42" class="b2 help" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a42" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">2</i>
			<span class="t2t1">
			결측치가 포함된 레코드는 모델링에서 다른 변수와의 영향도를 분석시 예상치 못한 결과를 생산하므로 무조건 삭제하고 전처리한다. 			</span>
					</div>
        <br>
				<strong class="tt1">해설</strong>
		<div class="t1">
		결측치가 포함된 레코드라고 무조건 삭제하는 것은 바람직하지 못하며 삭제하였을 경우, 분석 가능한 데이터를 확보할 수 있는 여부를 판단하는 것이 선행되어야 한다.				</div>
		
				
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				정답은 2번입니다.<br>
<br>
데이터 분석에서 결측치 처리는 매우 중요한 단계입니다. 결측치는 데이터셋에서 누락된 값으로, 분석 결과에 큰 영향을 미칠 수 있습니다. 결측치를 처리하는 방법에는 여러 가지가 있으며, 데이터의 특성과 분석 목적에 따라 적절한 방법을 선택해야 합니다. 일반적으로 결측치를 처리하는 방법에는 삭제, 대체, 예측 모델을 통한 보완 등이 있습니다. 결측치를 무조건 삭제하는 것은 데이터 손실을 초래할 수 있으며, 분석 결과의 신뢰성을 떨어뜨릴 수 있습니다. 따라서 결측치가 많은 변수나 레코드를 우선적으로 처리하고, 데이터의 패턴을 분석하여 적절한 방법을 선택하는 것이 중요합니다.<br>
<br>
1. 빅데이터 분석에서 결측치 처리는 먼저 결측치가 많은 변수를 처리하고 결측치가 포함된 레코드를 처리한다. <br>
: 결측치가 많은 변수를 먼저 처리하는 것은 데이터의 품질을 높이는 데 효과적입니다. 결측치가 많은 변수는 분석에 큰 영향을 미칠 수 있으므로, 이를 우선적으로 처리하여 데이터의 신뢰성을 높이는 것이 중요합니다. 예를 들어, 결측치가 많은 변수를 삭제하거나 대체하는 방법을 사용할 수 있습니다. 이는 데이터의 전체적인 품질을 높이고, 분석 결과의 신뢰성을 확보하는 데 도움이 됩니다.<br>
<br>
2. 결측치가 포함된 레코드는 모델링에서 다른 변수와의 영향도를 분석시 예상치 못한 결과를 생산하므로 무조건 삭제하고 전처리한다. <br>
: 결측치가 포함된 레코드를 무조건 삭제하는 것은 바람직하지 않습니다. 이는 데이터 손실을 초래할 수 있으며, 분석 가능한 데이터의 양을 줄일 수 있습니다. 결측치를 포함한 레코드가 다른 변수와의 관계에서 중요한 정보를 제공할 수 있기 때문에, 무조건 삭제하기보다는 대체하거나 예측 모델을 통해 보완하는 방법을 고려해야 합니다. 예를 들어, 평균값이나 중앙값으로 대체하거나, 회귀 분석을 통해 결측치를 예측할 수 있습니다.<br>
<br>
3. 데이터마이닝 모델링을 위한 데이터셋에서 결측치가 포함하지 않는 레코드 수가 10,000이상일 경우는 삭제한다. <br>
: 결측치가 포함되지 않은 레코드 수가 충분히 많을 경우, 결측치가 포함된 레코드를 삭제하는 것은 하나의 방법이 될 수 있습니다. 데이터셋의 크기가 충분히 크고, 결측치가 포함된 레코드가 분석에 큰 영향을 미치지 않는 경우, 이를 삭제하여 데이터의 품질을 높일 수 있습니다. 그러나 이 경우에도 결측치가 포함된 레코드가 중요한 정보를 포함하고 있는지 여부를 신중히 고려해야 합니다.<br>
<br>
4. 회귀분석을 활용한 통계 분석에서 데이터셋에 결측치가 포함된 레코드는 결측치가 많은 변수부터 삭제하는 것이 효과적이다. <br>
: 회귀분석에서 결측치가 많은 변수를 먼저 삭제하는 것은 데이터의 품질을 높이는 데 도움이 될 수 있습니다. 결측치가 많은 변수는 분석 결과에 큰 영향을 미칠 수 있으므로, 이를 우선적으로 처리하여 데이터의 신뢰성을 높이는 것이 중요합니다. 회귀분석에서는 결측치를 대체하거나 예측 모델을 통해 보완하는 방법도 고려할 수 있습니다.<br>
<br>
결측치가 포함된 레코드를 무조건 삭제하는 것은 데이터 손실을 초래할 수 있으며, 분석 가능한 데이터의 양을 줄일 수 있습니다. 이는 데이터 분석의 신뢰성을 떨어뜨릴 수 있기 때문에, 결측치를 대체하거나 예측 모델을 통해 보완하는 방법을 고려해야 합니다. 다른 선택지들은 결측치를 처리하는 데 있어 보다 신중하고 적절한 접근 방법을 제시하고 있습니다.<br>
따라서, 정답은 '2. 결측치가 포함된 레코드는 모델링에서 다른 변수와의 영향도를 분석시 예상치 못한 결과를 생산하므로 무조건 삭제하고 전처리한다.' 입니다.<br>
			</div>
			<div class="t2">
									#결측치 처리									# 데이터 품질									# 데이터 손실									# 대체 방법									# 예측 모델							</div>
		</div>
		
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">4과목</span>
			<span class="g1">주성분 분석</span>
			<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">43.</span>
			<span class="tt1t1">
				다음은 1973년 미국 50개 주의 100,000명의 인구당 체포된 강력범죄수와 각 주마다 도시에 거주하는 인구의 비율을 통해 주성분 분석을 한 결과이다. 제 2주성분까지 변수로 선택 시 전체 데이터의 몇 %를 설명할 수 있을까?							</span>
		</strong>
		<span class="tt1t1">
						<a href="exam1view1img1.php?img=07375a40-204d-b5eb-83b8-091e8a44bc97.png" target="_blank" rel="noopener" title="새 창" class="p1">
				<img src="/data/img/question/07375a40-204d-b5eb-83b8-091e8a44bc97.png" alt="문제에 포함된 이미지">
			</a>
				    </span> 
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			99.4%					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			86.8%					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			62.0%					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			24.7%					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a43" class="b2 help" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a43" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">2</i>
			<span class="t2t1">
			86.8%			</span>
					</div>
        <br>
				<strong class="tt1">해설</strong>
		<div class="t1">
		주성분 분석을 통한 설명력은 누적비율(Cumulative Proportion)을 활용하면 된다. 제 2주성분까지의 설명력은 Comp.2의 누적비율인 0.8675이고 제 2주성분까지 변수로 선택할 경우 전체 데이터의 86.8%를 설명하게 된다.				</div>
		
				
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				주성분 분석 결과에서 제 2주성분까지의 누적 설명력을 확인하면 됩니다. 제 1주성분의 설명력은 62.0%이고, 제 2주성분의 설명력은 24.7%입니다. 따라서 제 2주성분까지의 누적 설명력은 62.0% + 24.7% = 86.7%입니다. 주어진 보기 중 가장 가까운 값은 86.8%입니다.<br>
			</div>
			<div class="t2">
									# 주성분 분석									# 누적 설명력									# 제 1주성분									# 제 2주성분									# R 프로그램 결과해석							</div>
		</div>
		
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">4과목</span>
			<span class="g1">분류분석</span>
			<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">44.</span>
			<span class="tt1t1">
				데이터 마이닝 분석 기법 중 의사결정나무의 활용 예가 아닌 것은?							</span>
		</strong>
		<span class="tt1t1">
				    </span> 
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			세분화(Segmentation)					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			분류(Classification)					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			예측(Prediction) 					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			연관성 분석(Association Analysis)					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a44" class="b2 help" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a44" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">4</i>
			<span class="t2t1">
			연관성 분석(Association Analysis)			</span>
					</div>
        <br>
				<strong class="tt1">해설</strong>
		<div class="t1">
		데이터마이닝 분석 기법 중 의사결정나무의 활용의 예는 세분화, 분류, 예측, 차원축소 및 변수선택, 교호작용효과의 파악, 범주의 병합 또는 연속형 변수의 이산화 등이 있다.				</div>
		
				
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				정답은 4번입니다.<br>
<br>
의사결정나무는 데이터 마이닝에서 널리 사용되는 기법으로, 주로 분류(Classification)와 예측(Prediction) 문제를 해결하는 데 사용됩니다. 이 기법은 데이터를 여러 기준에 따라 분할하여 의사결정 규칙을 생성합니다. 의사결정나무는 하향식 접근법을 사용하여 데이터를 분할하며, 각 단계에서 가장 적합한 기준을 선택하여 데이터를 나누는 방식으로 작동합니다. 이 과정에서 과대적합을 방지하기 위해 가지치기(pruning) 등의 기법이 사용됩니다. 의사결정나무는 분류와 예측 외에도 세분화(Segmentation) 작업에 활용될 수 있지만, 연관성 분석(Association Analysis)에는 일반적으로 사용되지 않습니다. 연관성 분석은 주로 데이터 내 항목 간의 관계를 찾는 데 중점을 두며, 의사결정나무와는 다른 알고리즘을 사용합니다.<br>
<br>
1. 세분화(Segmentation) <br>
: 세분화(Segmentation)는 데이터를 유사한 특성을 가진 그룹으로 나누는 작업입니다. 의사결정나무는 데이터를 분할하는 특성 때문에 세분화 작업에 활용될 수 있습니다. 이는 데이터를 여러 기준에 따라 나누어 각 그룹의 특성을 파악하는 데 유용합니다.<br>
<br>
2. 분류(Classification) <br>
: 분류(Classification)는 의사결정나무의 대표적인 활용 분야입니다. 이 기법은 데이터를 미리 정의된 범주로 나누는 데 사용되며, 각 노드에서 데이터를 분할하여 최종적으로 특정 범주에 속하는지를 결정합니다. 의사결정나무는 이러한 분류 작업에 매우 효과적입니다.<br>
<br>
3. 예측(Prediction) <br>
: 예측(Prediction)은 의사결정나무가 데이터를 기반으로 미래의 값을 예측하는 데 사용되는 방법입니다. 이 기법은 과거 데이터를 분석하여 미래의 결과를 예측하는 데 유용하며, 회귀 분석과 같은 방식으로 활용될 수 있습니다.<br>
<br>
4. 연관성 분석(Association Analysis) <br>
: 연관성 분석(Association Analysis)은 데이터 내 항목 간의 관계를 찾는 데 중점을 둡니다. 이는 주로 장바구니 분석과 같은 분야에서 사용되며, 의사결정나무와는 다른 알고리즘을 사용합니다. 따라서 연관성 분석은 의사결정나무의 일반적인 활용 예가 아닙니다.<br>
<br>
의사결정나무는 주로 분류, 예측, 세분화와 같은 작업에 사용됩니다. 이는 데이터를 분할하여 규칙을 생성하는 데 적합하기 때문입니다. 반면, 연관성 분석은 데이터 내 항목 간의 관계를 찾는 데 중점을 두며, 의사결정나무와는 다른 알고리즘을 사용합니다. 따라서 연관성 분석은 의사결정나무의 활용 예가 아닙니다.<br>
<br>
따라서, 정답은 '4. 연관성 분석(Association Analysis)' 입니다.<br>
			</div>
			<div class="t2">
									#의사결정나무									# 분류									# 예측									# 세분화									# 연관성 분석							</div>
		</div>
		
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">4과목</span>
			<span class="g1">분류분석</span>
			<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">45.</span>
			<span class="tt1t1">
				다음 중 아래 집단의 지니 지수를 구한 것은 무엇인가?							</span>
		</strong>
		<span class="tt1t1">
						<a href="exam1view1img1.php?img=ffd4a44e-c337-592b-6b2c-462fd59f1d57.png" target="_blank" rel="noopener" title="새 창" class="p1">
				<img src="/data/img/question/ffd4a44e-c337-592b-6b2c-462fd59f1d57.png" alt="문제에 포함된 이미지">
			</a>
				    </span> 
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			0					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			10/25					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			12/25					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			14/25					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a45" class="b2 help" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a45" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">3</i>
			<span class="t2t1">
			12/25			</span>
					</div>
        <br>
				<strong class="tt1">해설</strong>
		<div class="t1">
		지니 지수를 구한 결과는 (1-{left({2over 5}right)}^{2}-{left({3over 5}right)}^{2}={12 over 25})이다.				</div>
		
				
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				지니 지수(Gini coefficient)는 소득 분포의 불평등도를 나타내는 지표로, 0은 완전 평등, 1은 완전 불평등을 의미합니다. 주어진 집단의 지니 지수를 계산하기 위해서는 각 요소의 빈도를 확인하고, 이를 바탕으로 지니 지수를 계산해야 합니다.<br>
<br>
주어진 집단에서 십자가(+)는 3개, 원(O)은 2개입니다. 이를 바탕으로 지니 지수를 계산하면 다음과 같습니다:<br>
<br>
1. 각 요소의 빈도: 십자가(+) = 3/5, 원(O) = 2/5<br>
2. 지니 지수 공식: ( G = 1 - sum (p_i)^2 )<br>
3. 십자가(+)와 원(O)의 빈도를 대입: ( G = 1 - [(3/5)^2 + (2/5)^2] )<br>
4. 계산: ( G = 1 - [9/25 + 4/25] = 1 - 13/25 = 12/25 )<br>
<br>
따라서, 정답은 12/25입니다.<br>
			</div>
			<div class="t2">
									# 지니 지수									# 소득 분포									# 불평등도									# 완전 평등									# 완전 불평등							</div>
		</div>
		
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">4과목</span>
			<span class="g1">군집분석</span>
			<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">46.</span>
			<span class="tt1t1">
				계층적 군집분석 방법론 중 군집을 생성할 때 거리를 정의하는 방법이 아닌 것은?							</span>
		</strong>
		<span class="tt1t1">
				    </span> 
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			최단연결법					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			최장연결법					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			중간연결법					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			와드연결법					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a46" class="b2 help" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a46" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">3</i>
			<span class="t2t1">
			중간연결법			</span>
					</div>
        <br>
				<strong class="tt1">해설</strong>
		<div class="t1">
		군집을 생성할 때 거리를 정의하는 방법은 최단연결법, 최장연결법, 평균연결법, 와드연결법이 있다. 				</div>
		
				
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				정답은 3번입니다.<br>
<br>
계층적 군집분석은 데이터를 유사성에 따라 계층적으로 묶어가는 방법입니다. 이 방법은 크게 두 가지로 나뉘는데, 합병형 방법(Agglomerative)과 분리형 방법(Divisive)이 있습니다. 합병형 방법은 개별 데이터를 시작으로 가장 유사한 데이터부터 차례로 묶어가며 군집을 형성합니다. 이 과정에서 군집 간의 거리를 정의하는 방법이 중요한데, 대표적으로 최단연결법(Single Linkage), 최장연결법(Complete Linkage), 평균연결법(Average Linkage), 와드연결법(Ward's Method) 등이 있습니다. 각 방법은 군집 간의 거리를 계산하는 방식이 다르며, 군집의 형성에 영향을 미칩니다.<br>
<br>
1. 최단연결법 <br>
: 최단연결법은 군집 간의 거리를 계산할 때 두 군집에서 가장 가까운 두 점 사이의 거리를 사용합니다. 이 방법은 군집이 길게 늘어지는 경향이 있어, 노이즈나 이상치에 민감할 수 있습니다. 예를 들어, 두 군집 A와 B가 있을 때, A의 한 점과 B의 한 점 사이의 거리가 가장 짧다면 그 거리를 군집 간 거리로 사용합니다.<br>
<br>
2. 최장연결법 <br>
: 최장연결법은 두 군집 간의 거리를 계산할 때 가장 먼 두 점 사이의 거리를 사용합니다. 이 방법은 군집이 보다 구형에 가깝게 형성되도록 하며, 노이즈에 덜 민감합니다. 예를 들어, 두 군집 A와 B가 있을 때, A의 한 점과 B의 한 점 사이의 거리가 가장 길다면 그 거리를 군집 간 거리로 사용합니다.<br>
<br>
3. 중간연결법 <br>
: 중간연결법은 군집 간의 거리를 정의하는 방법으로 일반적으로 사용되지 않습니다. 계층적 군집분석에서 주로 사용되는 방법은 최단연결법, 최장연결법, 평균연결법, 와드연결법 등입니다. 따라서 중간연결법은 군집 간 거리를 정의하는 방법이 아닙니다.<br>
<br>
4. 와드연결법 <br>
: 와드연결법은 군집 내 편차의 제곱합을 최소화하는 방향으로 군집을 형성합니다. 이는 군집 간의 정보 손실을 최소화하려는 방법으로, 군집이 보다 균일한 크기를 가지도록 합니다. 예를 들어, 두 군집을 합쳤을 때의 분산 증가량이 최소가 되도록 군집을 형성합니다.<br>
<br>
중간연결법은 계층적 군집분석에서 군집 간의 거리를 정의하는 방법으로 사용되지 않습니다. 최단연결법, 최장연결법, 평균연결법, 와드연결법은 각각 군집 간의 거리를 정의하는 명확한 방법을 가지고 있지만, 중간연결법은 그러한 정의가 없기 때문에 정답은 3번입니다.<br>
<br>
따라서, 정답은 '3. 중간연결법' 입니다.<br>
			</div>
			<div class="t2">
									#계층적 군집분석									# 최단연결법									# 최장연결법									# 와드연결법									# 중간연결법							</div>
		</div>
		
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">4과목</span>
			<span class="g1">연관분석</span>
			<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">47.</span>
			<span class="tt1t1">
				연관성분석의 측도 중 “P(A∩B)=(A와 B가 동시에 포함된 거래수)/전체 거래수”를 나타내는 측도는 무엇인가?							</span>
		</strong>
		<span class="tt1t1">
				    </span> 
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			지지도(Support)					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			신뢰도(Confidence)					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			향상도(Lift)					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			정확도(Accuracy)					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a47" class="b2 help" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a47" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">1</i>
			<span class="t2t1">
			지지도(Support)			</span>
					</div>
        <br>
				<strong class="tt1">해설</strong>
		<div class="t1">
		간단히 말하면 A→B인 경우, 전체 TRANSACTION(POS 데이터에서는 영수증번호로, 카드사에서는 카드 전표 1장으로 생각하면 된다. POS 데이터에는 여러 아이템이 하나의 POS 트랜잭션에 연결돼 있음)에서 A만 사거나 B만 사거나 A와 B를 같이 구매한 경우, ABC를 같이 구매한 경우 등 트랜잭션에서 A또는 B가 들어간 트랜잭션 개수의 비율이다. 즉, 얼마나 빈번하게 나타나는 경우인지를 설명하는 상대적인 값이다.				</div>
		
				
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				정답은 1번입니다.<br>
<br>
연관성분석에서 거래 내에서 두 항목이 동시에 발생하는 빈도를 측정하는 것이 중요합니다. 이는 데이터 마이닝에서 패턴을 발견하는 데 사용됩니다.<br>
<br>
1. 지지도(Support)<br>
: 두 항목이 동시에 발생하는 빈도를 전체 거래 수로 나눈 값을 나타내며, 이는 두 항목이 함께 나타나는 정도를 측정하는 데 사용됩니다.<br>
<br>
2. 신뢰도(Confidence)<br>
: 한 항목이 발생했을 때 다른 항목이 발생할 확률을 나타내며, 이는 조건부 확률의 개념을 사용합니다.<br>
<br>
3. 향상도(Lift)<br>
: 두 항목의 발생이 서로 독립적인지 여부를 판단하는 데 사용되며, 두 항목의 결합 확률을 각 항목의 개별 확률로 나눈 값입니다.<br>
<br>
4. 정확도(Accuracy)<br>
: 모델의 예측이 얼마나 정확한지를 나타내는 지표로, 전체 예측 중에서 올바르게 예측한 비율을 의미합니다.<br>
<br>
<br>
문제에서 묻는 것은 두 항목이 동시에 발생하는 빈도를 전체 거래 수로 나눈 값입니다. 이는 지지도를 의미합니다. 다른 선택지들은 각각 신뢰도, 향상도, 정확도와 관련된 개념으로, 문제에서 요구하는 개념과는 다릅니다.<br>
<br>
따라서, 정답은 '1. 지지도(Support)' 입니다.<br>
			</div>
			<div class="t2">
									#지지도									# 신뢰도									# 향상도									# 정확도							</div>
		</div>
		
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">4과목</span>
			<span class="g1">분류분석</span>
			<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">48.</span>
			<span class="tt1t1">
				다음 중 의사결정나무의 특징으로 틀린 것은?							</span>
		</strong>
		<span class="tt1t1">
				    </span> 
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			누구에게나 결과를 설명하기에 용이하다.					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			모형을 만드는 방법이 계산적으로 복잡하지 않다.					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			대용량 데이터에서도 빠르게 만들 수 있다.					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			비정상 잡음 데이터에 대해서는 민감함이 있어 따로 분류하기 힘들다.					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a48" class="b2 help" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a48" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">4</i>
			<span class="t2t1">
			비정상 잡음 데이터에 대해서는 민감함이 있어 따로 분류하기 힘들다.			</span>
					</div>
        <br>
				<strong class="tt1">해설</strong>
		<div class="t1">
		의사결정나무는 변수에 이상치가 포함되어 있는 비정상 잡음 데이터에 대해서도 민감하지 않게 분류할 수 있다. 				</div>
		
				
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				1. 의사결정나무의 장점 중 하나로, 결과를 누구에게나 설명하기 용이합니다.<br>
<br>
2. 의사결정나무의 장점 중 하나로, 모형을 만드는 방법이 계산적으로 복잡하지 않습니다.<br>
<br>
3. 의사결정나무의 장점 중 하나로, 대용량 데이터에서도 빠르게 만들 수 있습니다.<br>
<br>
4. 의사결정나무는 한 변수와 상관성이 높은 다른 불필요한 변수가 있어도 크게 영향을 받지 않으므로, 해당 설명은 틀린 보기입니다.<br>
			</div>
			<div class="t2">
									# 의사결정나무									# 의사결정나무의 특징							</div>
		</div>
		
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">4과목</span>
			<span class="g1">고급회귀분석</span>
			<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">49.</span>
			<span class="tt1t1">
				변수들 간에 높은 상관성이 있는 것들이 회귀모형에 포함될 경우 다중공선성(multicollinearity)의 문제가 발생한다. 이러한 문제점에 대한 해결방안으로 가장 부적절한 것은?							</span>
		</strong>
		<span class="tt1t1">
				    </span> 
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			중요하지 않으면서 다른 변수와 상관성이 높은 변수를 제거한다. 					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			구조적 다중공선성의 문제가 있는 경우에는 데이터의 평균 중심을 변화한다. 					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			상관관계가 낮아지도록 변수 값을 조정한다. 					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			VIF(Variance Inflation factor)를 이용하여 다중공선성이 존재하는지 파악한다.					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a49" class="b2 help" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a49" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">3</i>
			<span class="t2t1">
			상관관계가 낮아지도록 변수 값을 조정한다. 			</span>
					</div>
        <br>
				<strong class="tt1">해설</strong>
		<div class="t1">
		분석에 있어서 상관관계 값이 크다고 해서 변수 값을 조정하면 안된다. 				</div>
		
				
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				다중공선성 문제를 해결하기 위해서는 일반적으로 변수 선택, 변수 변환, 또는 변수 제거 등의 방법을 사용합니다. <br>
<br>
-1번 선택지는 중요하지 않으면서 다른 변수와 상관성이 높은 변수를 제거하는 방법으로, 다중공선성을 줄이는 데 <br>
  효과적입니다.<br>
<br>
-2번 선택지는 구조적 다중공선성의 문제를 해결하기 위해 데이터의 평균 중심을 변화시키는 방법으로, 이는 변수의 스케일을 <br>
  조정하여 다중공선성을 줄일 수 있습니다.<br>
   <br>
-4번 선택지는 VIF를 이용하여 다중공선성이 존재하는지 파악하는 방법으로, 다중공선성을 진단하는 데 유용합니다.<br>
<br>
 그러나 3번 선택지인 "상관관계가 낮아지도록 변수 값을 조정한다"는 다중공선성을 해결하는 구체적인 방법으로는 <br>
 적절하지 않습니다. 상관관계를 낮추기 위해 변수 값을 조정하는 것은 현실적으로 어려우며, 구체적인 방법론이 부족합니다.<br>
<br>
			</div>
			<div class="t2">
									# 다중공선성									# 회귀모형									# 변수 제거									# 평균 중심 변화									# VIF									# 상관관계 조정							</div>
		</div>
		
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">4과목</span>
			<span class="g1">군집분석</span>
			<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">50.</span>
			<span class="tt1t1">
				아래는 22개의 미국 전투기에 대한 4개의 변수 값을 사용한 군집분석의 결과이다. 이에 대한 설명 중 부적절한 것은?							</span>
		</strong>
		<span class="tt1t1">
						<a href="exam1view1img1.php?img=716f892b-6c46-754f-f20f-930c68fe2dc4.png" target="_blank" rel="noopener" title="새 창" class="p1">
				<img src="/data/img/question/716f892b-6c46-754f-f20f-930c68fe2dc4.png" alt="문제에 포함된 이미지">
			</a>
				    </span> 
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			계층적 군집분석의 결과이다.					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			위의 방법을 사용할 때 군집 개수를 사전에 결정해야 한다. 					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			각 군집은 7개, 9개, 6개의 전투기를 포함한다.					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			각 군집의 중심에 대한 정보가 포함되어 있다.					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a50" class="b2 help" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a50" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">1</i>
			<span class="t2t1">
			계층적 군집분석의 결과이다.			</span>
					</div>
        <br>
				<strong class="tt1">해설</strong>
		<div class="t1">
		주어진 결과는 k-means 군집분석의 결과로, 이는 비계층적 군집분석 방법이다.				</div>
		
				
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				정답은 1번입니다.<br>
<br>
군집분석은 데이터를 유사한 특성을 가진 그룹으로 나누는 기법입니다. 크게 계층적 군집분석과 비계층적 군집분석으로 나뉩니다. 계층적 군집분석은 데이터 간의 거리나 유사도를 기반으로 트리 형태의 덴드로그램을 생성하여 군집을 형성합니다. 반면, 비계층적 군집분석은 사전에 군집의 개수를 정하고 데이터를 해당 군집으로 나누는 방식입니다. K-means는 대표적인 비계층적 군집분석 기법으로, 각 데이터 포인트를 가장 가까운 군집 중심에 할당하여 군집을 형성합니다. 주어진 문제에서는 K-means 군집분석 결과가 제공되었으며, 각 군집의 크기와 중심에 대한 정보가 포함되어 있습니다.<br>
<br>
1. 계층적 군집분석의 결과이다. <br>
: 계층적 군집분석은 데이터 간의 유사성을 기반으로 트리 구조를 형성하여 군집을 형성합니다. 이는 사전에 군집의 개수를 정하지 않으며, 덴드로그램을 통해 군집의 수를 결정할 수 있습니다. 주어진 문제는 K-means 군집분석 결과로, 이는 비계층적 방법입니다.<br>
<br>
2. 위의 방법을 사용할 때 군집 개수를 사전에 결정해야 한다. <br>
: K-means와 같은 비계층적 군집분석은 사전에 군집의 개수를 정해야 합니다. 이는 알고리즘이 각 데이터 포인트를 미리 정해진 군집 중심에 할당하여 군집을 형성하기 때문입니다.<br>
<br>
3. 각 군집은 7개, 9개, 6개의 전투기를 포함한다. <br>
: K-means 군집분석 결과에서 각 군집의 크기가 7, 6, 9로 나와 있습니다. 이는 각 군집에 포함된 데이터 포인트의 수를 의미하며, 주어진 결과와 일치합니다.<br>
<br>
4. 각 군집의 중심에 대한 정보가 포함되어 있다. <br>
: K-means 군집분석 결과에는 각 군집의 중심에 대한 정보가 포함됩니다. 이는 각 군집의 평균값을 나타내며, 군집의 특성을 이해하는 데 도움을 줍니다.<br>
<br>
주어진 문제는 K-means 군집분석 결과를 기반으로 하고 있습니다. K-means는 비계층적 군집분석 기법으로, 사전에 군집의 개수를 정해야 하며, 각 군집의 중심에 대한 정보가 포함됩니다. 따라서 계층적 군집분석이라는 설명은 부적절합니다.<br>
<br>
따라서, 정답은 '1. 계층적 군집분석의 결과이다.' 입니다.<br>
			</div>
			<div class="t2">
									#군집분석									# 계층적 군집분석									# 비계층적 군집분석									# K-means									# 군집 중심							</div>
		</div>
		
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">4과목</span>
			<span class="g1">데이터 마이닝 개요</span>
			<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">51.</span>
			<span class="tt1t1">
				다음 중 아래 오분류표를 이용하여 재현율(Recall)을 구한 것은 무엇인가?							</span>
		</strong>
		<span class="tt1t1">
						<a href="exam1view1img1.php?img=79bbf142-a4b0-38a1-c1c4-8f787ebaa465.png" target="_blank" rel="noopener" title="새 창" class="p1">
				<img src="/data/img/question/79bbf142-a4b0-38a1-c1c4-8f787ebaa465.png" alt="문제에 포함된 이미지">
			</a>
				    </span> 
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			0.15					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			0.3					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			0.4					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			0.55					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a51" class="b2 help" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a51" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">3</i>
			<span class="t2t1">
			0.4			</span>
					</div>
        <br>
				<strong class="tt1">해설</strong>
		<div class="t1">
		재현율을 구하면 ({TP over TP+FN}={40 over 40+60}=0.4)이다.				</div>
		
				
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				정답은 3번입니다.<br>
<br>
재현율(Recall)은 모델이 실제로 긍정인 경우 중에서 얼마나 잘 예측했는지를 나타내는 지표입니다. 이는 민감도(Sensitivity)와 동일한 개념으로, 수식은 TP / (TP + FN)으로 계산됩니다. 여기서 TP는 True Positive, FN은 False Negative를 의미합니다. 주어진 오분류표에서 TP는 '실제값이 True이고 예측도 True인 경우'로 40이며, FN은 '실제값이 True인데 예측이 False인 경우'로 60입니다. 따라서 재현율은 40 / (40 + 60) = 0.4가 됩니다.<br>
<br>
1. 0.15 <br>
: 재현율을 계산할 때 TP와 FN의 값을 잘못 대입하면 오답이 나올 수 있습니다. 이 경우 0.15는 TP와 FN의 비율을 잘못 계산한 결과입니다. 재현율은 TP / (TP + FN)으로 계산해야 하며, 이 경우 40 / 100이 되어야 합니다.<br>
<br>
2. 0.3 <br>
: 0.3은 TP와 FN의 비율을 잘못 계산한 결과입니다. 재현율은 TP / (TP + FN)으로 계산해야 하며, 이 경우 40 / 100이 되어야 합니다.<br>
<br>
3. 0.4 <br>
: 이 값은 재현율을 올바르게 계산한 결과입니다. TP는 40, FN은 60이므로, 재현율은 40 / (40 + 60) = 0.4입니다.<br>
<br>
4. 0.55 <br>
: 0.55는 TP와 FN의 비율을 잘못 계산한 결과입니다. 재현율은 TP / (TP + FN)으로 계산해야 하며, 이 경우 40 / 100이 되어야 합니다.<br>
<br>
재현율은 TP / (TP + FN)으로 계산되며, 주어진 오분류표에서 TP는 40, FN은 60입니다. 따라서 재현율은 40 / (40 + 60) = 0.4가 되어야 합니다. 다른 선택지들은 이 계산을 잘못 적용한 결과입니다.<br>
<br>
따라서, 정답은 '3. 0.4' 입니다.<br>
			</div>
			<div class="t2">
									#재현율									# 민감도									# 오분류표									# TP									# FN							</div>
		</div>
		
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">4과목</span>
			<span class="g1">군집분석</span>
			<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">52.</span>
			<span class="tt1t1">
				다음 중 k-means 군집의 단점으로 가장 부적절한 것은? 							</span>
		</strong>
		<span class="tt1t1">
				    </span> 
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			잡음이나 이상값에 영향을 많이 받는다. 					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			전체 최적화가 보장되지는 않는다.					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			볼록한 형태가 아닌 군집이 존재하면 성능이 떨어진다.					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			한번 군집이 형성되면 군집 내 객체들은 다른 군집으로 이동 할 수 없다.					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a52" class="b2 help" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a52" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">4</i>
			<span class="t2t1">
			한번 군집이 형성되면 군집 내 객체들은 다른 군집으로 이동 할 수 없다.			</span>
					</div>
        <br>
				<strong class="tt1">해설</strong>
		<div class="t1">
		k-means 군집은 초기 중심값의 선정에 따라 결과가 달라질 수 있다.				</div>
		
				
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				정답은 4번입니다.<br>
<br>
k-means 군집 분석은 비계층적 군집 분석의 대표적인 방법으로, 주어진 데이터 집합을 k개의 군집으로 나누는 알고리즘입니다. 이 방법은 각 데이터 포인트를 가장 가까운 군집 중심에 할당하여 군집을 형성합니다. k-means의 주요 특징은 초기 중심값의 선택에 따라 결과가 달라질 수 있으며, 군집의 수를 미리 정해야 한다는 점입니다. 또한, 거리 계산을 통해 군집화가 이루어지므로 연속형 변수에 적합합니다. 그러나 잡음이나 이상값에 민감하고, 볼록한 형태가 아닌 군집에서는 성능이 떨어질 수 있습니다. 이는 초기 중심값의 선택과 군집의 형태에 따라 최적의 결과를 보장하지 못할 수 있음을 의미합니다.<br>
<br>
1. 잡음이나 이상값에 영향을 많이 받는다. <br>
: k-means 군집 분석은 잡음이나 이상값에 민감합니다. 이는 군집 중심을 계산할 때 모든 데이터 포인트를 고려하기 때문입니다. 이상값은 군집 중심을 왜곡시켜 잘못된 군집 형성을 초래할 수 있습니다. 따라서, 이 점은 k-means의 단점으로 적절합니다.<br>
<br>
2. 전체 최적화가 보장되지는 않는다. <br>
: k-means는 탐욕적 알고리즘으로, 초기 중심값에 따라 결과가 달라질 수 있으며, 전체 최적화를 보장하지 않습니다. 이는 지역 최적해에 수렴할 수 있음을 의미합니다. 따라서, 이 점은 k-means의 단점으로 적절합니다.<br>
<br>
3. 볼록한 형태가 아닌 군집이 존재하면 성능이 떨어진다. <br>
: k-means는 볼록한 형태의 군집에 적합하며, 비볼록(non-convex) 형태의 군집에서는 성능이 떨어질 수 있습니다. 이는 군집의 형태가 복잡할 경우, 군집 중심이 적절히 배치되지 않을 수 있음을 의미합니다. 따라서, 이 점은 k-means의 단점으로 적절합니다.<br>
<br>
4. 한번 군집이 형성되면 군집 내 객체들은 다른 군집으로 이동 할 수 없다. <br>
: k-means는 반복적으로 군집 중심을 재계산하고, 각 데이터 포인트를 가장 가까운 군집 중심에 재할당합니다. 따라서, 군집 내 객체들은 다른 군집으로 이동할 수 있습니다. 이 점은 k-means의 단점으로 부적절합니다.<br>
<br>
선지 4는 k-means의 단점으로 부적절합니다. k-means는 반복적인 재할당 과정을 통해 데이터 포인트가 다른 군집으로 이동할 수 있도록 설계되어 있습니다. 반면, 나머지 선지들은 k-means의 단점으로 적절합니다. 잡음이나 이상값에 민감하고, 전체 최적화를 보장하지 않으며, 비볼록 형태의 군집에서는 성능이 떨어질 수 있습니다.<br>
따라서, 정답은 '4. 한번 군집이 형성되면 군집 내 객체들은 다른 군집으로 이동 할 수 없다.' 입니다.<br>
			</div>
			<div class="t2">
									#k-means									# 군집 분석									# 이상값									# 최적화									# 볼록 형태									# 군집 재할당							</div>
		</div>
		
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">4과목</span>
			<span class="g1">연관분석</span>
			<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">53.</span>
			<span class="tt1t1">
				연관성분석의 측도로 향상도에 대해 올바른 것은? 							</span>
		</strong>
		<span class="tt1t1">
				    </span> 
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			A가 주어지지 않았을 때의 품목 B의 확률에 비해 A가 주어졌을 때의 품목 B의 확률의 증가 비율					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			항목 A를 포함한 거래 중에서 항목 A와 항목 B가 같이 포함될 확률 					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			전체 거래 중 항목 A와 항목 B를 동시에 포함하는 거래의 비율 					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			품목 A와 품목 B의 구매가 서로 관련이 있는 경우에 향상도가 1이 됨 					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a53" class="b2 help" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a53" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">1</i>
			<span class="t2t1">
			A가 주어지지 않았을 때의 품목 B의 확률에 비해 A가 주어졌을 때의 품목 B의 확률의 증가 비율			</span>
					</div>
        <br>
				<strong class="tt1">해설</strong>
		<div class="t1">
		연관분석의 향상도(Lift)는 “A가 주어지지 않았을 때의 품목 B의 확률에 비해 A가 주어졌을 때의 품목 B의 확률의 증가비율”을 의미한다. 				</div>
		
				
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				정답은 1번입니다.<br>
<br>
연관성분석에서 향상도는 두 품목 A와 B의 연관성을 측정하는 지표입니다. 향상도는 품목 A가 주어졌을 때 품목 B가 발생할 확률이, 품목 A가 주어지지 않았을 때의 확률보다 얼마나 증가했는지를 나타냅니다. 수식으로는 향상도 = P(B|A) / P(B)로 표현되며, 여기서 P(B|A)는 A가 주어졌을 때 B가 발생할 확률, P(B)는 B가 발생할 확률입니다. 향상도가 1보다 크면 A와 B 사이에 양의 연관성이 있음을 의미하고, 1이면 독립적이며, 1보다 작으면 음의 연관성이 있음을 나타냅니다.<br>
<br>
1. A가 주어지지 않았을 때의 품목 B의 확률에 비해 A가 주어졌을 때의 품목 B의 확률의 증가 비율 <br>
: 선지 1은 향상도의 정의를 정확히 설명하고 있습니다. 향상도는 A가 주어졌을 때 B의 발생 확률이 A가 주어지지 않았을 때의 B의 발생 확률에 비해 얼마나 증가했는지를 나타내는 비율입니다. 이는 향상도의 본질적인 개념을 잘 설명하고 있습니다.<br>
<br>
2. 항목 A를 포함한 거래 중에서 항목 A와 항목 B가 같이 포함될 확률 <br>
: 선지 2는 신뢰도(Confidence)에 대한 설명입니다. 신뢰도는 A를 포함한 거래 중에서 A와 B가 함께 포함될 확률을 의미합니다. 이는 향상도와는 다른 개념으로, 향상도는 두 확률의 비율을 나타내지만, 신뢰도는 특정 조건 하에서의 발생 확률을 나타냅니다.<br>
<br>
3. 전체 거래 중 항목 A와 항목 B를 동시에 포함하는 거래의 비율 <br>
: 선지 3은 지지도(Support)에 대한 설명입니다. 지지도는 전체 거래 중 A와 B가 동시에 포함되는 거래의 비율을 의미합니다. 이는 향상도와는 다른 개념으로, 향상도는 두 확률의 비율을 나타내지만, 지지도는 단순히 두 항목이 동시에 발생하는 빈도를 나타냅니다.<br>
<br>
4. 품목 A와 품목 B의 구매가 서로 관련이 있는 경우에 향상도가 1이 됨 <br>
: 선지 4는 잘못된 설명입니다. 향상도가 1이 되는 경우는 A와 B가 서로 독립적일 때입니다. 즉, A의 발생이 B의 발생에 영향을 미치지 않는 경우입니다. 따라서 이 설명은 향상도의 개념을 잘못 이해한 것입니다.<br>
<br>
정답은 1번입니다. 향상도는 A가 주어졌을 때 B의 발생 확률이 A가 주어지지 않았을 때의 B의 발생 확률에 비해 얼마나 증가했는지를 나타내는 비율입니다. 2번은 신뢰도에 대한 설명이고, 3번은 지지도에 대한 설명이며, 4번은 향상도가 1일 때의 의미를 잘못 설명하고 있습니다.<br>
<br>
따라서, 정답은 '1. A가 주어지지 않았을 때의 품목 B의 확률에 비해 A가 주어졌을 때의 품목 B의 확률의 증가 비율' 입니다.<br>
			</div>
			<div class="t2">
									#향상도									# 연관성분석									# 신뢰도									# 지지도									# 확률							</div>
		</div>
		
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">4과목</span>
			<span class="g1">군집분석</span>
			<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">54.</span>
			<span class="tt1t1">
				아래는 계층적 군집분석을 진행하기 위한 거리행렬이다. 아래 표에서 가장 먼저 군집으로 묶어지는 점을 고르시오.							</span>
		</strong>
		<span class="tt1t1">
						<a href="exam1view1img1.php?img=471b5603-09ef-32e6-c79e-eaea842ccf33.png" target="_blank" rel="noopener" title="새 창" class="p1">
				<img src="/data/img/question/471b5603-09ef-32e6-c79e-eaea842ccf33.png" alt="문제에 포함된 이미지">
			</a>
				    </span> 
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			ad					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			bc					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			bd					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			de					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a54" class="b2 help" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a54" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">4</i>
			<span class="t2t1">
			de			</span>
					</div>
        <br>
				<strong class="tt1">해설</strong>
		<div class="t1">
		계층적 군집분석에서 군집을 묶는 순서는 거리가 가장 짧은 노드들을 하나의 군집으로 선택하고 다음에 나머지 노드들을 최장거리순 혹은 최단거리순으로 묶을지 결정을 하고 묶어 나간다. 두 지점의 거리가 가장 짧은 노드는 d와 e이며 거리는 5.00이다.				</div>
		
				
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				정답은 4번입니다.<br>
<br>
계층적 군집분석은 데이터의 유사성을 기반으로 계층 구조를 형성하는 방법입니다. 이 방법은 주로 거리 행렬을 사용하여 가장 가까운 두 개체를 하나의 군집으로 묶는 방식으로 진행됩니다. 주어진 거리 행렬에서 가장 작은 거리를 찾고, 해당 거리에 해당하는 두 개체를 먼저 군집으로 묶습니다. 이 과정을 반복하여 모든 개체가 하나의 군집이 될 때까지 진행합니다. [참고 문서]에 따르면, 가장 짧은 거리를 가진 노드들이 먼저 군집으로 묶이게 됩니다. [보기 이미지]에서 제공된 거리 행렬을 통해 가장 짧은 거리를 가진 두 점을 찾아 군집을 형성하는 것이 문제의 핵심입니다.<br>
<br>
1. ad <br>
: 거리 행렬에서 a와 d의 거리는 10.00입니다. 이는 다른 거리들에 비해 짧지 않으므로 가장 먼저 군집으로 묶이지 않습니다. 계층적 군집분석에서는 가장 짧은 거리를 우선적으로 선택합니다.<br>
<br>
2. bc <br>
: b와 c의 거리는 29.00으로, 주어진 거리 중 가장 큰 값입니다. 따라서 이 두 점은 가장 나중에 군집으로 묶이게 됩니다. 계층적 군집분석의 원리를 이해하면, 가장 큰 거리는 우선순위에서 밀리게 됩니다.<br>
<br>
3. bd <br>
: b와 d의 거리는 8.00입니다. 이는 비교적 짧은 거리이지만, e와 d의 거리인 5.00보다는 깁니다. 따라서 b와 d는 e와 d가 군집으로 묶인 후에 고려됩니다.<br>
<br>
4. de <br>
: d와 e의 거리는 5.00으로, 주어진 거리 중 가장 짧습니다. 따라서 계층적 군집분석의 원리에 따라 가장 먼저 군집으로 묶입니다. 이는 [참고 문서]에서도 언급된 바와 같이 가장 짧은 거리를 우선적으로 선택하는 방법에 부합합니다.<br>
<br>
d와 e의 거리가 5.00으로 가장 짧기 때문에, 계층적 군집분석의 원리에 따라 이 두 점이 가장 먼저 군집으로 묶입니다. 다른 선택지들은 이보다 큰 거리를 가지므로 우선순위에서 밀리게 됩니다.<br>
따라서, 정답은 '4. de' 입니다.<br>
			</div>
			<div class="t2">
									#계층적 군집분석									# 거리 행렬									# 최단 거리									# 군집 형성							</div>
		</div>
		
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">4과목</span>
			<span class="g1">인공신경망분석</span>
			<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">55.</span>
			<span class="tt1t1">
				R에서 인공신경망의 학습 및 추론을 위해 대표적으로 사용되는 함수는 neuralnet( )이다. 다음 중 neuralnet 함수의 실행 결과로 도출되는 일반화 가중치(generalized weight)에 대한 설명으로 가장 적절한 것은?							</span>
		</strong>
		<span class="tt1t1">
				    </span> 
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			로지스틱 회귀와 달리 일반화 가중치는 전역적인 기여도를 나타낸다. 					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			로지스틱 회귀모형에서의 회귀 계수와 유사하게 해석된다.					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			각 자료점의 분산이 로그-오즈(log-odds)에 미치는 기여도를 나타낸다.					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			모든 자료에 대한 일반화 가중치의 분포는 가중치(weight)에 대한 신뢰구간을 나타낸다.					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a55" class="b2 help" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a55" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">2</i>
			<span class="t2t1">
			로지스틱 회귀모형에서의 회귀 계수와 유사하게 해석된다.			</span>
					</div>
        <br>
				<strong class="tt1">해설</strong>
		<div class="t1">
		일반화 가중치(generalized weight)는 각 공변량의 영향을 표현하기 때문에 회귀모델에서 I번째 회귀 변수의 유사한 해석을 가진다.				</div>
		
				
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				정답은 2번입니다.<br>
<br>
인공신경망에서의 학습은 입력 데이터에 대한 가중치를 조정하여 출력값을 예측하는 과정입니다. R의 neuralnet 함수는 이러한 인공신경망을 구현하는 데 사용되며, 학습 과정에서 각 입력 변수에 대한 가중치를 조정합니다. 이 가중치는 입력 데이터가 출력에 미치는 영향을 나타내며, 일반화 가중치(generalized weight)는 이러한 가중치의 해석을 돕는 개념입니다. 일반화 가중치는 특정 입력이 출력에 미치는 기여도를 나타내며, 이는 로지스틱 회귀의 회귀 계수와 유사하게 해석될 수 있습니다. 로지스틱 회귀에서는 회귀 계수가 각 독립 변수가 종속 변수에 미치는 영향을 나타내듯이, 인공신경망의 일반화 가중치도 유사한 역할을 합니다.<br>
<br>
1. 로지스틱 회귀와 달리 일반화 가중치는 전역적인 기여도를 나타낸다. <br>
: 일반화 가중치는 인공신경망에서 각 입력이 출력에 미치는 기여도를 나타내는 값입니다. 이는 로지스틱 회귀의 회귀 계수와 유사하게 해석되며, 전역적인 기여도를 나타내기보다는 특정 입력의 기여도를 나타냅니다. 따라서, 일반화 가중치가 전역적인 기여도를 나타낸다는 설명은 부적절합니다.<br>
<br>
2. 로지스틱 회귀모형에서의 회귀 계수와 유사하게 해석된다. <br>
: 로지스틱 회귀모형에서의 회귀 계수는 각 독립 변수가 종속 변수에 미치는 영향을 나타내며, 이는 인공신경망의 일반화 가중치와 유사한 해석을 가집니다. 따라서, 일반화 가중치는 로지스틱 회귀모형의 회귀 계수와 유사하게 해석된다는 설명은 적절합니다.<br>
<br>
3. 각 자료점의 분산이 로그-오즈(log-odds)에 미치는 기여도를 나타낸다. <br>
: 일반화 가중치는 각 자료점의 분산이 로그-오즈에 미치는 기여도를 나타내지 않습니다. 이는 로지스틱 회귀의 회귀 계수와 유사하게 해석되며, 입력이 출력에 미치는 기여도를 나타냅니다. 따라서, 이 설명은 부적절합니다.<br>
<br>
4. 모든 자료에 대한 일반화 가중치의 분포는 가중치(weight)에 대한 신뢰구간을 나타낸다. <br>
: 일반화 가중치의 분포가 가중치에 대한 신뢰구간을 나타낸다는 설명은 부적절합니다. 일반화 가중치는 특정 입력의 기여도를 나타내는 값으로, 신뢰구간과는 관련이 없습니다.<br>
<br>
정답은 2번입니다. 일반화 가중치는 로지스틱 회귀모형의 회귀 계수와 유사하게 해석되며, 이는 각 입력이 출력에 미치는 기여도를 나타냅니다. 1번은 전역적인 기여도를 나타낸다는 잘못된 설명이고, 3번은 로그-오즈에 대한 기여도를 설명하지 않으며, 4번은 신뢰구간과 관련이 없습니다.<br>
따라서, 정답은 '2. 로지스틱 회귀모형에서의 회귀 계수와 유사하게 해석된다.' 입니다.<br>
			</div>
			<div class="t2">
									#인공신경망									# 일반화 가중치									# 로지스틱 회귀									# 회귀 계수									# 기여도							</div>
		</div>
		
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">4과목</span>
			<span class="g1">회귀분석</span>
			<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">56.</span>
			<span class="tt1t1">
				불필요한 변수들 중에서 필요한 변수들을 선택하여 간단한 모형을 만드는 방법을 변수 선택(variable selection)이라 한다. 다음 중 변수 선택 기준으로 사용되는 통계량들에 대한 설명으로 가장 부적절한 것은?							</span>
		</strong>
		<span class="tt1t1">
				    </span> 
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			수정결정계수(Adjusted Rsquare)는 평균제곱오차가 가장 작은 축소모형을 선택하는 방법으로 모형의 간명성과 설명력을 동시에 고려한 기준이다.					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			Mallows Cp는 예측식이 가진 수행능력을 예측값의 변이를 기준으로 평가하기 위해 예측값에 대한 MSE를 고려하는 방법이다.					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			Akaike 정보통계량은 정확도와 간명성 사이의 상충을 조절하려는 방법으로 비슷한 SSE를 갖는 두 모형에 대해 AIC는 적은 변수를 갖는 모형에 대해 가산점을 부여한다.					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			베이즈 정보기준(BIC)은 AIC가 과적합이 되는 경향을 제어하기 위해 사용되는 방법이다.					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a56" class="b2 help" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a56" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">1</i>
			<span class="t2t1">
			수정결정계수(Adjusted Rsquare)는 평균제곱오차가 가장 작은 축소모형을 선택하는 방법으로 모형의 간명성과 설명력을 동시에 고려한 기준이다.			</span>
					</div>
        <br>
				<strong class="tt1">해설</strong>
		<div class="t1">
		베이즈 정보기준(BIC)은 AIC가 과적합이 되는 경향을 제어하기 위한 방법이 아니라 페널티 기간에 대한 차이로 인하여 다른 방법으로 사용되고 있다.				</div>
		
				
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				1. 수정결정계수는 평균제곱오차가 가장 작은 축소모형을 선택하는 방법이 아니라, 변수의 수를 고려하여 모형의 설명력을 평가하는 방법입니다.<br>
<br>
2. Mallows Cp 통계량은 예측 모형의 편향과 분산을 평가하는데 사용됩니다. Cp 통계량은 예측 오차의 분산(MSE)과 모형의 복잡도(변수의 수)를 동시에 고려하여 최적의 모형을 선택하는데 도움을 줍니다. 따라서 이 설명은 적절합니다.<br>
<br>
3. Akaike 정보통계량(AIC)은 모형의 적합도를 평가할 때 사용되며, 모형의 복잡도(변수의 수)와 적합도(SSE)를 동시에 고려합니다. AIC는 작은 값을 갖는 모형을 선호하며, 과적합을 방지하기 위해 변수가 적은 모형에 가산점을 부여합니다. 따라서 이 설명은 적절합니다.<br>
<br>
4. 베이즈 정보기준(BIC)은 AIC와 유사하게 모형의 적합도를 평가하지만, 더 강력한 페널티를 적용하여 변수의 수를 제한합니다. BIC는 AIC보다 더 과적합에 민감하며, 작은 값을 갖는 모형을 선호합니다. 따라서 이 설명은 적절합니다.<br>
			</div>
			<div class="t2">
									# 변수 선택									# 수정결정계수									# Mallows Cp									# Akaike 정보통계량									# 베이즈 정보기준							</div>
		</div>
		
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">4과목</span>
			<span class="g1">회귀분석</span>
			<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">57.</span>
			<span class="tt1t1">
				변수 X와 Y의 피어슨 상관계수는 0.3이고 변수 X와 Z의 피어슨 상관계수는 –0.7이다. 다음 중 X, Y, Z 간 피어슨 상관계수에 대한 설명으로 가장 부적절한 것은?							</span>
		</strong>
		<span class="tt1t1">
				    </span> 
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			X와 Z는 음의 상관관계를 가진다. 					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			X와 Y는 강한 선형관계를 가진다.					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			X와 Y의 선형관계보다 X와 Z의 선형관계가 강하다. 					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			두 상관계수의 유의성은 판단할 수 없다.					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a57" class="b2 help" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a57" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">2</i>
			<span class="t2t1">
			X와 Y는 강한 선형관계를 가진다.			</span>
					</div>
        <br>
				<strong class="tt1">해설</strong>
		<div class="t1">
		X와 Y의 피어슨 상관계수는 0.3으로 약한 선형관계를 가진다.				</div>
		
				
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				피어슨 상관계수는 -1에서 1 사이의 값을 가지며, 상관계수의 절댓값이 1에 가까울수록 두 변수 간의 선형관계가 강하다는 것을 의미합니다. <br>
<br>
보기 1: X와 Z의 피어슨 상관계수가 -0.7이므로, 이는 음의 상관관계를 의미합니다. 따라서 이 설명은 적절합니다.<br>
<br>
보기 2: X와 Y의 피어슨 상관계수가 0.3이므로, 이는 약한 양의 선형관계를 의미합니다. 따라서 "강한 선형관계"라는 설명은 부적절합니다.<br>
<br>
보기 3: X와 Y의 상관계수(0.3)보다 X와 Z의 상관계수(-0.7)의 절댓값이 더 크므로, X와 Z의 선형관계가 더 강합니다. 따라서 이 설명은 적절합니다.<br>
<br>
보기 4: 상관계수의 유의성을 판단하기 위해서는 추가적인 통계적 검정이 필요합니다. 따라서 이 설명은 적절합니다.<br>
			</div>
			<div class="t2">
									# 피어슨 상관계수									# 선형 관계									# 양의 상관관계									# 음의 상관관계									# 유의성							</div>
		</div>
		
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">4과목</span>
			<span class="g1">사회연결망 분석</span>
			<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">58.</span>
			<span class="tt1t1">
				다음 중 R에서 네트워크 그래프를 그리고 분석하기 위해 사용하는 igraph 패키지에서 자기자신에 대한 연결이나 중복 연결을 제거하기 위해 사용되는 함수로 가장 적절한 것은 무엇인가?							</span>
		</strong>
		<span class="tt1t1">
				    </span> 
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			v( )					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			graph.adjacency( )					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			E( )					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			simplify( )					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a58" class="b2 help" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a58" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">4</i>
			<span class="t2t1">
			simplify( )			</span>
					</div>
        <br>
				<strong class="tt1">해설</strong>
		<div class="t1">
		simplify 함수는 loop나 multiple edge를 제거해서 단순하게 해준다.				</div>
		
				
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				정답은 4번입니다.<br>
<br>
R의 igraph 패키지는 네트워크 그래프를 생성하고 분석하는 데 사용됩니다. 네트워크 그래프는 노드(정점)와 엣지(간선)로 구성되며, 이들 간의 관계를 시각적으로 표현합니다. 네트워크 분석에서 중요한 개념 중 하나는 자기자신에 대한 연결(루프)이나 중복 연결(다중 간선)을 제거하는 것입니다. 이러한 불필요한 연결을 제거함으로써 그래프의 구조를 단순화하고 분석을 용이하게 할 수 있습니다. 이를 위해 igraph 패키지에서는 특정 함수를 사용하여 이러한 연결을 제거할 수 있습니다.<br>
<br>
1. v( ) <br>
: v() 함수는 igraph 패키지에서 그래프의 정점(노드)을 선택하거나 조작할 때 사용됩니다. 이 함수는 그래프의 구조를 단순화하거나 중복 연결을 제거하는 기능과는 관련이 없습니다. 예를 들어, 특정 정점의 속성을 변경하거나 정점의 목록을 가져오는 데 사용됩니다.<br>
<br>
2. graph.adjacency( ) <br>
: graph.adjacency() 함수는 인접 행렬을 사용하여 그래프 객체를 생성하는 데 사용됩니다. 인접 행렬은 그래프의 정점 간 연결을 행렬 형태로 표현한 것입니다. 이 함수는 그래프의 생성과 관련이 있으며, 중복 연결이나 루프를 제거하는 기능은 포함되어 있지 않습니다.<br>
<br>
3. E( ) <br>
: E() 함수는 igraph 패키지에서 그래프의 간선(엣지)을 선택하거나 조작할 때 사용됩니다. 이 함수는 특정 간선의 속성을 변경하거나 간선의 목록을 가져오는 데 유용하지만, 간선을 제거하거나 단순화하는 기능은 제공하지 않습니다.<br>
<br>
4. simplify( ) <br>
: simplify() 함수는 igraph 패키지에서 그래프를 단순화하는 데 사용됩니다. 이 함수는 그래프에서 자기자신에 대한 연결(루프)과 중복 연결(다중 간선)을 제거하여 그래프의 구조를 단순화합니다. 예를 들어, 두 정점 간에 여러 개의 간선이 있을 경우, simplify() 함수를 사용하면 하나의 간선만 남기고 나머지를 제거할 수 있습니다. 이 함수는 네트워크 분석에서 불필요한 복잡성을 줄이고 분석을 용이하게 하는 데 매우 유용합니다.<br>
<br>
igraph 패키지에서 네트워크 그래프의 루프와 다중 간선을 제거하여 그래프를 단순화하는 기능을 제공하는 함수는 simplify()입니다. 다른 선택지들은 그래프의 정점이나 간선을 선택하거나 그래프를 생성하는 데 사용되지만, 그래프의 구조를 단순화하는 기능은 제공하지 않습니다. 따라서 이 문제의 정답은 simplify() 함수입니다.<br>
<br>
따라서, 정답은 '4. simplify( )' 입니다.<br>
			</div>
			<div class="t2">
									#igraph									# 네트워크 그래프									# simplify									# 루프 제거									# 다중 간선 제거							</div>
		</div>
		
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">4과목</span>
			<span class="g1">인공신경망분석</span>
			<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">59.</span>
			<span class="tt1t1">
				단층신경망인 퍼셉트론(perceptron)에서 최종 목표값(Target value)은 활성함수에 의해 결정되는데 다양한 활성함수 중 출력값이 여러 개로 주어지고, 목표치가 다범주인 경우 각 범주에 속할 사후확률을 제공하는 함수는 무엇인가?							</span>
		</strong>
		<span class="tt1t1">
				    </span> 
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			Sigmoid 함수 					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			Tanh 함수 					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			Gauss 함수 					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			Softmax 함수					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a59" class="b2 help" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a59" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">4</i>
			<span class="t2t1">
			Softmax 함수			</span>
					</div>
        <br>
				<strong class="tt1">해설</strong>
		<div class="t1">
		Softmax 함수는 출력 값이 여러 개로 주어지고, 목표치가 다범주인 경우 각 범주에 속할 사후확률을 제공하는 함수이다.				</div>
		
				
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				정답은 4번입니다.<br>
<br>
퍼셉트론은 인공신경망의 기본 단위로, 입력 신호의 가중치 합을 계산하여 활성화 함수를 통해 출력 신호를 결정합니다. 활성화 함수는 입력 신호를 처리하여 출력 신호를 생성하는데, 다양한 유형이 있습니다. 이 중 Softmax 함수는 출력값이 여러 개로 주어지고 목표치가 다범주인 경우 각 범주에 속할 사후확률을 제공하는 함수로, 다중 클래스 분류 문제에서 자주 사용됩니다. Softmax 함수는 각 클래스의 지수화된 점수를 전체 점수의 합으로 나누어 확률을 계산합니다.<br>
<br>
1. Sigmoid 함수 <br>
: Sigmoid 함수는 이진 분류 문제에서 주로 사용되며, 입력값을 0과 1 사이의 확률로 변환합니다. 그러나 다중 클래스 분류 문제에서는 각 클래스에 대한 확률을 제공하지 못하므로, 이 문제의 요구사항에 적합하지 않습니다.<br>
<br>
2. Tanh 함수 <br>
: Tanh 함수는 입력값을 -1과 1 사이로 변환하는 활성화 함수로, 주로 이진 분류 문제에서 사용됩니다. 다중 클래스 분류 문제에서 각 클래스에 대한 확률을 제공하지 않기 때문에 이 문제의 요구사항에 맞지 않습니다.<br>
<br>
3. Gauss 함수 <br>
: Gauss 함수는 주로 가우시안 분포를 따르는 데이터에 대한 모델링에 사용되며, 활성화 함수로서 다중 클래스 분류 문제에서 각 클래스에 대한 확률을 제공하지 않습니다. 따라서 이 문제의 요구사항에 부합하지 않습니다.<br>
<br>
4. Softmax 함수 <br>
: Softmax 함수는 다중 클래스 분류 문제에서 각 클래스에 대한 사후확률을 제공하는 활성화 함수입니다. 입력값을 지수화하여 전체 합으로 나누어 각 클래스에 대한 확률을 계산하므로, 이 문제의 요구사항에 정확히 부합합니다.<br>
<br>
문제에서 요구하는 것은 다중 클래스 분류 문제에서 각 클래스에 대한 사후확률을 제공하는 활성화 함수입니다. Softmax 함수는 이러한 요구사항을 충족하며, 각 클래스의 지수화된 점수를 전체 점수의 합으로 나누어 확률을 계산합니다. 반면, Sigmoid와 Tanh 함수는 주로 이진 분류 문제에 사용되며, Gauss 함수는 다중 클래스 확률을 제공하지 않으므로 오답입니다.<br>
<br>
따라서, 정답은 '4. Softmax 함수' 입니다.<br>
			</div>
			<div class="t2">
									#퍼셉트론									# 활성화 함수									# Softmax									# 다중 클래스 분류									# 사후확률							</div>
		</div>
		
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">4과목</span>
			<span class="g1">주성분 분석</span>
			<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">60.</span>
			<span class="tt1t1">
				다음 중 주성분 분석에 대한 설명으로 적절하지 않은 것은 무엇인가?							</span>
		</strong>
		<span class="tt1t1">
				    </span> 
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			전체 변이 공헌도(percentage of total variance)방법은 전체 변이의 70,90% 정도가 되도록 주성분의 수를 결정한다.					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			변수들이 서로 상관성이 있는 경우, 해석상의 복잡한 주조적 문제가 발생하는데 이를 해결하기 위해 사용한다.					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			회귀분석에서 다중공선성(Multicollinearity)의 문제를 해결하기 위해 활용한다.					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			다변량 자료를 저차원의 그래프로 표시하여 이상치(Outlier) 탐색에 활용할 수 없다.					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a60" class="b2 help" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a60" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">4</i>
			<span class="t2t1">
			다변량 자료를 저차원의 그래프로 표시하여 이상치(Outlier) 탐색에 활용할 수 없다.			</span>
					</div>
        <br>
				<strong class="tt1">해설</strong>
		<div class="t1">
		주성분 분석은 서로 상관성이 높은 변수들의 선형 결합으로 만들어 기존의  상관성이 높은 변수들을 요약, 축소하는 기법으로 이상치 탐지에도 사용한다.				</div>
		
				
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				주성분 분석(PCA)은 고차원의 데이터를 저차원으로 축소하면서도 데이터의 중요한 구조를 유지하는 방법입니다. 이를 통해 데이터의 시각화와 해석이 용이해지며, 특히 이상치(Outlier) 탐색에도 활용될 수 있습니다. 따라서 4번 문항은 적절하지 않은 설명입니다. 나머지 선택지들은 주성분 분석의 특징과 활용에 대해 적절하게 설명하고 있습니다.<br>
			</div>
			<div class="t2">
									# 주성분 분석									# 전체 변이 공헌도									# 상관성									# 다중공선성									# 이상치 탐색									# 저차원 축소							</div>
		</div>
		
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">4과목</span>
			<span class="g1">통계분석 방법론</span>
			<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">61.</span>
			<span class="tt1t1">
				아래의 attitude는 어떤 금융회사 내 30개의 부서에 관한 사원들의 평가를 수집한 데이터로 각 변수는 하나의 설명항목을 나타내고 그 값은 부서에 대한 사원들의 평가 점수를 나타낸다. 다음은 데이터프레임 attitude에 R 명령을 수행시킨 결과이다. 설명이 가장 부적절한 것은?							</span>
		</strong>
		<span class="tt1t1">
						<a href="exam1view1img1.php?img=a5362338-dbde-c7ed-004a-65183044bf1f.png" target="_blank" rel="noopener" title="새 창" class="p1">
				<img src="/data/img/question/a5362338-dbde-c7ed-004a-65183044bf1f.png" alt="문제에 포함된 이미지">
			</a>
				    </span> 
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			어떤 부서가 설문 문항 rating에서 85점을 받았다면 최고점을 받은 것이다.					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			어떤 부서가 설문 문항 complaints에서 80점을 받았다면 최소한 22개의 부서보다는 높은 점수를 받은 것이다.					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			설문 문항 privileges의 경우 15개의 부서의 점수가 45에서 62.5사이에 있다.					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			설문 문항 learning의 경우 30개 부서의 점수가 모두 다르다고 하면, 21개의 부서가 47점 보다 높은 점수를 받았다.					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a61" class="b2 help" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a61" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">4</i>
			<span class="t2t1">
			설문 문항 learning의 경우 30개 부서의 점수가 모두 다르다고 하면, 21개의 부서가 47점 보다 높은 점수를 받았다.			</span>
					</div>
        <br>
				<strong class="tt1">해설</strong>
		<div class="t1">
		설문문항 learning의 경우 30개 부서의 점수가 모두 다르다고 하면, 22개의 부서가 47점보다 높은 점수를 받았다.				</div>
		
				
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				보기 1: "어떤 부서가 설문 문항 rating에서 85점을 받았다면 최고점을 받은 것이다."<br>
  - 데이터에 따르면 rating의 최고점수는 85점입니다. 따라서 이 설명은 적절합니다.<br>
<br>
보기 2: "어떤 부서가 설문 문항 complaints에서 80점을 받았다면 최소한 22개의 부서보다는 높은 점수를 받은 것이다."<br>
  - complaints의 75% 지점이 77점이므로, 80점은 상위 25%에 해당합니다. 즉, 30개의 부서 중 최소 22개의 부서보다 높은 점수를 받은 것입니다. 따라서 이 설명도 적절합니다.<br>
<br>
보기 3: "설문 문항 privileges의 경우 15개의 부서의 점수가 45에서 62.5사이에 있다."<br>
  - privileges의 25% 지점이 45점이고, 75% 지점이 62.5점입니다. 따라서 중간 50%의 부서가 이 범위에 속합니다. 30개의 부서 중 15개 부서가 이 범위에 속하는 것은 맞습니다. 따라서 이 설명도 적절합니다.<br>
<br>
보기 4: "설문 문항 learning의 경우 30개 부서의 점수가 모두 다르다고 하면, 21개의 부서가 47점 보다 높은 점수를 받았다."<br>
  - learning의 25% 지점이 47점이므로, 47점보다 높은 점수를 받은 부서는 75%에 해당합니다. 30개의 부서 중 75%는 22.5개 부서입니다. 따라서 21개 부서가 아니라 22개 부서가 47점보다 높은 점수를 받았습니다. 이 설명은 부적절합니다.<br>
			</div>
			<div class="t2">
									# quantile									# 점수 분포									# 사분위수									# R프로그램 결과해석							</div>
		</div>
		
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">4과목</span>
			<span class="g1">분류분석</span>
			<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">62.</span>
			<span class="tt1t1">
				다음 중 의사결정나무의 특성으로 가장 부적절한 것은?							</span>
		</strong>
		<span class="tt1t1">
				    </span> 
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			의사결정나무 모형의 결과는 누구에게나 설명이 용이하다.					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			의사결정나무 알고리즘의 모형 정확도는 다른 분류모형에 뒤지지 않는다. 					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			의사결정나무 알고리즘은 정상적인 데이터에 대해서만 민감함이 없이 분류할 수 있다. 					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			의사결정나무를 만드는 방법은 계산적으로 복잡하지 않다.					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a62" class="b2 help" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a62" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">3</i>
			<span class="t2t1">
			의사결정나무 알고리즘은 정상적인 데이터에 대해서만 민감함이 없이 분류할 수 있다. 			</span>
					</div>
        <br>
				<strong class="tt1">해설</strong>
		<div class="t1">
		의사결정나무는 비정상 잡음 데이터에 대해서도 민감함이 없이 분류할 수 있다.				</div>
		
				
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				정답은 3번입니다.<br>
<br>
의사결정나무는 데이터 마이닝에서 널리 사용되는 기법으로, 데이터를 분류하거나 예측하는 데 사용됩니다. 이 기법은 나무 구조를 통해 의사결정 규칙을 시각적으로 표현하여, 복잡한 데이터 관계를 쉽게 이해할 수 있도록 돕습니다. 의사결정나무는 주어진 데이터를 여러 기준에 따라 분할하여 최종적으로 분류하거나 예측하는 결과를 도출합니다. 이 과정에서 각 노드는 특정 기준에 따라 데이터를 분할하며, 최종 노드에서는 예측 결과를 제공합니다. 의사결정나무는 해석이 용이하고, 다양한 데이터 유형을 처리할 수 있는 장점이 있지만, 과대적합의 위험이 존재할 수 있습니다.<br>
<br>
1. 의사결정나무 모형의 결과는 누구에게나 설명이 용이하다. <br>
: 의사결정나무의 가장 큰 장점 중 하나는 그 결과가 시각적으로 표현되기 때문에 누구나 쉽게 이해할 수 있다는 점입니다. 나무 구조는 각 단계에서의 의사결정 과정을 명확히 보여주며, 이는 비전문가도 결과를 해석하는 데 도움을 줍니다. 예를 들어, 고객의 구매 여부를 예측하는 의사결정나무는 각 노드에서의 분기 기준을 통해 고객의 특성을 설명하고, 최종적으로 구매 여부를 예측합니다.<br>
<br>
2. 의사결정나무 알고리즘의 모형 정확도는 다른 분류모형에 뒤지지 않는다. <br>
: 의사결정나무의 모형 정확도는 다른 분류 모형과 비교했을 때 항상 우수한 것은 아닙니다. 그러나, 의사결정나무는 데이터의 특성에 따라 높은 정확도를 보일 수 있으며, 특히 데이터의 구조가 나무 모형에 적합할 경우 강력한 성능을 발휘합니다. 하지만, 과대적합의 위험이 있어, 이를 방지하기 위한 가지치기 등의 기법이 필요합니다.<br>
<br>
3. 의사결정나무 알고리즘은 정상적인 데이터에 대해서만 민감함이 없이 분류할 수 있다. <br>
: 의사결정나무는 비정상적인 잡음 데이터에 대해서도 민감하지 않게 분류할 수 있는 장점이 있습니다. 이는 의사결정나무가 데이터의 분포나 이상치에 크게 영향을 받지 않고, 전체적인 패턴을 파악하여 분류를 수행하기 때문입니다. 그러나, 정상적인 데이터에 대해서만 민감하지 않다는 것은 잘못된 설명입니다. 의사결정나무는 다양한 데이터 유형에 대해 유연하게 작동합니다.<br>
<br>
4. 의사결정나무를 만드는 방법은 계산적으로 복잡하지 않다. <br>
: 의사결정나무를 만드는 과정은 비교적 계산적으로 간단합니다. 이는 각 노드에서 데이터를 분할하는 기준을 선택하고, 이를 반복하여 나무 구조를 형성하는 방식으로 이루어지기 때문입니다. 이러한 과정은 알고리즘적으로 효율적이며, 대용량 데이터에서도 빠르게 처리할 수 있습니다.<br>
<br>
선지 3은 의사결정나무의 특성을 잘못 설명하고 있습니다. 의사결정나무는 비정상적인 잡음 데이터에 대해서도 민감하지 않게 작동할 수 있는 장점이 있지만, 정상적인 데이터에 대해서만 민감하지 않다는 것은 잘못된 설명입니다. 다른 선지들은 의사결정나무의 장점과 특성을 올바르게 설명하고 있습니다.<br>
<br>
따라서, 정답은 '3. 의사결정나무 알고리즘은 정상적인 데이터에 대해서만 민감함이 없이 분류할 수 있다.' 입니다.<br>
			</div>
			<div class="t2">
									#의사결정나무									# 데이터 분류									# 시각적 표현									# 과대적합									# 잡음 데이터							</div>
		</div>
		
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">4과목</span>
			<span class="g1">주성분 분석</span>
			<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">63.</span>
			<span class="tt1t1">
				다음의 headsize 데이터는 25개 가구에서 첫 번째와 두 번째 성인 아들의 머리길이와 머리둘레를 보여준다. 아래의 행렬도는 headsize데이터를 사용하여 주성분 분석을 한 결과이다. 이에 대한 설명으로 가장 부적절한 것은?							</span>
		</strong>
		<span class="tt1t1">
						<a href="exam1view1img1.php?img=f224a7bb-40ea-3be0-e5f0-ccc9fec52139.png" target="_blank" rel="noopener" title="새 창" class="p1">
				<img src="/data/img/question/f224a7bb-40ea-3be0-e5f0-ccc9fec52139.png" alt="문제에 포함된 이미지">
			</a>
				    </span> 
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			첫 번째와 두 번째 주성분에 관한 그래프이다.					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			head2와 breadth2의 상관관계가 다른 변수들 간의 관계보다 상대적으로 높다. 					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			첫 번째 주성분은 네 개의 변수와 양의 상관관계를 가진다.					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			두 번째 주성분은 head2, breadth2 변수와 양의 상관관계를 가진다.					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a63" class="b2 help" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a63" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">4</i>
			<span class="t2t1">
			두 번째 주성분은 head2, breadth2 변수와 양의 상관관계를 가진다.			</span>
					</div>
        <br>
				<strong class="tt1">해설</strong>
		<div class="t1">
		두 번째 주성분은 head2, breadth2 변수와 음의 상관관계를 가질 것이다.				</div>
		
				
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				정답은 4번입니다.<br>
<br>
주성분 분석(PCA)은 데이터의 차원을 축소하면서도 최대한의 정보를 유지하는 기법입니다. 주성분은 데이터의 분산을 최대화하는 방향으로 설정되며, 각 주성분은 서로 직교합니다. 주성분 분석의 결과는 주성분의 중요도, 각 변수의 로딩 값, 그리고 시각화 자료로 나타납니다. 주성분의 로딩 값은 각 변수와 주성분 간의 상관관계를 나타내며, 양수는 양의 상관관계, 음수는 음의 상관관계를 의미합니다. 제공된 이미지에서는 첫 번째 주성분이 전체 분산의 80.4%를 설명하며, 두 번째 주성분은 10.4%를 설명합니다. 로딩 값을 통해 각 변수와 주성분 간의 관계를 파악할 수 있습니다.<br>
<br>
1. 첫 번째와 두 번째 주성분에 관한 그래프이다. <br>
: 첫 번째와 두 번째 주성분에 관한 그래프는 주성분 분석의 결과를 시각화한 것으로, 각 주성분이 데이터의 분산을 얼마나 설명하는지를 보여줍니다. 주성분 분석의 그래프는 주로 biplot 형태로 제공되며, 이는 변수와 관측치의 관계를 동시에 시각화합니다.<br>
<br>
2. head2와 breadth2의 상관관계가 다른 변수들 간의 관계보다 상대적으로 높다. <br>
: head2와 breadth2의 상관관계는 로딩 값을 통해 확인할 수 있습니다. 두 변수의 로딩 값이 비슷하거나 같은 방향을 가리키면 상관관계가 높다고 볼 수 있습니다. 이미지에서 head2와 breadth2는 첫 번째 주성분에서 양의 로딩 값을 가지므로 상관관계가 높다고 해석할 수 있습니다.<br>
<br>
3. 첫 번째 주성분은 네 개의 변수와 양의 상관관계를 가진다. <br>
: 첫 번째 주성분은 네 개의 변수와 양의 상관관계를 가진다는 의미는 적절합니다. 로딩 값이 양수인 경우 양의 상관관계를 의미합니다. 이미지에서 첫 번째 주성분의 로딩 값은 모두 양수입니다.<br>
<br>
4. 두 번째 주성분은 head2, breadth2 변수와 양의 상관관계를 가진다. <br>
: 두 번째 주성분은 head2와 breadth2 변수와 양의 상관관계를 가진다고 했으나, 실제로는 음의 상관관계를 가집니다. 두 번째 주성분의 로딩 값은 head2와 breadth2에 대해 음수로 나타나 있습니다.<br>
<br>
두 번째 주성분이 head2와 breadth2와 양의 상관관계를 가진다는 설명은 잘못되었습니다. 이미지에서 두 번째 주성분의 로딩 값은 head2와 breadth2에 대해 음수로 나타나 있어, 실제로는 음의 상관관계를 가집니다. 따라서 이 설명이 부적절합니다.<br>
따라서, 정답은 '4. 두 번째 주성분은 head2, breadth2 변수와 양의 상관관계를 가진다.' 입니다.<br>
			</div>
			<div class="t2">
									#주성분 분석									# 로딩 값									# 상관관계									# 차원 축소							</div>
		</div>
		
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">4과목</span>
			<span class="g1">텍스트 마이닝</span>
			<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">64.</span>
			<span class="tt1t1">
				다음 중 텍스트 마이닝에 대한 설명으로 가장 부적절한 것은?							</span>
		</strong>
		<span class="tt1t1">
				    </span> 
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			Term Frequence-Inverse Document Frequence는 분석내의 단어 빈도수를 이용하여 키워드를 도출하는 기법이다.					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			wordcloud는 문서에 포함되는 단어를 사용해 빈도가 높은 단어를 크게 나타내 효과적으로 시각화한 기법이다.					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			Stemming은 접속사, 대명사 등은 남겨두고, 공통 어간을 가지는 단어끼리 묶기 위한 처리 방법이다.					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			Opinion Mining은 문장에서 사용된 단어의 긍정과 부정 여부에 의해 얼마나 긍정, 부정적인 단어가 많은지 여부를 활용해 긍정, 부정 문장인지를 평가하는 기법이다.					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a64" class="b2 help" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a64" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">3</i>
			<span class="t2t1">
			Stemming은 접속사, 대명사 등은 남겨두고, 공통 어간을 가지는 단어끼리 묶기 위한 처리 방법이다.			</span>
					</div>
        <br>
				<strong class="tt1">해설</strong>
		<div class="t1">
		Stemming은 접속사, 대명사 등을 제거하고, 공통 어간을 가지는 단어끼리 묶기 위한 처리 방법이다.				</div>
		
				
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				정답은 3번입니다.<br>
<br>
텍스트 마이닝은 대량의 텍스트 데이터를 분석하여 유의미한 정보를 추출하는 과정입니다. 이 과정에는 여러 기법이 사용되며, 그 중 TF-IDF는 특정 단어의 중요도를 평가하기 위해 사용됩니다. TF는 특정 문서에서의 단어 빈도를 나타내고, IDF는 그 단어가 전체 문서에서 얼마나 흔한지를 나타내는 역수입니다. 이를 통해 자주 등장하지만 특정 문서에만 중요한 단어를 식별할 수 있습니다. Wordcloud는 단어의 빈도를 시각적으로 표현하여 쉽게 이해할 수 있도록 돕습니다. Stemming은 단어의 어간을 추출하여 형태소 분석을 단순화하는 기법입니다. Opinion Mining은 문서의 감정적 경향을 분석하여 긍정적 또는 부정적 감정을 평가합니다.<br>
<br>
1. Term Frequence-Inverse Document Frequence는 분석내의 단어 빈도수를 이용하여 키워드를 도출하는 기법이다. <br>
: TF-IDF는 텍스트 마이닝에서 단어의 중요도를 평가하는 기법으로, 특정 문서에서의 단어 빈도(TF)와 그 단어가 전체 문서에서 얼마나 흔한지를 나타내는 역수(IDF)를 곱하여 계산합니다. 이를 통해 특정 문서에서 중요한 단어를 식별할 수 있습니다.<br>
<br>
2. wordcloud는 문서에 포함되는 단어를 사용해 빈도가 높은 단어를 크게 나타내 효과적으로 시각화한 기법이다. <br>
: Wordcloud는 텍스트 데이터에서 단어의 빈도를 시각적으로 표현하는 기법입니다. 빈도가 높은 단어일수록 더 크게 표시되며, 이를 통해 문서의 주요 주제를 한눈에 파악할 수 있습니다.<br>
<br>
3. Stemming은 접속사, 대명사 등은 남겨두고, 공통 어간을 가지는 단어끼리 묶기 위한 처리 방법이다. <br>
: Stemming은 단어의 어간을 추출하여 형태소 분석을 단순화하는 기법입니다. 접속사나 대명사와 같은 불필요한 단어를 제거하고, 공통 어간을 가진 단어들을 묶어주는 역할을 합니다. 그러나 접속사나 대명사를 남겨두는 것이 아니라 제거하는 것이 일반적입니다.<br>
<br>
4. Opinion Mining은 문장에서 사용된 단어의 긍정과 부정 여부에 의해 얼마나 긍정, 부정적인 단어가 많은지 여부를 활용해 긍정, 부정 문장인지를 평가하는 기법이다. <br>
: Opinion Mining은 문서에서 사용된 단어의 긍정적 또는 부정적 의미를 분석하여 문서의 감정적 경향을 평가하는 기법입니다. 이를 통해 문서가 긍정적, 부정적 감정을 얼마나 포함하고 있는지를 판단할 수 있습니다.<br>
<br>
선지 3의 설명은 Stemming에 대한 잘못된 설명을 포함하고 있습니다. Stemming은 접속사나 대명사를 남겨두는 것이 아니라, 불필요한 단어를 제거하고 어간을 추출하는 과정입니다. 나머지 선지들은 각각 TF-IDF, Wordcloud, Opinion Mining에 대한 올바른 설명을 제공하고 있습니다.<br>
<br>
따라서, 정답은 '3. Stemming은 접속사, 대명사 등은 남겨두고, 공통 어간을 가지는 단어끼리 묶기 위한 처리 방법이다.' 입니다.<br>
			</div>
			<div class="t2">
									#텍스트 마이닝									# TF-IDF									# Wordcloud									# Stemming									# Opinion Mining							</div>
		</div>
		
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">4과목</span>
			<span class="g1">데이터 마이닝 개요</span>
			<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">65.</span>
			<span class="tt1t1">
				아래는 모델 성능 평가에 관한 내용이다. 다음 중 모델 성능 평가 기법들에 대한 설명으로 가장 부적절한 것은?					
					<span class="tt1t1">
						분류모델이 만들어지고 나면 모델의 성능을 평가하는 것이 필요하다. 과잉 적합이 되지 않았는지, 예측력이 높으면서 안정적인지, 적당한 복잡도를 가지고 있는 모델인지 등에 대한 성능을 측정하는 것이다. 모델의 성능을 평가하는 기준은 분석 기법별로 다양하다.					</span>
							</span>
		</strong>
		<span class="tt1t1">
				    </span> 
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			예비기법(Holdout method)은 데이터를 훈련집단과 시험집단으로 나누어 평가하는 기법이다. 					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			다중 교차 검증(k-fold cross validation)은 데이터를 k개의 동일 크기 구획으로 분할하여 평가하는 기법이다.					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			붓스트랩(Bootstrap) 방식에서는 붓스트랩 샘플링 방식으로 훈련 집합을 구성하는 기법이다. 					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			분류 모형 평가를 위해 범주형 변수에 대표적으로 사용되는 방법에 오분류표는 포함되지 않는다.					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a65" class="b2 help" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a65" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">4</i>
			<span class="t2t1">
			분류 모형 평가를 위해 범주형 변수에 대표적으로 사용되는 방법에 오분류표는 포함되지 않는다.			</span>
					</div>
        <br>
				<strong class="tt1">해설</strong>
		<div class="t1">
		분류 모형 평가를 위해 범주형 변수에 대표적으로 사용되는 방법은 오분류표, ROC 그래프, 이익 도표, 향상도 곡선 등이 있다.				</div>
		
				
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				정답은 4번입니다.<br>
<br>
모델 성능 평가 기법은 머신러닝 모델이 얼마나 잘 작동하는지를 평가하는 중요한 과정입니다. 모델이 과적합되지 않았는지, 예측력이 높은지, 그리고 적절한 복잡도를 가지고 있는지를 확인하는 것이 핵심입니다. 다양한 평가 기법이 존재하며, 각 기법은 데이터의 특성과 분석 목적에 따라 선택됩니다. 예를 들어, Holdout 방법은 데이터를 훈련과 테스트 세트로 나누어 모델의 성능을 평가하는 기본적인 방법입니다. k-fold 교차 검증은 데이터를 여러 부분으로 나누어 여러 번의 훈련과 테스트를 통해 모델의 일반화 성능을 평가합니다. Bootstrap은 데이터 샘플링을 통해 모델의 안정성을 평가하는 방법입니다. 마지막으로, 오분류표는 분류 모델의 성능을 평가하는 데 사용되는 대표적인 방법 중 하나입니다.<br>
<br>
1. 예비기법(Holdout method)은 데이터를 훈련집단과 시험집단으로 나누어 평가하는 기법이다. <br>
: Holdout 방법은 데이터를 훈련 세트와 테스트 세트로 나누어 모델을 평가하는 가장 기본적인 방법입니다. 이 방법은 간단하고 빠르게 모델의 성능을 평가할 수 있지만, 데이터의 분할 방식에 따라 결과가 달라질 수 있어 데이터의 대표성을 확보하기 어려울 수 있습니다. 예를 들어, 데이터가 충분히 크지 않거나 편향되어 있을 경우, 모델의 성능이 과대평가되거나 과소평가될 수 있습니다. 따라서 Holdout 방법은 데이터가 충분히 크고 균일하게 분포되어 있을 때 효과적입니다.<br>
<br>
2. 다중 교차 검증(k-fold cross validation)은 데이터를 k개의 동일 크기 구획으로 분할하여 평가하는 기법이다. <br>
: k-fold 교차 검증은 데이터를 k개의 동일 크기 구획으로 나누어 각 구획을 한 번씩 테스트 세트로 사용하고 나머지를 훈련 세트로 사용하여 k번의 모델 평가를 수행하는 방법입니다. 이 방법은 데이터의 모든 부분이 테스트 세트로 사용되기 때문에 모델의 일반화 성능을 보다 정확하게 평가할 수 있습니다. 예를 들어, 5-fold 교차 검증에서는 데이터를 5개로 나누어 5번의 훈련과 테스트를 수행합니다. 이 방법은 데이터가 적을 때 특히 유용하며, 모델의 과적합을 방지하는 데 도움을 줍니다.<br>
<br>
3. 붓스트랩(Bootstrap) 방식에서는 붓스트랩 샘플링 방식으로 훈련 집합을 구성하는 기법이다. <br>
: Bootstrap 방법은 데이터에서 여러 번 샘플링하여 훈련 세트를 구성하고 모델을 평가하는 방법입니다. 이 방법은 데이터의 불확실성을 평가하고 모델의 안정성을 확인하는 데 유용합니다. 예를 들어, 데이터가 작거나 불균형한 경우에도 Bootstrap을 통해 다양한 샘플을 생성하여 모델의 성능을 평가할 수 있습니다. 이 방법은 특히 앙상블 기법에서 자주 사용되며, 모델의 예측력을 향상시키는 데 기여합니다.<br>
<br>
4. 분류 모형 평가를 위해 범주형 변수에 대표적으로 사용되는 방법에 오분류표는 포함되지 않는다. <br>
: 오분류표는 분류 모델의 성능을 평가하는 데 사용되는 대표적인 방법 중 하나입니다. 오분류표는 실제 클래스와 예측 클래스 간의 관계를 표로 나타내어 모델의 정확도, 정밀도, 재현율 등을 계산할 수 있게 해줍니다. 따라서 분류 모델 평가에 오분류표가 포함되지 않는다는 설명은 부적절합니다. 오분류표는 모델의 성능을 직관적으로 이해할 수 있게 해주며, 모델의 개선 방향을 제시하는 데 유용합니다.<br>
<br>
선지 4는 오분류표가 분류 모델 평가에 포함되지 않는다고 설명하고 있지만, 이는 사실과 다릅니다. 오분류표는 분류 모델의 성능을 평가하는 데 필수적인 도구로, 모델의 정확도, 정밀도, 재현율 등을 계산하는 데 사용됩니다. 따라서 선지 4의 설명은 부적절하며, 정답은 4입니다. 다른 선지들은 각각의 평가 기법에 대한 올바른 설명을 제공하고 있습니다.<br>
<br>
따라서, 정답은 '4. 분류 모형 평가를 위해 범주형 변수에 대표적으로 사용되는 방법에 오분류표는 포함되지 않는다.' 입니다.<br>
			</div>
			<div class="t2">
									#모델 성능 평가									# Holdout									# k-fold 교차 검증									# Bootstrap									# 오분류표							</div>
		</div>
		
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">4과목</span>
			<span class="g1">군집분석</span>
			<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">66.</span>
			<span class="tt1t1">
				다음 대표적인 밀도기반 군집분석 방법인 DBSCAN에 대한 설명으로 가장 부적절한 것은?							</span>
		</strong>
		<span class="tt1t1">
				    </span> 
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			K-means와 같은 분할 방법에서 발전하였으나, 데이터의 분포를 통해 군집을 정하는 방법이다. 					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			군집의 경계를 찾기 위해서는 밀도가 낮아지는 시점이 필요하여 실제 세계에서는 정확한 군집의 구조를 찾기 힘들다.					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			DBSCAN 알고리즘에는 두가지 파라미터에 대한 정의가 필요하다. 첫 번째는 주변 공간에 대한 정의이며 두 번째는 그 주변공간에 몇 개의 데이터가 존재해야 군집으로 설정할 것인지에 대한 정의가 필요하다.					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			DBSCAN 알고리즘은 군집과 노이즈를 분류하는 알고리즘으로 군집은 한 예상벡터로부터 접근 가능한 모든 데이터 집합이라고 정의된다.					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a66" class="b2 help" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a66" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">1</i>
			<span class="t2t1">
			K-means와 같은 분할 방법에서 발전하였으나, 데이터의 분포를 통해 군집을 정하는 방법이다. 			</span>
					</div>
        <br>
				<strong class="tt1">해설</strong>
		<div class="t1">
		DBSCAN은 데이터의 밀도를 통해 군집을 정하는 방법이다.				</div>
		
				
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				정답은 1번입니다.<br>
<br>
DBSCAN(Density-Based Spatial Clustering of Applications with Noise)은 밀도 기반 군집화 기법으로, 데이터의 밀도를 이용하여 군집을 형성합니다. 이 방법은 데이터가 밀집된 영역을 군집으로 식별하고, 밀도가 낮은 영역을 노이즈로 간주합니다. DBSCAN은 두 가지 주요 파라미터를 사용합니다: 첫 번째는 반경(epsilon)으로, 이는 한 점을 중심으로 하는 주변 공간의 크기를 정의합니다. 두 번째는 최소 포인트 수(minPts)로, 이는 해당 반경 내에 존재해야 하는 최소 데이터 포인트 수를 의미합니다. 이 두 파라미터를 통해 DBSCAN은 데이터의 밀도 차이를 기반으로 군집을 형성하며, 비구형(non-convex) 군집도 잘 식별할 수 있습니다. 그러나 밀도가 낮아지는 경계에서 군집을 식별하는 데 어려움이 있을 수 있습니다.<br>
<br>
1. K-means와 같은 분할 방법에서 발전하였으나, 데이터의 분포를 통해 군집을 정하는 방법이다. <br>
: DBSCAN은 K-means와 같은 분할 기반 군집화 방법과는 다르게, 데이터의 밀도를 기반으로 군집을 형성합니다. K-means는 군집의 수를 미리 정하고, 각 데이터 포인트를 가장 가까운 군집 중심에 할당하는 방식입니다. 반면, DBSCAN은 데이터의 밀집도를 이용하여 군집을 형성하며, 군집의 수를 사전에 정하지 않습니다. 따라서 선지 1은 부적절한 설명입니다.<br>
<br>
2. 군집의 경계를 찾기 위해서는 밀도가 낮아지는 시점이 필요하여 실제 세계에서는 정확한 군집의 구조를 찾기 힘들다. <br>
: DBSCAN은 밀도가 높은 영역을 군집으로 식별하고, 밀도가 낮은 영역을 노이즈로 간주합니다. 이 과정에서 군집의 경계를 찾기 위해서는 밀도가 낮아지는 시점을 식별해야 하며, 이는 실제 데이터에서 정확한 군집 구조를 찾는 데 어려움을 줄 수 있습니다. 따라서 이 설명은 DBSCAN의 특성을 잘 설명하고 있습니다.<br>
<br>
3. DBSCAN 알고리즘에는 두가지 파라미터에 대한 정의가 필요하다. 첫 번째는 주변 공간에 대한 정의이며 두 번째는 그 주변공간에 몇 개의 데이터가 존재해야 군집으로 설정할 것인지에 대한 정의가 필요하다. <br>
: DBSCAN은 두 가지 주요 파라미터인 반경(epsilon)과 최소 포인트 수(minPts)를 사용하여 군집을 형성합니다. 반경은 한 점을 중심으로 하는 주변 공간의 크기를 정의하고, 최소 포인트 수는 해당 반경 내에 존재해야 하는 최소 데이터 포인트 수를 의미합니다. 이 두 파라미터를 통해 DBSCAN은 데이터의 밀도 차이를 기반으로 군집을 형성합니다. 따라서 이 설명은 DBSCAN의 작동 원리를 잘 설명하고 있습니다.<br>
<br>
4. DBSCAN 알고리즘은 군집과 노이즈를 분류하는 알고리즘으로 군집은 한 예상벡터로부터 접근 가능한 모든 데이터 집합이라고 정의된다. <br>
: DBSCAN은 군집과 노이즈를 분류하는 알고리즘으로, 군집은 한 점으로부터 접근 가능한 모든 데이터 집합으로 정의됩니다. 이는 DBSCAN의 핵심 개념 중 하나로, 밀도가 높은 영역을 군집으로 식별하고, 밀도가 낮은 영역을 노이즈로 간주하는 방식입니다. 따라서 이 설명은 DBSCAN의 특성을 잘 설명하고 있습니다.<br>
<br>
선지 1은 DBSCAN이 K-means와 같은 분할 기반 방법에서 발전한 것처럼 설명하고 있지만, 실제로 DBSCAN은 밀도 기반 방법으로, K-means와는 다른 접근 방식을 사용합니다. K-means는 군집의 수를 미리 정하고, 각 데이터 포인트를 가장 가까운 군집 중심에 할당하는 방식인 반면, DBSCAN은 데이터의 밀도를 기반으로 군집을 형성하며, 군집의 수를 사전에 정하지 않습니다. 나머지 선지들은 DBSCAN의 특성과 작동 원리를 잘 설명하고 있습니다.<br>
<br>
따라서, 정답은 '1. K-means와 같은 분할 방법에서 발전하였으나, 데이터의 분포를 통해 군집을 정하는 방법이다.' 입니다.<br>
			</div>
			<div class="t2">
									#DBSCAN									# 밀도 기반 군집화									# 반경									# 최소 포인트 수									# 노이즈									# 비구형 군집							</div>
		</div>
		
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">4과목</span>
			<span class="g1">텍스트 마이닝</span>
			<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">67.</span>
			<span class="tt1t1">
				다음 중 데이터의 정제, 통합, 선택, 변환의 과정을 거쳐 구조화된 단계로 R의 텍스트마이닝 패키지인 tm에서 문서를 관리하는 기본 구조를 의미하는 것은 무엇인가?							</span>
		</strong>
		<span class="tt1t1">
				    </span> 
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			Corpus 					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			word cloud 					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			Dictionary					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			TDM(Term-Document Matrix)					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a67" class="b2 help" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a67" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">1</i>
			<span class="t2t1">
			Corpus 			</span>
					</div>
        <br>
				<strong class="tt1">해설</strong>
		<div class="t1">
		Corpus는 데이터마이닝의 절차 중 데이터의 정제, 통합, 선택, 변환의 과정을 거친 구조화된 단계로서 더 이상 추가적인 절차 없이 데이터마이닝 알고리즘실험에서 활용될 수 있는 상태이며, tm 패키지에서 문서를 관리하는 기본구조이다.				</div>
		
				
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				정답은 1번입니다.<br>
<br>
텍스트 마이닝은 비정형 데이터인 텍스트로부터 유의미한 정보를 추출하는 과정입니다. 이 과정은 텍스트 데이터를 구조화하여 패턴을 도출하고, 이를 통해 인사이트를 얻는 것을 목표로 합니다. 텍스트 마이닝의 핵심은 다양한 형태의 문서에서 텍스트를 추출하고, 이를 정제, 통합, 선택, 변환하여 분석 가능한 형태로 만드는 것입니다. R의 'tm' 패키지에서는 이러한 과정을 통해 문서를 관리하는 기본 구조로 'Corpus'를 사용합니다. Corpus는 텍스트 데이터를 정제하고 통합하여 구조화된 형태로 만들어, 추가적인 데이터 마이닝 알고리즘을 적용할 수 있는 상태로 준비합니다.<br>
<br>
1. Corpus <br>
: Corpus는 텍스트 마이닝에서 문서들을 관리하는 기본 구조로, 데이터의 정제, 통합, 선택, 변환 과정을 거쳐 구조화된 텍스트 데이터입니다. 이 과정은 텍스트 데이터를 분석 가능한 형태로 준비하는 것을 의미합니다. 예를 들어, 다양한 문서에서 텍스트를 추출하여 불필요한 공백을 제거하고, 소문자로 변환하며, 불용어를 처리하는 등의 전처리 과정을 거칩니다. 이러한 과정을 통해 Corpus는 데이터 마이닝 실험에 바로 활용할 수 있는 상태가 됩니다. 암기팁으로는 'Corpus는 텍스트의 집합체로, 정제된 데이터의 집합'이라고 기억하면 좋습니다.<br>
<br>
2. word cloud <br>
: Word cloud는 텍스트 데이터에서 단어의 빈도를 시각적으로 표현하는 방법입니다. 주로 단어의 크기로 빈도를 나타내며, 빈도가 높은 단어일수록 더 크게 표시됩니다. 이는 텍스트 데이터에서 중요한 단어를 한눈에 파악할 수 있게 해줍니다. 그러나 Word cloud는 데이터의 정제, 통합, 선택, 변환의 과정을 거친 구조화된 데이터가 아니라, 시각화 기법에 가깝습니다. 따라서 이 문제의 정답이 될 수 없습니다.<br>
<br>
3. Dictionary <br>
: Dictionary는 텍스트 마이닝에서 단어의 목록이나 사전을 의미합니다. 이는 텍스트 데이터에서 특정 단어의 존재 여부를 확인하거나, 단어의 의미를 분석하는 데 사용됩니다. Dictionary는 데이터의 정제, 통합, 선택, 변환의 과정을 거친 구조화된 데이터가 아니라, 단어의 집합체로서의 역할을 합니다. 따라서 이 문제의 정답이 될 수 없습니다.<br>
<br>
4. TDM(Term-Document Matrix) <br>
: TDM(Term-Document Matrix)은 문서와 단어의 관계를 행렬 형태로 표현한 것입니다. 각 행은 단어를, 각 열은 문서를 나타내며, 셀의 값은 해당 문서에서 단어의 빈도를 나타냅니다. TDM은 텍스트 데이터를 분석하기 위한 중요한 도구이지만, 데이터의 정제, 통합, 선택, 변환의 과정을 거친 구조화된 데이터 자체는 아닙니다. 따라서 이 문제의 정답이 될 수 없습니다.<br>
<br>
문제에서 묻는 것은 데이터의 정제, 통합, 선택, 변환의 과정을 거쳐 구조화된 단계로, R의 텍스트마이닝 패키지인 tm에서 문서를 관리하는 기본 구조를 의미하는 것입니다. Corpus는 이러한 과정을 거쳐 텍스트 데이터를 구조화된 형태로 만들어, 추가적인 분석이 가능하도록 준비된 상태를 의미합니다. 다른 선택지인 Word cloud, Dictionary, TDM은 각각 시각화 기법, 단어의 집합체, 문서와 단어의 관계를 나타내는 행렬로, 문제에서 요구하는 구조화된 데이터의 개념과는 다릅니다.<br>
따라서, 정답은 '1. Corpus' 입니다.<br>
			</div>
			<div class="t2">
									#텍스트 마이닝									# Corpus									# 데이터 정제									# 구조화된 데이터							</div>
		</div>
		
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">4과목</span>
			<span class="g1">연관분석</span>
			<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">68.</span>
			<span class="tt1t1">
				아래는 순대와 떡볶이의 거래 관계를 나타낸 표로, 순대/떡볶이는 순대/떡볶이를 포함하는 거래 수를 의미하고 (순대)/(떡볶이)는 순대/떡볶이를 포함하지 않은 거래 수를 의미한다. 아래 표에서 순대 구매와 떡볶이 구매에 대해 설명한 것으로 가장 적절한 것은 무엇인가?							</span>
		</strong>
		<span class="tt1t1">
						<a href="exam1view1img1.php?img=d01f32bc-b22d-ed3d-477b-345eef4540c6.png" target="_blank" rel="noopener" title="새 창" class="p1">
				<img src="/data/img/question/d01f32bc-b22d-ed3d-477b-345eef4540c6.png" alt="문제에 포함된 이미지">
			</a>
				    </span> 
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			지지도가 0.6으로 전체 구매 중 떡볶이와 순대가 같이 구매되는 경향이 높다. 					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			정확도가 0.7로 떡볶이와 순대의 구매 관련성은 높다.					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			향상도가 1보다 크므로 서로 양의 관계로 순대와 떡볶이의 연관성은 매우 높다. 					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			연관규칙 중 “떡볶이 → 순대” 보다 “순대 → 떡볶이”의 선호도가 더 높다.					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a68" class="b2 help" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a68" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">3</i>
			<span class="t2t1">
			향상도가 1보다 크므로 서로 양의 관계로 순대와 떡볶이의 연관성은 매우 높다. 			</span>
					</div>
        <br>
				<strong class="tt1">해설</strong>
		<div class="t1">
		"떡볶이 → 순대와 ""순대 → 떡볶이"" 각각 향상도는 1보다 크므로 연관성이 높음을 알 수 있다."				</div>
		
				
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				정답은 3번입니다.<br>
<br>
이 문제는 연관성 분석을 통해 떡볶이와 순대의 구매 관계를 이해하는 것입니다. 연관성 분석은 주로 장바구니 분석에 사용되며, 특정 상품이 함께 구매되는 경향을 파악하는 데 유용합니다. 이 문제에서는 지지도, 신뢰도, 향상도 등의 개념을 사용하여 두 품목 간의 관계를 분석합니다. 지지도는 전체 거래 중 두 품목이 함께 구매된 비율을 나타내고, 신뢰도는 특정 품목이 구매되었을 때 다른 품목이 함께 구매될 확률을 의미합니다. 향상도는 두 품목의 구매가 서로 독립적인 경우와 비교하여 얼마나 더 자주 함께 구매되는지를 나타냅니다. 표를 통해 떡볶이와 순대의 구매 데이터를 분석하여 각 선지의 진위를 판단합니다.<br>
<br>
1. 지지도가 0.6으로 전체 구매 중 떡볶이와 순대가 같이 구매되는 경향이 높다. <br>
: 지지도는 두 품목이 함께 구매된 비율을 나타냅니다. 표에서 떡볶이와 순대가 함께 구매된 경우는 2000건이며, 전체 거래는 5000건입니다. 따라서 지지도는 2000/5000 = 0.4입니다. 이는 0.6이 아니므로 선지의 설명은 틀렸습니다.<br>
<br>
2. 정확도가 0.7로 떡볶이와 순대의 구매 관련성은 높다. <br>
: 신뢰도는 특정 품목이 구매되었을 때 다른 품목이 함께 구매될 확률입니다. 떡볶이가 구매되었을 때 순대가 함께 구매된 경우는 2000건이며, 떡볶이 구매는 총 2500건입니다. 따라서 신뢰도는 2000/2500 = 0.8입니다. 이는 0.7보다 높으므로 선지의 설명은 틀렸습니다.<br>
<br>
3. 향상도가 1보다 크므로 서로 양의 관계로 순대와 떡볶이의 연관성은 매우 높다. <br>
: 향상도는 두 품목의 구매가 서로 독립적인 경우와 비교하여 얼마나 더 자주 함께 구매되는지를 나타냅니다. 향상도는 신뢰도를 두 품목의 개별 구매 확률의 곱으로 나눈 값입니다. 떡볶이와 순대의 향상도는 0.8 / (0.5 * 0.6) = 2.67로 1보다 큽니다. 이는 두 품목이 양의 관계에 있음을 나타내므로 선지의 설명이 맞습니다.<br>
<br>
4. 연관규칙 중 “떡볶이 → 순대” 보다 “순대 → 떡볶이”의 선호도가 더 높다. <br>
: 선호도는 특정 연관 규칙의 신뢰도를 비교하는 것입니다. 떡볶이 → 순대의 신뢰도는 0.8이고, 순대 → 떡볶이의 신뢰도는 0.67입니다. 따라서 떡볶이 → 순대의 선호도가 더 높습니다. 선지의 설명은 틀렸습니다.<br>
<br>
정답은 3번입니다. 향상도가 1보다 크다는 것은 두 품목이 서로 양의 관계에 있음을 의미합니다. 다른 선지들은 지지도, 신뢰도, 선호도에 대한 잘못된 해석을 포함하고 있습니다.<br>
<br>
따라서, 정답은 '3. 향상도가 1보다 크므로 서로 양의 관계로 순대와 떡볶이의 연관성은 매우 높다.' 입니다.<br>
			</div>
			<div class="t2">
									#연관성 분석									# 지지도									# 신뢰도									# 향상도									# 장바구니 분석							</div>
		</div>
		
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">4과목</span>
			<span class="g1">사회연결망 분석</span>
			<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">69.</span>
			<span class="tt1t1">
				다음 중 사회연결망 분석에서 행과 열에 다른 개체가 배열되어 있는 매트릭스로 적절한 것은?							</span>
		</strong>
		<span class="tt1t1">
				    </span> 
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			준 연결 매트릭스 					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			2원모드 매트릭스 					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			상관 매트릭스 					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			1원모드 매트릭스					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a69" class="b2 help" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a69" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">2</i>
			<span class="t2t1">
			2원모드 매트릭스 			</span>
					</div>
        <br>
				<strong class="tt1">해설</strong>
		<div class="t1">
		행과 열에 다른 개체가 배열되는 것은 2원모드 매트릭스이다.				</div>
		
				
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				정답은 2번입니다.<br>
<br>
사회연결망 분석에서 매트릭스는 네트워크의 구조를 수학적으로 표현하는 도구입니다. 이 중 2원모드 매트릭스는 행과 열에 서로 다른 개체가 배열되어 있는 형태로, 예를 들어 사람과 이벤트가 각각 행과 열에 위치하여 사람과 이벤트 간의 관계를 나타냅니다. 이는 1원모드 매트릭스와 달리, 동일한 종류의 개체가 아닌 서로 다른 종류의 개체 간의 관계를 분석할 때 사용됩니다.<br>
<br>
1. 준 연결 매트릭스 <br>
: 준 연결 매트릭스는 네트워크에서 노드 간의 연결을 나타내는 매트릭스의 한 형태로, 주로 노드 간의 직접적인 연결을 나타냅니다. 이는 행과 열에 동일한 개체가 배열되는 1원모드 매트릭스의 특성을 가집니다. 따라서 행과 열에 다른 개체가 배열되는 2원모드 매트릭스와는 다릅니다.<br>
<br>
2. 2원모드 매트릭스 <br>
: 2원모드 매트릭스는 행과 열에 서로 다른 종류의 개체가 배열되어 있는 매트릭스입니다. 예를 들어, 행에는 사람, 열에는 이벤트가 위치하여 사람과 이벤트 간의 관계를 나타냅니다. 이는 사회연결망 분석에서 두 종류의 개체 간의 관계를 분석할 때 유용합니다.<br>
<br>
3. 상관 매트릭스 <br>
: 상관 매트릭스는 변수들 간의 상관관계를 나타내는 매트릭스로, 주로 통계 분석에서 사용됩니다. 이는 행과 열에 동일한 종류의 변수들이 배열되며, 각 변수 간의 상관계수를 계산하여 나타냅니다. 따라서 행과 열에 다른 개체가 배열되는 2원모드 매트릭스와는 다릅니다.<br>
<br>
4. 1원모드 매트릭스 <br>
: 1원모드 매트릭스는 행과 열에 동일한 종류의 개체가 배열되어 있는 매트릭스로, 주로 네트워크 내의 노드 간의 관계를 나타냅니다. 이는 행과 열에 다른 개체가 배열되는 2원모드 매트릭스와는 다릅니다.<br>
<br>
2원모드 매트릭스는 행과 열에 서로 다른 종류의 개체가 배열되어 있는 매트릭스입니다. 이는 문제에서 요구하는 조건과 일치합니다. 반면, 준 연결 매트릭스, 상관 매트릭스, 1원모드 매트릭스는 모두 행과 열에 동일한 종류의 개체가 배열되는 형태로, 문제의 조건과 맞지 않습니다.<br>
<br>
따라서, 정답은 '2. 2원모드 매트릭스' 입니다.<br>
			</div>
			<div class="t2">
									#사회연결망 분석									# 2원모드 매트릭스									# 행과 열									# 개체									# 관계							</div>
		</div>
		
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">4과목</span>
			<span class="g1">사회연결망 분석</span>
			<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">70.</span>
			<span class="tt1t1">
				다음 중 사회연결망 분석 시, 한 노드에 직접적으로 연결된 노드들의 합으로 얻어지며, 한 노드에 얼마나 많은 노드들이 관계를 맺고 있는지를 기준으로 그 노드가 중심에 위치하는 정도를 계량화한 것은?							</span>
		</strong>
		<span class="tt1t1">
				    </span> 
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			연결정도 중심성 					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			근접 중심성 					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			매개 중심성 					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			위세 중심성					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a70" class="b2 help" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a70" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">1</i>
			<span class="t2t1">
			연결정도 중심성 			</span>
					</div>
        <br>
				<strong class="tt1">해설</strong>
		<div class="t1">
		연결정도 중심성은 한 노드에 직접적으로 연결된 노드들의 합으로 얻어지며, 한 노드에 얼마나 많은 노드들이 관계를 맺고 있는지를 기준으로 그 노드가 중심에 위치하는 정도를 계량화 한 것이다.				</div>
		
				
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				정답은 1번입니다.<br>
<br>
사회연결망 분석(Social Network Analysis)은 개인과 집단 간의 관계를 노드와 링크로 모델링하여 그 구조와 확산 과정을 계량적으로 분석하는 방법론입니다. 이 분석에서 중심성은 네트워크 내에서 특정 노드의 중요성을 측정하는 지표로 사용됩니다. 중심성의 종류에는 연결정도 중심성, 근접 중심성, 매개 중심성, 위세 중심성이 있습니다. 연결정도 중심성은 한 노드에 직접적으로 연결된 노드들의 수를 통해 그 노드의 중심성을 평가합니다. 즉, 연결된 노드가 많을수록 그 노드의 연결정도 중심성이 높아집니다.<br>
<br>
1. 연결정도 중심성 <br>
: 연결정도 중심성은 한 노드에 직접적으로 연결된 다른 노드들의 수를 통해 그 노드의 중심성을 평가하는 방법입니다. 네트워크에서 한 노드가 얼마나 많은 다른 노드와 직접적으로 연결되어 있는지를 측정하며, 연결된 노드의 수가 많을수록 그 노드의 연결정도 중심성이 높아집니다. 이 중심성은 네트워크 내에서 노드의 영향력이나 중요성을 단순히 연결 수로 평가하는 데 유용합니다.<br>
<br>
2. 근접 중심성 <br>
: 근접 중심성은 한 노드가 네트워크 내의 다른 모든 노드에 얼마나 빠르게 도달할 수 있는지를 측정합니다. 이는 한 노드로부터 다른 노드에 도달하기까지 필요한 최소 단계의 합으로 계산됩니다. 근접 중심성이 높을수록 그 노드는 네트워크의 중앙에 위치하며, 정보나 자원이 빠르게 전달될 수 있는 위치에 있음을 의미합니다. 이 문제에서는 직접 연결된 노드의 수를 묻고 있으므로 오답입니다.<br>
<br>
3. 매개 중심성 <br>
: 매개 중심성은 네트워크 내에서 한 노드가 다른 노드들 사이의 경로에서 얼마나 중요한 역할을 하는지를 측정합니다. 즉, 한 노드가 다른 노드들 사이의 최단 경로에 얼마나 자주 위치하는지를 평가합니다. 매개 중심성이 높을수록 그 노드는 네트워크 내에서 중재자나 매개자로서의 역할이 큽니다. 이 문제에서는 직접 연결된 노드의 수를 묻고 있으므로 오답입니다.<br>
<br>
4. 위세 중심성 <br>
: 위세 중심성은 한 노드의 연결정도 중심성뿐만 아니라 그 노드와 연결된 다른 노드들의 중요성까지 고려하여 중심성을 평가합니다. 즉, 영향력 있는 노드들과 많이 연결될수록 자신의 위세 중심성도 높아집니다. 이는 단순히 연결 수가 아닌 연결된 노드들의 중요성까지 반영하는 지표입니다. 이 문제에서는 직접 연결된 노드의 수를 묻고 있으므로 오답입니다.<br>
<br>
정답은 '연결정도 중심성'입니다. 이는 한 노드에 직접적으로 연결된 노드들의 수를 통해 그 노드의 중심성을 평가하는 방법으로, 문제에서 묻고 있는 '한 노드에 얼마나 많은 노드들이 관계를 맺고 있는지를 기준으로 그 노드가 중심에 위치하는 정도'와 정확히 일치합니다. 나머지 선지들은 각각 다른 중심성의 개념을 설명하고 있으며, 직접 연결된 노드의 수를 기준으로 하지 않기 때문에 오답입니다.<br>
<br>
따라서, 정답은 '1. 연결정도 중심성' 입니다.<br>
			</div>
			<div class="t2">
									#사회연결망 분석									# 연결정도 중심성									# 근접 중심성									# 매개 중심성									# 위세 중심성							</div>
		</div>
		
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">5과목</span>
			<span class="g1">활용(3단계)</span>
			<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">71.</span>
			<span class="tt1t1">
				인사이트의 발전과 확장에 대한 설명으로 부적절한 것은?							</span>
		</strong>
		<span class="tt1t1">
				    </span> 
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			처음으로 무언가를 살펴볼 때에는 보텀업 방식이 적절하다.					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			데이터가 많아질수록 실시간으로 처리할 수 있는 탐색과 분석의 수준은 낮아진다. 					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			몇 가지의 지표에만 집중해도 관계들을 통해 나타나는 전체적인 흐름을 알 수 있다. 					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			다양한 시각화의 오류를 피하기 위해서는 하나의 관점에서 깊게 고려해야 한다.					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a71" class="b2 help" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a71" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">4</i>
			<span class="t2t1">
			다양한 시각화의 오류를 피하기 위해서는 하나의 관점에서 깊게 고려해야 한다.			</span>
					</div>
        <br>
				<strong class="tt1">해설</strong>
		<div class="t1">
		다양한 시각화의 오류와 문제점을 피하기 위해서는 최대한 여러 관점에서 신중하게 고려해야 한다.				</div>
		
				
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				정답은 4번입니다.<br>
<br>
이 문제는 인사이트의 발전과 확장에 대한 이해를 평가합니다. 인사이트는 데이터를 분석하여 유의미한 정보를 도출하는 과정으로, 다양한 방법론과 접근 방식을 통해 발전할 수 있습니다.<br>
<br>
1. 처음으로 무언가를 살펴볼 때에는 보텀업 방식이 적절하다.<br>
: 보텀업 방식은 세부적인 데이터나 요소를 먼저 분석하여 전체적인 그림을 이해하는 접근법입니다. 이는 처음 데이터를 분석할 때 유용할 수 있습니다.<br>
<br>
2. 데이터가 많아질수록 실시간으로 처리할 수 있는 탐색과 분석의 수준은 낮아진다.<br>
: 데이터의 양이 많아질수록 실시간 처리의 어려움이 증가할 수 있습니다. 이는 데이터 처리 기술의 발전에 따라 달라질 수 있지만, 일반적으로 데이터가 많아지면 처리 속도가 느려질 수 있습니다.<br>
<br>
3. 몇 가지의 지표에만 집중해도 관계들을 통해 나타나는 전체적인 흐름을 알 수 있다.<br>
: 몇 가지 주요 지표를 통해 전체적인 흐름을 파악할 수 있는 것은 데이터 분석의 장점 중 하나입니다. 이는 데이터의 상관관계와 패턴을 통해 가능해집니다.<br>
<br>
4. 다양한 시각화의 오류를 피하기 위해서는 하나의 관점에서 깊게 고려해야 한다.<br>
: 다양한 시각화의 오류를 피하기 위해서는 여러 관점에서 데이터를 분석하는 것이 중요합니다. 하나의 관점에만 의존하면 편향된 결과를 초래할 수 있습니다.<br>
<br>
<br>
정답은 4번입니다. 다양한 시각화의 오류를 피하기 위해서는 여러 관점에서 데이터를 분석해야 합니다. 하나의 관점에만 의존하면 편향된 결과를 초래할 수 있기 때문에, 이는 부적절한 설명입니다. 다른 선택지들은 각각의 상황에서 적절한 설명을 제공하고 있습니다.<br>
<br>
따라서, 정답은 '4. 다양한 시각화의 오류를 피하기 위해서는 하나의 관점에서 깊게 고려해야 한다.' 입니다.<br>
			</div>
			<div class="t2">
									#인사이트									# 데이터 분석									# 보텀업									# 시각화 오류							</div>
		</div>
		
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">5과목</span>
			<span class="g1">분석 도구를 이용한 시각화 구현 : R</span>
			<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">72.</span>
			<span class="tt1t1">
				시각화 도구 R을 이용해 시각화 그래프를 구현하고자 한다. 이 때 사용가능한 명령어로 가장 부적절한 것은? (단, /는 enter의 의미로 사용되었다.)							</span>
		</strong>
		<span class="tt1t1">
				    </span> 
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			axis(2, ylim=c(0, max(grp)), lwd=2, line=7) 					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			states &lt;- data.frame(state.name, state.x77)					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			var group=svg.append("g") / .attr(“transform”, “translate(200, 200)”) 					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			geom_bar(colour="white", fill="red")					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a72" class="b2 help" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a72" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">3</i>
			<span class="t2t1">
			var group=svg.append("g") / .attr(“transform”, “translate(200, 200)”) 			</span>
					</div>
        <br>
				<strong class="tt1">해설</strong>
		<div class="t1">
		D3.js의 명령어이다.				</div>
		
				
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				정답은 3번입니다.<br>
<br>
R은 데이터 분석과 시각화를 위한 강력한 도구로, 다양한 그래프와 차트를 생성할 수 있는 여러 패키지와 함수들을 제공합니다. 기본적으로 R의 그래픽 시스템은 'base', 'lattice', 'ggplot2'와 같은 패키지를 통해 다양한 시각화 기능을 지원합니다. 'axis()' 함수는 그래프의 축을 설정하는 데 사용되며, 'geom_bar()'는 ggplot2 패키지에서 막대 그래프를 그리는 데 사용됩니다. 데이터 프레임은 R에서 데이터를 구조화하여 저장하는 기본적인 방법입니다. 반면, 'svg.append()'와 같은 명령어는 R이 아닌 D3.js와 같은 JavaScript 라이브러리에서 사용되는 것으로, R의 시각화 명령어와는 다릅니다.<br>
<br>
1. axis(2, ylim=c(0, max(grp)), lwd=2, line=7) <br>
: R의 'axis()' 함수는 그래프의 축을 설정하는 데 사용됩니다. 이 함수는 그래프의 특정 축에 눈금을 추가하거나 조정할 수 있는 기능을 제공합니다. 예를 들어, 'axis(2, ylim=c(0, max(grp)), lwd=2, line=7)'는 y축에 대해 눈금을 설정하고, 선의 두께와 위치를 조정하는 데 사용됩니다. 이는 R의 기본 그래픽 시스템에서 자주 사용되는 명령어입니다.<br>
<br>
2. states &lt;- data.frame(state.name, state.x77) <br>
: 데이터 프레임은 R에서 데이터를 저장하고 조작하는 기본적인 구조입니다. 'states &lt;- data.frame(state.name, state.x77)'는 'state.name'과 'state.x77'이라는 두 개의 벡터를 결합하여 데이터 프레임을 생성하는 코드입니다. 이는 R에서 데이터를 구조화하여 분석할 때 매우 유용한 방법입니다.<br>
<br>
3. var group=svg.append("g") / .attr(“transform”, “translate(200, 200)”) <br>
: 이 명령어는 R이 아닌 D3.js와 같은 JavaScript 기반의 시각화 라이브러리에서 사용되는 코드입니다. 'var group=svg.append("g") / .attr("transform", "translate(200, 200)")'는 SVG 요소에 그룹을 추가하고, 해당 그룹의 위치를 변환하는 데 사용됩니다. 이는 R의 시각화 명령어와는 관련이 없습니다.<br>
<br>
4. geom_bar(colour="white", fill="red") <br>
: ggplot2 패키지의 'geom_bar()' 함수는 막대 그래프를 생성하는 데 사용됩니다. 'geom_bar(colour="white", fill="red")'는 막대의 테두리 색상을 흰색으로, 채우기 색상을 빨간색으로 설정하여 막대 그래프를 그립니다. 이는 R의 ggplot2 패키지에서 시각화를 구현할 때 자주 사용되는 명령어입니다.<br>
<br>
정답은 '3'입니다. 'var group=svg.append("g") / .attr("transform", "translate(200, 200)")'는 R의 시각화 명령어가 아니라 D3.js와 같은 JavaScript 라이브러리에서 사용되는 코드입니다. 나머지 선지들은 모두 R에서 시각화를 구현할 때 사용되는 명령어들입니다. 'axis()'와 'geom_bar()'는 각각 R의 기본 그래픽 시스템과 ggplot2 패키지에서 사용되며, 데이터 프레임 생성은 R의 데이터 구조화 방법입니다.<br>
따라서, 정답은 '3. var group=svg.append("g") / .attr(“transform”, “translate(200, 200)”)' 입니다.<br>
			</div>
			<div class="t2">
									#R									# 시각화									# axis									# 데이터 프레임									# ggplot2									# D3.js									# JavaScript							</div>
		</div>
		
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">5과목</span>
			<span class="g1">시각화 프로세스</span>
			<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">73.</span>
			<span class="tt1t1">
				정보 디자인의 빅데이터 시각화 영역에 대한 설명으로 가장 부적절한 것은?							</span>
		</strong>
		<span class="tt1t1">
				    </span> 
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			데이터 시각화의 주요 목적은 그래픽 의미를 이용해 명확하고 효과적으로 커뮤니케이션하기 위함이다.					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			정보 시각화는 보는 사람들이 좀 더 명확하게 의미를 이해할 수 있도록 돕는다.					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			정보 디자인은 사람이 사용할 수 있는 효과적인 정보와 복잡하고 구조적이지 않은 기술 데이터를 시각적으로 표현하는 방법을 의미한다.					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			인포그래픽은 중요한 정보를 여러 장의 그래픽으로 표현해 손쉽게 해당 정보를 이해할 수 있도록 하는 그래픽 메시지이다.					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a73" class="b2 help" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a73" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">4</i>
			<span class="t2t1">
			인포그래픽은 중요한 정보를 여러 장의 그래픽으로 표현해 손쉽게 해당 정보를 이해할 수 있도록 하는 그래픽 메시지이다.			</span>
					</div>
        <br>
				<strong class="tt1">해설</strong>
		<div class="t1">
		인포그래픽은 중요한 정보를 여러 장이 아닌 한 장의 그래픽으로 표현한다.				</div>
		
				
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				정답은 4번입니다.<br>
<br>
정보 디자인의 빅데이터 시각화 영역은 데이터를 시각적으로 표현하여 정보를 명확하고 효과적으로 전달하는 것을 목표로 합니다. 데이터 시각화는 복잡한 데이터를 이해하기 쉽게 변환하여 전달하는 과정이며, 정보 시각화는 더 큰 범주의 정보를 시각적으로 표현하여 이해를 돕습니다. 인포그래픽은 이러한 시각화의 한 형태로, 복잡한 정보를 쉽게 이해할 수 있도록 그래픽으로 표현합니다. 빅데이터 시각화는 특히 데이터의 객관적 표현에 중점을 두며, 정보의 기능적 전달을 목표로 합니다.<br>
<br>
1. 데이터 시각화의 주요 목적은 그래픽 의미를 이용해 명확하고 효과적으로 커뮤니케이션하기 위함이다. <br>
: 데이터 시각화의 주요 목적은 그래픽을 통해 명확하고 효과적으로 정보를 전달하는 것입니다. 이는 복잡한 데이터를 시각적으로 변환하여 쉽게 이해할 수 있도록 돕는 과정입니다. 예를 들어, 대량의 숫자 데이터를 차트나 그래프로 표현하면, 데이터의 패턴이나 트렌드를 쉽게 파악할 수 있습니다. 이 과정은 데이터의 본질을 왜곡하지 않고 전달하는 데 중점을 둡니다.<br>
<br>
2. 정보 시각화는 보는 사람들이 좀 더 명확하게 의미를 이해할 수 있도록 돕는다. <br>
: 정보 시각화는 데이터를 포함한 더 큰 범주의 정보를 시각적으로 표현하여 사람들이 의미를 명확하게 이해할 수 있도록 돕습니다. 이는 복잡한 정보나 데이터를 시각적으로 정리하여, 사용자가 쉽게 이해할 수 있도록 하는 것입니다. 예를 들어, 복잡한 시스템의 작동 원리를 다이어그램으로 표현하면, 시스템의 구조와 작동 방식을 쉽게 이해할 수 있습니다.<br>
<br>
3. 정보 디자인은 사람이 사용할 수 있는 효과적인 정보와 복잡하고 구조적이지 않은 기술 데이터를 시각적으로 표현하는 방법을 의미한다. <br>
: 정보 디자인은 사용자가 정보를 효과적으로 사용할 수 있도록 시각적으로 표현하는 방법을 의미합니다. 이는 복잡하고 구조적이지 않은 데이터를 시각적으로 정리하여, 사용자가 쉽게 이해하고 활용할 수 있도록 돕습니다. 예를 들어, 복잡한 기술 문서를 인포그래픽으로 표현하면, 기술적 내용을 쉽게 전달할 수 있습니다.<br>
<br>
4. 인포그래픽은 중요한 정보를 여러 장의 그래픽으로 표현해 손쉽게 해당 정보를 이해할 수 있도록 하는 그래픽 메시지이다. <br>
: 인포그래픽은 정보를 여러 장의 그래픽으로 표현하여 쉽게 이해할 수 있도록 하는 것입니다. 그러나 빅데이터 시각화에서는 데이터의 객관적 표현에 중점을 두기 때문에, 인포그래픽은 빅데이터 시각화에 포함되지 않는 경우가 많습니다. 인포그래픽은 주로 설득형 메시지를 전달하는 데 사용되며, 빅데이터 시각화는 정보형 메시지를 전달하는 데 중점을 둡니다.<br>
<br>
선지 4는 인포그래픽이 빅데이터 시각화에 포함되지 않는 경우가 많다는 점에서 부적절합니다. 빅데이터 시각화는 데이터의 객관적 표현에 중점을 두며, 인포그래픽은 설득형 메시지를 전달하는 데 사용되기 때문에, 두 개념은 목적과 사용 방식에서 차이가 있습니다. 다른 선지들은 정보 디자인과 시각화의 목적과 방법을 적절히 설명하고 있습니다.<br>
따라서, 정답은 '4. 인포그래픽은 중요한 정보를 여러 장의 그래픽으로 표현해 손쉽게 해당 정보를 이해할 수 있도록 하는 그래픽 메시지이다.' 입니다.<br>
			</div>
			<div class="t2">
									#정보 디자인									# 데이터 시각화									# 정보 시각화									# 인포그래픽									# 빅데이터 시각화							</div>
		</div>
		
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">5과목</span>
			<span class="g1">시각화 방법</span>
			<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">74.</span>
			<span class="tt1t1">
				아래 그래프는 네임보이저에서 공개하는 100년이 넘는 아기 이름 데이터베이스를 시각화한 것이다. 아래와 같은 시각화 그래프에 대한 설명으로 가장 부적절한 것은?							</span>
		</strong>
		<span class="tt1t1">
						<a href="exam1view1img1.php?img=d78b61b3-2cd9-1842-ea7f-307dc1a42527.png" target="_blank" rel="noopener" title="새 창" class="p1">
				<img src="/data/img/question/d78b61b3-2cd9-1842-ea7f-307dc1a42527.png" alt="문제에 포함된 이미지">
			</a>
				    </span> 
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			분포 시각화의 한 종류로, 몇 개의 시계열 그래프를 차곡차곡 쌓아 올려 그려 빈 공간을 채워 만든 것이다.					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			가로축은 시간을 나타내며 세로축은 데이터 값을 나타낸다.					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			한 구간이 몇 개의 세부 항목으로 나뉘면서도 전체의 합이 의미가 있는 경우에 사용한다. 					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			한 시점의 세로 단면을 가져오면 그 시점의 분포를 볼 수 있다.					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a74" class="b2 help" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a74" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">3</i>
			<span class="t2t1">
			한 구간이 몇 개의 세부 항목으로 나뉘면서도 전체의 합이 의미가 있는 경우에 사용한다. 			</span>
					</div>
        <br>
				<strong class="tt1">해설</strong>
		<div class="t1">
		누적 막대그래프에 대한 설명이다.				</div>
		
				
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				1. 이 그래프는 여러 개의 시계열 그래프를 쌓아 올려 데이터를 시각화하는 분포 시각화의 일종입니다. 각 선은 시간이 지남에 따라 데이터 값을 나타냅니다. 따라서 이 설명은 적절합니다.<br>
<br>
2. 그래프에서 가로축은 시간의 흐름을 나타내고 세로축은 데이터 값을 나타냅니다. 이 그래프는 시간에 따른 데이터의 변화를 시각화합니다. 따라서 이 설명도 적절합니다.<br>
<br>
3. 이 설명은 적절하지 않습니다. 이 그래프는 주로 시간에 따른 데이터의 변화를 시각화하는 데 사용되며, 각 선이 독립적인 값을 나타냅니다. 전체의 합의 의미를 강조하는 그래프는 스택드 바 차트(Stacked Bar Chart) 또는 스택드 에어리어 차트(Stacked Area Chart)와 유사하지만, 이 그래프는 그런 용도로 사용되지 않습니다.<br>
<br>
4. 이 그래프에서 한 시점의 세로 단면을 보면, 그 시점의 데이터 값들을 볼 수 있습니다. 따라서 이 설명도 적절합니다.<br>
			</div>
			<div class="t2">
									#시각화 그래프									# 분포 시각화							</div>
		</div>
		
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">5과목</span>
			<span class="g1">라이브러리 기반의 시각화 구현 : D3.js</span>
			<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">75.</span>
			<span class="tt1t1">
				D3.js의 함수와 그 특징의 연결이 가장 적절한 것은?							</span>
		</strong>
		<span class="tt1t1">
				    </span> 
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			domain( ) : scale 출력값의 범위 지정					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			ticks( ) : 축의 눈금 단위를 지정					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			range( ) : scale 입력값의 범위 지정					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			array( ) : 배열의 최솟값과 최댓값을 찾아 반환					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a75" class="b2 help" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a75" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">2</i>
			<span class="t2t1">
			ticks( ) : 축의 눈금 단위를 지정			</span>
					</div>
        <br>
				<strong class="tt1">해설</strong>
		<div class="t1">
		ticks( ) - 축의 눈금 단위를 지정하는 함수이다. domain( ) - scale 입력값의 범위 지정 / range( ) - scale 출력값의 범위 지정 / extent( ) - 배열의 최솟값과 최댓값을 찾아 반환하는 함수				</div>
		
				
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				정답은 2번입니다.<br>
<br>
D3.js는 데이터 시각화를 위한 JavaScript 라이브러리로, 다양한 함수들이 제공됩니다. 각 함수는 특정한 역할을 하며, 데이터의 입력과 출력, 시각적 요소의 설정 등을 담당합니다.<br>
<br>
1. domain( ) : scale 출력값의 범위 지정<br>
: domain() 함수는 scale의 입력값의 범위를 지정하는 데 사용됩니다. 이는 데이터의 최소값과 최대값을 설정하여, 데이터가 어떻게 시각화될지를 결정합니다.<br>
<br>
2. ticks( ) : 축의 눈금 단위를 지정<br>
: ticks() 함수는 축의 눈금 단위를 지정하는 데 사용됩니다. 이는 그래프의 축에 표시될 눈금의 개수나 간격을 설정하여, 데이터의 가독성을 높입니다.<br>
<br>
3. range( ) : scale 입력값의 범위 지정<br>
: range() 함수는 scale의 출력값의 범위를 지정하는 데 사용됩니다. 이는 시각적 요소가 화면에 어떻게 나타날지를 결정하는 중요한 역할을 합니다.<br>
<br>
4. array( ) : 배열의 최솟값과 최댓값을 찾아 반환<br>
: array() 함수는 D3.js의 기본 함수가 아니며, 배열의 최솟값과 최댓값을 찾는 기능은 d3.min()과 d3.max() 함수를 통해 수행됩니다.<br>
<br>
<br>
ticks() 함수는 축의 눈금 단위를 지정하는 데 사용되므로, 보기 2가 가장 적절합니다. domain()과 range() 함수는 각각 입력값과 출력값의 범위를 지정하는 데 사용되며, array()는 D3.js의 함수가 아닙니다.<br>
<br>
따라서, 정답은 '2. ticks( ) : 축의 눈금 단위를 지정' 입니다.<br>
			</div>
			<div class="t2">
									#D3.js									# domain									# ticks									# range									# array							</div>
		</div>
		
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">5과목</span>
			<span class="g1">빅데이터와 시각화 디자인</span>
			<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">76.</span>
			<span class="tt1t1">
				빅데이터 시각화 영역에 대한 설명으로 가장 부적절한 것은?							</span>
		</strong>
		<span class="tt1t1">
				    </span> 
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			메시지 전달 관점에서 데이터 시각화는 큰 범주에 해당하는 정보를 시각화하는 것이다.					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			빅데이터 시각화에서는 데이터를 직접적으로 전달하는 기능성에 초점을 맞춘 정보형 메시지를 전달하기 위한 데이터 시각화 작업을 하는 경향이 강하다.					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			데이터 자체보다는 데이터를 기초로 해석된 의미의 설득형 메시지를 전달하기 위한 경우에는 인포그래픽에 해당하는 결과물이 도출될 수 있다.					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			빅데이터 시각화의 경우에는 데이터를 기반으로 객관적 표현에 더 초점을 맞추는 경우가 많다.					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a76" class="b2 help" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a76" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">1</i>
			<span class="t2t1">
			메시지 전달 관점에서 데이터 시각화는 큰 범주에 해당하는 정보를 시각화하는 것이다.			</span>
					</div>
        <br>
				<strong class="tt1">해설</strong>
		<div class="t1">
		메시지 전달 관점에서 정보 시각화에 대한 설명이다.				</div>
		
				
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				정답은 1번입니다.<br>
<br>
빅데이터 시각화는 데이터를 효과적으로 전달하기 위해 다양한 방법을 사용합니다. 이 과정에서 정보의 기능성과 설득력을 고려하여 시각화의 목적에 맞는 적절한 형태를 선택하는 것이 중요합니다.<br>
<br>
1. 메시지 전달 관점에서 데이터 시각화는 큰 범주에 해당하는 정보를 시각화하는 것이다.<br>
: 데이터 시각화는 단순히 큰 범주의 정보를 시각화하는 것이 아니라, 데이터를 통해 전달하고자 하는 메시지를 명확히 하는 것이 중요합니다. 따라서 메시지 전달 관점에서의 시각화는 정보의 명확성과 전달력을 높이는 데 중점을 둡니다.<br>
<br>
2. 빅데이터 시각화에서는 데이터를 직접적으로 전달하는 기능성에 초점을 맞춘 정보형 메시지를 전달하기 위한 데이터 시각화 작업을 하는 경향이 강하다.<br>
: 빅데이터 시각화는 주로 데이터를 직접적으로 전달하는 데 초점을 맞추며, 정보의 기능성을 강조합니다. 이는 데이터의 정확한 해석과 전달을 통해 의사결정에 도움을 주기 위함입니다.<br>
<br>
3. 데이터 자체보다는 데이터를 기초로 해석된 의미의 설득형 메시지를 전달하기 위한 경우에는 인포그래픽에 해당하는 결과물이 도출될 수 있다.<br>
: 데이터 시각화는 데이터를 기반으로 해석된 의미를 전달할 때 설득력을 높이기 위해 인포그래픽과 같은 형태를 사용할 수 있습니다. 이는 시각적 요소를 통해 메시지를 효과적으로 전달하려는 목적을 가집니다.<br>
<br>
4. 빅데이터 시각화의 경우에는 데이터를 기반으로 객관적 표현에 더 초점을 맞추는 경우가 많다.<br>
: 빅데이터 시각화는 객관적인 데이터 표현에 중점을 두며, 데이터의 신뢰성과 정확성을 유지하는 것이 중요합니다. 이는 데이터 기반의 의사결정을 지원하기 위한 필수적인 요소입니다.<br>
<br>
<br>
첫 번째 선택지는 데이터 시각화의 본질을 오해하고 있습니다. 데이터 시각화는 단순히 큰 범주의 정보를 시각화하는 것이 아니라, 전달하고자 하는 메시지를 명확히 하고, 정보의 기능성과 설득력을 높이는 데 중점을 둡니다. 다른 선택지들은 빅데이터 시각화의 목적과 방법을 적절히 설명하고 있습니다.<br>
<br>
따라서, 정답은 '1. 메시지 전달 관점에서 데이터 시각화는 큰 범주에 해당하는 정보를 시각화하는 것이다.' 입니다.<br>
			</div>
			<div class="t2">
									#빅데이터 시각화									# 메시지 전달									# 정보의 기능성									# 인포그래픽							</div>
		</div>
		
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">5과목</span>
			<span class="g1">시각화 구현 개요</span>
			<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">77.</span>
			<span class="tt1t1">
				시각화 플랫폼에 대한 설명 중 적절하지 않은 것은?							</span>
		</strong>
		<span class="tt1t1">
				    </span> 
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			Conos Insight, PowerPivot등은 API로 코드를 작성해 시각화를 구현해야 한다.					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			사용자가 다양한 관점에서 인사이트를 얻을 수 있도록 ‘지식 시각화’ 관점에서 데이터 시각화 기능을 지원한다.					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			기존의 BI 플랫폼은 주로 데이터 분석, 마이닝 등의 기법을 통해 일정한 방식의 결과 리포트를 생성하기 위해 시각화 기술을 활용했다.					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			주로 BI분야에서 활용되기 때문에 다차원적 데이터 분석 결과를 시각화하고, 보고서로 생성하는 기능 등을 지원하는 경우가 많다.					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a77" class="b2 help" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a77" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">1</i>
			<span class="t2t1">
			Conos Insight, PowerPivot등은 API로 코드를 작성해 시각화를 구현해야 한다.			</span>
					</div>
        <br>
				<strong class="tt1">해설</strong>
		<div class="t1">
		플랫폼에서 제공하는 기능·명령어를 실행해 시각화할 수 있다. 라이브러리가 제공하는 API로 코드를 작성해 시각화하는 것은 시각화 라이브러리에 관한 설명이다.				</div>
		
				
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				정답은 1번입니다.<br>
<br>
시각화 플랫폼은 데이터를 시각적으로 표현하여 사용자가 쉽게 이해할 수 있도록 돕는 도구입니다. 이러한 플랫폼은 다양한 기능을 제공하며, 사용자의 필요에 따라 적절한 도구를 선택하는 것이 중요합니다.<br>
<br>
1. Conos Insight, PowerPivot등은 API로 코드를 작성해 시각화를 구현해야 한다.<br>
: Conos Insight와 PowerPivot은 주로 사용자가 직접 코드를 작성하지 않고도 시각화를 구현할 수 있는 도구입니다. API를 통해 코드를 작성해야 한다는 설명은 부적절합니다.<br>
<br>
2. 사용자가 다양한 관점에서 인사이트를 얻을 수 있도록 ‘지식 시각화’ 관점에서 데이터 시각화 기능을 지원한다.<br>
: 지식 시각화는 데이터를 다양한 관점에서 분석하고 인사이트를 얻을 수 있도록 돕는 기능을 포함합니다. 이는 시각화 플랫폼의 중요한 기능 중 하나입니다.<br>
<br>
3. 기존의 BI 플랫폼은 주로 데이터 분석, 마이닝 등의 기법을 통해 일정한 방식의 결과 리포트를 생성하기 위해 시각화 기술을 활용했다.<br>
: 기존의 BI 플랫폼은 데이터 분석과 마이닝을 통해 결과를 도출하고 이를 시각화하여 리포트로 생성하는 데 중점을 두었습니다. 이는 일반적인 BI 플랫폼의 특징입니다.<br>
<br>
4. 주로 BI분야에서 활용되기 때문에 다차원적 데이터 분석 결과를 시각화하고, 보고서로 생성하는 기능 등을 지원하는 경우가 많다.<br>
: BI 분야에서 시각화 플랫폼은 다차원적 데이터 분석 결과를 시각화하고 보고서로 생성하는 기능을 지원합니다. 이는 BI 플랫폼의 일반적인 기능입니다.<br>
<br>
<br>
Conos Insight와 PowerPivot은 사용자가 직접 코드를 작성하지 않고도 시각화를 구현할 수 있는 도구입니다. 따라서 'API로 코드를 작성해 시각화를 구현해야 한다'는 설명은 부적절합니다. 다른 선택지들은 시각화 플랫폼의 일반적인 기능과 특징을 잘 설명하고 있습니다.<br>
<br>
따라서, 정답은 '1. Conos Insight, PowerPivot등은 API로 코드를 작성해 시각화를 구현해야 한다.' 입니다.<br>
			</div>
			<div class="t2">
									#시각화 플랫폼									# BI 플랫폼									# 데이터 시각화									# 지식 시각화							</div>
		</div>
		
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">5과목</span>
			<span class="g1">시각화 구현 개요</span>
			<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">78.</span>
			<span class="tt1t1">
				분석 도구를 이용한 시각화 구현에 대한 설명으로 가장 부적절한 것은?							</span>
		</strong>
		<span class="tt1t1">
				    </span> 
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			시각화에 쓰이는 패키지는 ggplot2이다.					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			geom_histogram() 함수는 연속형 변수의 분포를 시각화할 때 사용할 수 있다.					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			모자이크 플롯은 단수의 categorical variable 분포 파악에 도움이 된다. 					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			내부 색상을 바꾸고 싶은 경우에는 fill을 이용할 수 있다.					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a78" class="b2 help" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a78" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">3</i>
			<span class="t2t1">
			모자이크 플롯은 단수의 categorical variable 분포 파악에 도움이 된다. 			</span>
					</div>
        <br>
				<strong class="tt1">해설</strong>
		<div class="t1">
		모자이크 플롯은 복수의 categorical variable 분포 파악에 도움이 된다.				</div>
		
				
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				정답은 3번입니다.<br>
<br>
시각화 도구와 기법에 대한 이해는 데이터 분석에서 매우 중요합니다. 다양한 시각화 기법은 데이터의 특성에 따라 적절히 선택되어야 하며, 각 기법의 특성과 용도를 정확히 이해하는 것이 필요합니다.<br>
<br>
1. 시각화에 쓰이는 패키지는 ggplot2이다.<br>
: ggplot2는 R에서 널리 사용되는 시각화 패키지로, 다양한 그래프를 생성할 수 있는 강력한 도구입니다. 데이터의 시각적 표현을 위해 다양한 옵션과 기능을 제공하여 사용자가 원하는 형태로 그래프를 커스터마이즈할 수 있습니다.<br>
<br>
2. geom_histogram() 함수는 연속형 변수의 분포를 시각화할 때 사용할 수 있다.<br>
: geom_histogram()은 ggplot2 패키지에서 제공하는 함수로, 히스토그램을 그리는 데 사용됩니다. 히스토그램은 연속형 데이터를 구간(bin)으로 나누어 각 구간에 속하는 데이터 개수를 막대의 높이로 표현합니다. 데이터의 분포, 치우침(skewness), 이상치 등을 파악하는 데 유용합니다.<br>
<br>
3. 모자이크 플롯은 단수의 categorical variable 분포 파악에 도움이 된다.<br>
: 모자이크 플롯은 두 개 이상의 범주형 변수 간의 관계를 시각화하는 데 유용합니다. 단일 범주형 변수의 분포를 파악하는 데는 적합하지 않으며, 주로 교차표 형태의 데이터를 시각적으로 표현하는 데 사용됩니다.<br>
<br>
4. 내부 색상을 바꾸고 싶은 경우에는 fill을 이용할 수 있다.<br>
: 시각화에서 내부 색상을 변경하는 것은 데이터의 가독성을 높이는 데 중요한 요소입니다. ggplot2에서는 'fill' 옵션을 사용하여 그래프의 내부 색상을 변경할 수 있으며, 이를 통해 데이터의 특정 부분을 강조하거나 구분할 수 있습니다.<br>
<br>
<br>
모자이크 플롯은 단일 범주형 변수의 분포를 파악하는 데 적합하지 않으며, 주로 두 개 이상의 범주형 변수 간의 관계를 시각화하는 데 사용됩니다. 따라서 이 설명은 부적절합니다. 다른 선택지들은 각각의 시각화 기법과 관련된 적절한 설명을 제공하고 있습니다.<br>
<br>
따라서, 정답은 '3. 모자이크 플롯은 단수의 categorical variable 분포 파악에 도움이 된다.' 입니다.<br>
			</div>
			<div class="t2">
									#시각화									# ggplot2									# 히스토그램									# 모자이크 플롯							</div>
		</div>
		
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">5과목</span>
			<span class="g1">시각화 방법</span>
			<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">79.</span>
			<span class="tt1t1">
				정보의 조직화 과정에서 3단계에 해당하는 것은?							</span>
		</strong>
		<span class="tt1t1">
				    </span> 
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			분류					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			배열 					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			데이터 수집 					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			관계 맺기					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a79" class="b2 help" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a79" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">2</i>
			<span class="t2t1">
			배열 			</span>
					</div>
        <br>
				<strong class="tt1">해설</strong>
		<div class="t1">
		정보의 조직화 과정은 ‘데이터 수집 – 분류 – 배열 – 관계 맺기’이다.				</div>
		
				
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				정보의 조직화는 데이터를 수집하는 과정을 거쳐 혼돈의 상태로 존재하는 데이터를 분류(Classifying)하고 배열(Arranging)하고 조직화(Organizing)해 질서를 부여하는 작업을 의미한다.<br>
<br>
정보 조직화가 진행되는 과정은 다음과 같다.<br>
<br>
1단계 : 데이터 수집 - 데이터 자료 또는 논거를 수집<br>
2단계 : 분류 - classifying 분류해 유사한 것끼리 묶음<br>
3단계 : 배열 - arranging 값의 의미에 따라 배치<br>
4단계 : 관계맺기 - organizing 데이터 사이의 관계를 만듦<br>
<br>
따라서 3단계에 해당하는 배열이 정답이다.<br>
<br>
			</div>
			<div class="t2">
									# 정보의 조직화									# 정보의 조직화 과정							</div>
		</div>
		
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">5과목</span>
			<span class="g1">시각화 구현 개요</span>
			<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">80.</span>
			<span class="tt1t1">
				데이터에 특성화된 시각화 도구인 게피(Gephi)에 대한 설명으로 적절한 것은?							</span>
		</strong>
		<span class="tt1t1">
				    </span> 
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			캘리포니아 정보통신 연구소의 실험실에서 대규모 이미지 세트를 마치 데이터처럼 사용이 가능하고 색사, 시간, 수량에 따라 시각화해서 경향이나 변화를 탐색할 수 있다.					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			메릴랜드 대학의 인간컴퓨터의 상호작용 연구실의 인터렉티브 소프트웨어로부터 시작되었으며, 위계구조를 갖는 데이터를 작은 공간에서 탐색하는데 매우 유용하다.					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			지도 제작 그룹인 엑시스 맵이 무료로 제공하는 것으로 맞춤형 지도 제작이 가능하고 개인의 데이터를 넣을 수 있다.					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			수많은 에지와 노드로 이루어져 복잡한 모습의 네트워크 그래프나 시각화 결과물을 만들어 내는 것으로 오픈소스 그래프 소프트웨어로 사용자가 인터렉티브하게 네트워크나 구조를 탐색할 수 있도록 해준다.					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a80" class="b2 help" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a80" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">4</i>
			<span class="t2t1">
			수많은 에지와 노드로 이루어져 복잡한 모습의 네트워크 그래프나 시각화 결과물을 만들어 내는 것으로 오픈소스 그래프 소프트웨어로 사용자가 인터렉티브하게 네트워크나 구조를 탐색할 수 있도록 해준다.			</span>
					</div>
        <br>
				<strong class="tt1">해설</strong>
		<div class="t1">
		게피(Gephi)는 네트워크 형태의 데이터를 시각화할 때 유용한 시각화 도구이다.				</div>
		
				
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				정답은 4번입니다.<br>
<br>
게피(Gephi)는 네트워크 형태의 데이터를 시각화하는 데 유용한 도구입니다. 네트워크 데이터는 노드와 에지로 구성되며, 이러한 구조를 시각화하여 데이터 간의 관계를 쉽게 이해할 수 있도록 돕습니다. 게피는 오픈소스 소프트웨어로, 사용자가 인터랙티브하게 네트워크를 탐색할 수 있는 기능을 제공합니다. 이는 복잡한 네트워크 구조를 시각적으로 표현하고 분석하는 데 매우 효과적입니다.<br>
<br>
1. 캘리포니아 정보통신 연구소의 실험실에서 대규모 이미지 세트를 마치 데이터처럼 사용이 가능하고 색사, 시간, 수량에 따라 시각화해서 경향이나 변화를 탐색할 수 있다. <br>
: 이 선지는 대규모 이미지 세트를 데이터처럼 사용하여 시각화하는 도구에 대한 설명입니다. 이는 게피의 기능과는 관련이 없습니다. 게피는 이미지가 아닌 네트워크 데이터를 시각화하는 데 중점을 둡니다.<br>
<br>
2. 메릴랜드 대학의 인간컴퓨터의 상호작용 연구실의 인터렉티브 소프트웨어로부터 시작되었으며, 위계구조를 갖는 데이터를 작은 공간에서 탐색하는데 매우 유용하다. <br>
: 이 선지는 메릴랜드 대학의 연구실에서 시작된 소프트웨어로, 위계구조를 탐색하는 데 유용하다고 설명합니다. 이는 게피의 기능과는 다릅니다. 게피는 위계구조보다는 네트워크 구조를 시각화하는 데 특화되어 있습니다.<br>
<br>
3. 지도 제작 그룹인 엑시스 맵이 무료로 제공하는 것으로 맞춤형 지도 제작이 가능하고 개인의 데이터를 넣을 수 있다. <br>
: 이 선지는 지도 제작 그룹이 제공하는 맞춤형 지도 제작 도구에 대한 설명입니다. 게피는 지도 제작이 아닌 네트워크 시각화 도구이므로 이 설명과는 관련이 없습니다.<br>
<br>
4. 수많은 에지와 노드로 이루어져 복잡한 모습의 네트워크 그래프나 시각화 결과물을 만들어 내는 것으로 오픈소스 그래프 소프트웨어로 사용자가 인터렉티브하게 네트워크나 구조를 탐색할 수 있도록 해준다. <br>
: 이 선지는 게피의 기능을 정확히 설명하고 있습니다. 게피는 수많은 에지와 노드로 이루어진 복잡한 네트워크 그래프를 시각화할 수 있는 오픈소스 소프트웨어로, 사용자가 네트워크를 인터랙티브하게 탐색할 수 있도록 지원합니다.<br>
<br>
정답은 4번입니다. 게피는 네트워크 데이터를 시각화하는 데 특화된 도구로, 복잡한 네트워크 구조를 시각적으로 표현하고 탐색할 수 있는 기능을 제공합니다. 다른 선지들은 게피의 기능과 관련이 없는 다른 도구나 소프트웨어에 대한 설명입니다.<br>
따라서, 정답은 '4. 수많은 에지와 노드로 이루어져 복잡한 모습의 네트워크 그래프나 시각화 결과물을 만들어 내는 것으로 오픈소스 그래프 소프트웨어로 사용자가 인터렉티브하게 네트워크나 구조를 탐색할 수 있도록 해준다.' 입니다.<br>
			</div>
			<div class="t2">
									#게피									# 네트워크 시각화									# 오픈소스									# 인터랙티브									# 노드									# 에지							</div>
		</div>
		
	</div>
</div>
<!-- /cp1question1 -->





<a href="index.html"> &lt; 돌아가기</a>
<script>
/* === AUTO-PATCH: answer-toggle-v2 === */
(function () {
  function qsa(sel, root) { return Array.from((root || document).querySelectorAll(sel)); }
  function qs(sel, root) { return (root || document).querySelector(sel); }

  function getPanelFromBtn(btn) {
    const href = btn && btn.getAttribute('href');
    if (!href || !href.startsWith('#')) return null;
    return document.querySelector(href);
  }

  function setHelpLabel(btn, open) {
    const t = btn ? btn.querySelector('.t1') : null;
    if (t) t.textContent = open ? '정답닫기' : '정답보기';
    if (btn) btn.setAttribute('aria-expanded', String(open));
  }

  function panelIsOpen(panel) {
    if (!panel) return false;
    if (panel.style.display) return panel.style.display !== 'none';
    return getComputedStyle(panel).display !== 'none';
  }

  function openPanel(btn, panel) {
    if (!panel) return;
    panel.style.display = 'block';
    panel.classList.add('loaded');     // 기존 테마 연동
    setHelpLabel(btn, true);
  }

  function closePanel(btn, panel) {
    if (!panel) return;
    panel.style.display = 'none';
    setHelpLabel(btn, false);
  }

  // ✅ 전체 정답 보기/닫기
  window.controlAllAnswers = function (show) {
    qsa('.tg2').forEach(panel => {
      panel.style.display = show ? 'block' : 'none';
      if (show) panel.classList.add('loaded');
    });
    qsa('a.b2.help').forEach(btn => setHelpLabel(btn, show));
  };

  // ✅ 개별 정답보기 토글 (이게 없으면 "클릭해도 아무 동작 없음")
  function onHelpClick(e) {
    const btn = e.target.closest('a.b2.help[href^="#"]');
    if (!btn) return;
    e.preventDefault();

    const panel = getPanelFromBtn(btn);
    if (!panel) return;

    panelIsOpen(panel) ? closePanel(btn, panel) : openPanel(btn, panel);
  }

  // ✅ 보기 클릭 → 정오답 판정 + s1/s2 적용 + 자동 정답보기
  function onOptionPick(e) {
    const li = e.target.closest('.cp1question1 .lst1 .li1');
    if (!li) return;

    const qBox = li.closest('.cp1question1');
    if (!qBox) return;

    const btn = qs('a.b2.help[href^="#"]', qBox);
    const panel = getPanelFromBtn(btn);

    // 정답 번호(i.t2n)는 해설 패널 안에 있음(1-based)
    const n = panel ? panel.querySelector('i.t2n') : null;
    const correctIdx = n ? parseInt((n.textContent || '').trim(), 10) : NaN;

    const options = qsa('.lst1 .li1', qBox);
    const idx = options.indexOf(li) + 1; // 1-based

    if (!Number.isFinite(correctIdx) || correctIdx <= 0) return;

    const isCorrect = idx === correctIdx;
    qBox.setAttribute('data-answer-state', isCorrect ? 'correct' : 'wrong');

    // 헤더 표시 (정답 s1 | 오답 s2)
    const b = qs('.w1 b', qBox);
    if (b) b.className = isCorrect ? 's1' : 's2';

    // 보기에도 클래스 부여(원하면 CSS로 강조)
    options.forEach((opt, i) => {
      opt.classList.remove('is-correct', 'is-wrong');
      if (i + 1 === correctIdx) opt.classList.add('is-correct');
    });
    li.classList.add(isCorrect ? 'is-correct' : 'is-wrong');

    // 자동 정답보기
    openPanel(btn, panel);
  }

  // capture로 등록: 다른 스크립트가 click을 막아도 최대한 동작
  document.addEventListener('click', onHelpClick, true);
  document.addEventListener('click', onOptionPick, true);
})();
</script>

<!-- AUTO:score-counter start -->
<script>
(function () {
  function qsa(sel, root) { return Array.from((root || document).querySelectorAll(sel)); }
  function qs(sel, root) { return (root || document).querySelector(sel); }

  function setText(el, n) {
    if (!el) return;
    el.textContent = String(n) + '개';
  }

  function updateTotal(total) {
    const block = qs('.cp1dlist2');
    if (!block) return;
    qsa('.cp1dlist2 .di1', block).forEach(li => {
      const label = (qs('.dt1', li)?.textContent || '').trim();
      if (label === '총 문제') {
        const dd = qs('.dd1', li);
        if (dd) dd.textContent = String(total) + '개';
      }
    });
  }

  function getPanelFromQ(qBox) {
    const btn = qBox.querySelector('a.b2.help[href^="#"]');
    if (!btn) return null;
    const href = btn.getAttribute('href');
    if (!href || !href.startsWith('#')) return null;
    return document.querySelector(href);
  }

  function getCorrectIndex(panel) {
    const n = panel ? panel.querySelector('i.t2n') : null;
    if (!n) return null;
    const v = parseInt((n.textContent || '').trim(), 10);
    return Number.isFinite(v) ? v : null; // 1-based
  }

  function recompute() {
    const total = qsa('.cp1question1').length;
    let correct = 0;
    let wrong = 0;

    qsa('.cp1question1').forEach(qBox => {
      const state = qBox.getAttribute('data-answer-state');
      if (state === 'correct') correct += 1;
      else if (state === 'wrong') wrong += 1;
    });

    const unanswered = Math.max(0, total - (correct + wrong));

    updateTotal(total);
    setText(qs('.cp1dlist2 .em1'), correct);
    setText(qs('.cp1dlist2 .em2'), wrong);
    setText(qs('.cp1dlist2 .em3'), unanswered);
  }

  function handle(e) {
    const li = e.target.closest('.cp1question1 .lst1 .li1');
    if (!li) return;

    const qBox = li.closest('.cp1question1');
    if (!qBox) return;

    const options = qsa('.lst1 .li1', qBox);
    const idx = options.indexOf(li) + 1; // 1-based
    if (idx <= 0) return;

    const panel = getPanelFromQ(qBox);
    const correctIdx = getCorrectIndex(panel);
    if (!correctIdx) {
      qBox.removeAttribute('data-answer-state');
      recompute();
      return;
    }

    qBox.setAttribute('data-answer-state', (idx === correctIdx) ? 'correct' : 'wrong');
    recompute();
  }

  // click이 막혀도 동작하도록 pointerup도 함께 수신(충돌 방어)
  document.addEventListener('click', handle, true);
  document.addEventListener('pointerup', handle, true);

  function init() { recompute(); }
  if (document.readyState === 'loading') document.addEventListener('DOMContentLoaded', init);
  else init();
})();
</script>
<!-- AUTO:score-counter end -->


  <style>
    /* 스크롤 시 적용될 스타일 */
    .cp1dlist2.fixed {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      z-index: 1000;
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
    }
  </style>
  <script>
    const header = document.querySelector('.cp1dlist2');
    const headerOffset = header.offsetTop;

    window.addEventListener('scroll', () => {
      if (window.scrollY > headerOffset) {
        header.classList.add('fixed');
      } else {
        header.classList.remove('fixed');
      }
    });
  </script>

</body>
</html>