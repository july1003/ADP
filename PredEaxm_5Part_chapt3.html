<html lang="ko" style="" class="cssscrollbar Desktop PC zoom object-fit gteIE9orSUA Chrome width-large lt-width-xlarge"><head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>예상문제 </title>
<style>
/* AUTO:exam-ui start */
/* 클릭 가능 UX */
a.b2.help,
.cp1question1 .lst1 .li1,
.cp1question1 .lst1 .li1 a {
  cursor: pointer;
}
/* hover (navy) */
.cp1question1 .lst1 .li1:hover {
  background: rgba(31, 42, 68, 0.06);
}
/* 선택 표시 (navy) */
.cp1question1 .lst1 .li1.is-selected {
  background: rgba(31, 42, 68, 0.12);
  border-radius: 6px;
}
.cp1question1 .lst1 .li1.is-selected .t1 {
  font-weight: 600;
  color: #2980b9; /* 딥 블루 */
}
/* 정답 (navy) */
.cp1question1 .lst1 .li1.is-correct {
  background: rgba(52, 152, 219, 0.18); /* 라이트 블루 */
  border-radius: 6px;
}
.cp1question1 .lst1 .li1.is-correct .t1 {
  font-weight: 700;
  color: #2980b9; /* 딥 블루 */
}
/* 오답 */
.cp1question1 .lst1 .li1.is-wrong {
  background: rgba(160, 30, 30, 0.12);
  border-radius: 6px;
}
.cp1question1 .lst1 .li1.is-wrong .t1 {
  font-weight: 600;
  color: #7a1f1f;
}
/* 보기 버튼 (navy) */
a.b2.help {
  color: #2980b9; /* 딥 블루 */
}
a.b2.help.on {
  font-weight: 600;
}
/* AUTO:exam-ui end */
.li1 {padding:4px 0px; line-height:1.2;font-size:16px}


/* AUTO:clickable-ui start */
a.b2.help,
.cp1question1 .lst1 .li1,
.cp1question1 .lst1 .li1 a {
  cursor: pointer;
}
.cp1question1 .lst1 .li1:hover {
  background: rgba(0, 0, 0, 0.04);
}
a.b2.help:hover {
  opacity: 0.85;
}
/* AUTO:clickable-ui end */
/* AUTO:mobile-scroll-fix start */
html {
  scroll-behavior: smooth;
}
.container {
  max-width: 600px;
  width: 100%;
  margin: 0 auto;
}
/* AUTO:mobile-scroll-fix end */
body {width:100%;}
	.eg1 {padding:10px 0px; text-align:center;width:100%;}
	.tg2 {border-bottom:1px solid #ddd;padding:5% 5%;display:none}
	.cp1question1 {padding-bottom:12px;}
	img {
	  width: 100%;
	  height: 100%;
	  object-fit: contain; /* 또는 cover */
	}
h2 a {
  font-size: 16px;        /* 글씨 크기 */
  text-decoration: none;  /* 밑줄 제거 */
  color: #333;            /* 기본 글자 색 */
  font-weight: 500;       /* 약간 두껍게 */
  transition: color 0.3s ease; /* hover 시 부드럽게 색 변화 */
}
h2 a:hover {
  color: #007acc;         /* hover 시 포인트 색 */
}

/* AUTO:cp1dlist2-style start */
.cp1dlist2 {
  display: flex;
  justify-content: flex-end;
  background-color: #f0f0f0;
  border-radius: 12px;
  padding: 10px 15px;
}

.cp1dlist2 ul {
  list-style: none;
  margin: 0;
  padding: 0;
  display: flex;
  gap: 10px;
}

.em2 {
  color: #d63031;
}
/* AUTO:cp1dlist2-style end */

</style>
</head>
<body>
<div class="container clearfix">
<div id="body" tabindex="-1">
<!-- container -->
<div class="container clearfix">
<!-- #forPrint -->
<div id="forPrint">
<!-- _content -->
<div id="body_content">
<h2><a href="./index.html"> &lt; 돌아가기</a>

<span class="all-controls" style="margin-left: 15px; vertical-align: middle;">
    <button type="button" onclick="window.controlAllAnswers(true)" style="padding: 6px 12px; background-color: #2c3e50; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 13px; font-weight: bold;">전체 정답 보기</button>
    <button type="button" onclick="window.controlAllAnswers(false)" style="padding: 6px 12px; background-color: #95a5a6; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 13px; font-weight: bold; margin-left: 5px;">전체 가리기</button>
</span></h2>
<!-- container -->
<div class="container clearfix">
<!-- cp1dlist2 -->
<div class="cp1dlist2">
<ul class="dl1">
<li class="di1">
<a class="a1">
<b class="dt1">총 문제</b>
<span class="dd1">18개</span>
</a>
</li>
<li class="di1">
<a class="a1">
<b class="dt1">맞춘 문제</b>
<span class="dd1"><b class="em1">0개</b></span>
</a>
</li>
<li class="di1">
<a class="a1">
<b class="dt1">틀린 문제</b>
<span class="dd1"><b class="em2">0개</b></span>
</a>
</li>
<li class="di1">
<a class="a1">
<b class="dt1">안 푼 문제</b>
<span class="dd1"><b class="em3">18개</b></span>
</a>
</li>
</ul>
</div>
<!-- /cp1dlist2 -->
<h3 class="hb1 h3">3장 - 시각화 구현</h3>
<!-- cp1question1 -->
<div class="cp1question1">
<div class="sg1">
<div class="w1">
<span class="g1">5과목</span>
<span class="g1">시각화 구현 개요</span>
<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
</div>
</div>
<div class="tg1">
<strong class="tt1">
<span class="tt1n">1.</span>
<span class="tt1t1">
				라이브러리가 제공하는 API로 코드를 작성해 시각화하는 도구의 리스트로 부적절한 것은 무엇인가?							</span>
</strong>
<span class="tt1t1">
</span>
</div>
<ol class="lst1">
<li class="li1"><a class="a1"><span class="t1">
			Flot					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			Timeline					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			QlikView					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			Polymaps					</span></a></li>
</ol>
<div class="eg1">
<a class="b2 help" href="#m-help1a1" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
<span class="t1">정답보기</span>
<i class="ic1"></i>
</a>
</div>
<div class="tg2 loaded" id="m-help1a1" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
<strong class="tt1">정답</strong>
<div class="t2">
<i class="t2n">3</i>
<span class="t2t1">
			QlikView			</span>
</div>
<br/>
<strong class="tt1">해설</strong>
<div class="t1">
		QlikView는 시각화 플랫폼이다. ①, ②, ④번은 시각화 라이브러리이다. 문제는 시각화 라이브러리의 적용 방법이므로, 시각화 라이브러리가 아닌 것을 찾는 문제이다.				</div>


<div class="more-c">
<strong class="tt1">비기봇 해설</strong>
<div class="t1">
				정답은 3번입니다.<br/>
<br/>
시각화 도구는 데이터를 시각적으로 표현하여 이해를 돕는 도구입니다. 다양한 라이브러리와 API를 통해 이러한 시각화를 구현할 수 있습니다. 시각화 도구는 주로 데이터의 패턴, 추세, 관계 등을 쉽게 파악할 수 있도록 도와줍니다. 일반적으로 시각화 도구는 차트, 그래프, 지도 등을 포함하며, 각 도구는 특정한 유형의 데이터를 시각화하는 데 특화되어 있습니다.<br/>
<br/>
1. Flot <br/>
: Flot은 jQuery 기반의 플러그인으로, 주로 웹에서 차트를 그리는 데 사용됩니다. Flot은 다양한 차트 유형을 지원하며, 특히 시계열 데이터 시각화에 강점을 가지고 있습니다. 따라서 Flot은 시각화 도구로 적절합니다.<br/>
<br/>
2. Timeline <br/>
: Timeline은 시간에 따른 사건이나 데이터를 시각적으로 표현하는 데 사용되는 도구입니다. 주로 시간의 흐름에 따라 데이터를 정렬하고 표시하는 데 유용합니다. 따라서 Timeline은 시각화 도구로 적절합니다.<br/>
<br/>
3. QlikView <br/>
: QlikView는 데이터 분석 및 비즈니스 인텔리전스 도구로, 데이터 시각화 기능을 포함하고 있지만, 주로 데이터 분석과 대시보드 생성에 중점을 둡니다. QlikView는 시각화 도구로 사용될 수 있지만, 주로 데이터 분석 도구로 분류됩니다.<br/>
<br/>
4. Polymaps <br/>
: Polymaps는 대규모 지리 데이터를 시각화하는 데 사용되는 도구로, 주로 웹 기반의 지도를 생성하는 데 사용됩니다. Polymaps는 지리적 데이터를 시각화하는 데 적합한 도구입니다.<br/>
<br/>
QlikView는 데이터 시각화 기능을 포함하고 있지만, 주로 데이터 분석과 비즈니스 인텔리전스에 중점을 둔 도구입니다. 따라서 시각화 도구로만 분류하기에는 부적절합니다. 반면, Flot, Timeline, Polymaps는 각각 차트, 시간 데이터, 지리 데이터를 시각화하는 데 특화된 도구로, 시각화 도구로 적절합니다.<br/>
따라서, 정답은 '3. QlikView' 입니다.<br/>
</div>
<div class="t2">
									#시각화 도구									# 데이터 시각화									# Flot									# Timeline									# QlikView									# Polymaps							</div>
</div>

</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
<div class="sg1">
<div class="w1">
<span class="g1">5과목</span>
<span class="g1">시각화 구현 개요</span>
<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
</div>
</div>
<div class="tg1">
<strong class="tt1">
<span class="tt1n">2.</span>
<span class="tt1t1">
				시각화 방법에서 분류와 도구의 매치가 부적절한 것은 무엇인가?							</span>
</strong>
<span class="tt1t1">
</span>
</div>
<ol class="lst1">
<li class="li1"><a class="a1"><span class="t1">
			시각화 플랫폼 - Tableau					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			시각화 라이브러리 - Tangle 					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			시각화 플랫폼 - Gephi					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			시각화 라이브러리 - Visual.ly					</span></a></li>
</ol>
<div class="eg1">
<a class="b2 help" href="#m-help1a2" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
<span class="t1">정답보기</span>
<i class="ic1"></i>
</a>
</div>
<div class="tg2 loaded" id="m-help1a2" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
<strong class="tt1">정답</strong>
<div class="t2">
<i class="t2n">4</i>
<span class="t2t1">
			시각화 라이브러리 - Visual.ly			</span>
</div>
<br/>
<strong class="tt1">해설</strong>
<div class="t1">
		Visual.ly는 인포그래픽스이다.				</div>


<div class="more-c">
<strong class="tt1">비기봇 해설</strong>
<div class="t1">
				1번의 Tableau는 데이터 시각화 플랫폼으로 널리 사용되는 도구입니다. <br/>
<br/>
2번의 Tangle은 인터랙티브 데이터 시각화를 위한 라이브러리로 사용됩니다.<br/>
<br/>
3번의 Gephi는 네트워크 시각화 및 분석을 위한 플랫폼입니다.<br/>
<br/>
4번의 Visual.ly는 시각화 라이브러리가 아니라, 데이터 시각화와 인포그래픽을 제작하는 플랫폼입니다. 따라서 시각화 라이브러리로 분류하는 것은 부적절합니다.<br/>
</div>
<div class="t2">
									#시각화 도구									# 시각화 플랫폼									# 시각화 라이브러리							</div>
</div>

</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
<div class="sg1">
<div class="w1">
<span class="g1">5과목</span>
<span class="g1">시각화 구현 개요</span>
<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
</div>
</div>
<div class="tg1">
<strong class="tt1">
<span class="tt1n">3.</span>
<span class="tt1t1">
				데이터 시각화의 이유로 가장 적절한 것은 무엇인가?							</span>
</strong>
<span class="tt1t1">
</span>
</div>
<ol class="lst1">
<li class="li1"><a class="a1"><span class="t1">
			분석결과의 정확도를 확인하기 위해					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			전체적인 데이터의 인사이트를 얻기 위해 					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			데이터를 엑셀로 정리하기 쉽게 하기 위해 					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			각 데이터의 성격을 알고 가공하기 위해					</span></a></li>
</ol>
<div class="eg1">
<a class="b2 help" href="#m-help1a3" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
<span class="t1">정답보기</span>
<i class="ic1"></i>
</a>
</div>
<div class="tg2 loaded" id="m-help1a3" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
<strong class="tt1">정답</strong>
<div class="t2">
<i class="t2n">2</i>
<span class="t2t1">
			전체적인 데이터의 인사이트를 얻기 위해 			</span>
</div>
<br/>
<strong class="tt1">해설</strong>
<div class="t1">
		데이터를 시각화함으로써 데이터의 전체적인 분포와 성격에 대해 한눈에 알기 쉽게 되므로 인사이트를 얻기에 좋다. 				</div>


<div class="more-c">
<strong class="tt1">비기봇 해설</strong>
<div class="t1">
				정답은 2번입니다.<br/>
<br/>
데이터 시각화는 복잡한 데이터를 시각적으로 표현하여 이해를 돕고, 인사이트를 얻기 위한 중요한 도구입니다. 이를 통해 데이터의 패턴, 추세, 이상치를 쉽게 파악할 수 있습니다.<br/>
<br/>
1. 분석결과의 정확도를 확인하기 위해<br/>
: 분석 결과의 정확도를 확인하는 것은 데이터 시각화의 주된 목적이 아닙니다. 시각화는 주로 데이터를 이해하고 해석하는 데 중점을 둡니다.<br/>
<br/>
2. 전체적인 데이터의 인사이트를 얻기 위해<br/>
: 데이터 시각화의 주요 목적 중 하나는 전체적인 데이터의 인사이트를 얻는 것입니다. 이를 통해 데이터의 패턴과 추세를 쉽게 파악할 수 있습니다.<br/>
<br/>
3. 데이터를 엑셀로 정리하기 쉽게 하기 위해<br/>
: 데이터를 엑셀로 정리하기 쉽게 하는 것은 시각화의 목적과는 거리가 멉니다. 시각화는 데이터를 시각적으로 표현하여 이해를 돕는 데 중점을 둡니다.<br/>
<br/>
4. 각 데이터의 성격을 알고 가공하기 위해<br/>
: 각 데이터의 성격을 알고 가공하는 것은 데이터 분석의 일부 과정일 수 있지만, 시각화의 주된 목적은 아닙니다.<br/>
<br/>
<br/>
데이터 시각화의 주된 목적은 전체적인 데이터의 인사이트를 얻는 것입니다. 이를 통해 데이터의 패턴과 추세를 쉽게 파악할 수 있으며, 이는 선택지 2에 해당합니다. 다른 선택지들은 시각화의 부수적인 기능이거나 목적과는 거리가 있습니다.<br/>
<br/>
따라서, 정답은 '2. 전체적인 데이터의 인사이트를 얻기 위해' 입니다.<br/>
</div>
<div class="t2">
									#데이터 시각화									# 인사이트									# 패턴									# 추세							</div>
</div>

</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
<div class="sg1">
<div class="w1">
<span class="g1">5과목</span>
<span class="g1">시각화 구현 개요</span>
<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
</div>
</div>
<div class="tg1">
<strong class="tt1">
<span class="tt1n">4.</span>
<span class="tt1t1">
				시각화 플랫폼에 관한 설명으로 가장 부적절한 것은 무엇인가?							</span>
</strong>
<span class="tt1t1">
</span>
</div>
<ol class="lst1">
<li class="li1"><a class="a1"><span class="t1">
			로그인한 사용자 또는 페이지와 관계된 활동, 관계 정보 등을 결과물로 변환해준다. 					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			주로 비즈니스 인텔리전스 분야에서 활용된다.					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			다양한 관점에서 인사이트를 얻을 수 있도록 ‘지식 시각화’ 관점에서 데이터 시각화 기능을 지원한다.					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			기존에는 주로 데이터 분석, 마이닝 등의 기법을 통해 일정한 방식의 결과 리포트를 생성하기 위해 활용 됐었다.					</span></a></li>
</ol>
<div class="eg1">
<a class="b2 help" href="#m-help1a4" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
<span class="t1">정답보기</span>
<i class="ic1"></i>
</a>
</div>
<div class="tg2 loaded" id="m-help1a4" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
<strong class="tt1">정답</strong>
<div class="t2">
<i class="t2n">1</i>
<span class="t2t1">
			로그인한 사용자 또는 페이지와 관계된 활동, 관계 정보 등을 결과물로 변환해준다. 			</span>
</div>
<br/>
<strong class="tt1">해설</strong>
<div class="t1">
		인포그래픽스에 대한 설명이다.				</div>


<div class="more-c">
<strong class="tt1">비기봇 해설</strong>
<div class="t1">
				1. 이 설명은 시각화 플랫폼의 주된 기능과는 거리가 있습니다. 시각화 플랫폼은 데이터를 시각적으로 표현하여 이해하기 쉽게 만드는 도구로, 로그인한 사용자나 페이지와 관계된 활동 정보를 결과물로 변환하는 것은 주로 웹 분석 도구나 CRM 시스템에서 수행하는 작업입니다. 따라서, 이 설명은 부적절합니다.<br/>
<br/>
2. 시각화 플랫폼은 비즈니스 인텔리전스(BI) 분야에서 널리 활용됩니다. BI 도구는 데이터를 분석하고 시각화하여 비즈니스 인사이트를 제공하는 데 중요한 역할을 합니다. 따라서, 이 설명은 적절합니다.<br/>
<br/>
3. 시각화 플랫폼은 데이터를 다양한 관점에서 시각화하여 사용자가 인사이트를 얻을 수 있도록 돕습니다. ‘지식 시각화’는 데이터에서 지식을 도출하기 위한 시각화 방법으로, 시각화 플랫폼의 주요 기능 중 하나입니다. 따라서, 이 설명은 적절합니다.<br/>
<br/>
4. 시각화 플랫폼은 전통적으로 데이터 분석 및 마이닝 결과를 시각적으로 표현하여 결과 리포트를 생성하는 데 사용되었습니다. 이는 시각화 플랫폼의 일반적인 용도 중 하나입니다. 따라서, 이 설명은 적절합니다.<br/>
</div>
<div class="t2">
									# 시각화 플랫폼							</div>
</div>

</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
<div class="sg1">
<div class="w1">
<span class="g1">5과목</span>
<span class="g1">시각화 구현 개요</span>
<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
</div>
</div>
<div class="tg1">
<strong class="tt1">
<span class="tt1n">5.</span>
<span class="tt1t1">
				아래 보기와 같은 시각화 방법에 대한 특징으로 가장 적절한 것은 무엇인가?					
					<span class="tt1t1">
						PowerPivot, R, Weka, Gephi, Visual Intelligence					</span>
</span>
</strong>
<span class="tt1t1">
</span>
</div>
<ol class="lst1">
<li class="li1"><a class="a1"><span class="t1">
			주로 소스를 모두 공개하는 프로젝트 또는 라이브러리 형태로 제공된다. 					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			사전에 제작된 템플릿을 기반으로 시각화를 생성하는 도구를 지원한다. 					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			플랫폼을 설치하거나 구축하는 것이 필요하다.					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			라이브러리가 제공하는 API로 코드를 작성해 시각화한다.					</span></a></li>
</ol>
<div class="eg1">
<a class="b2 help" href="#m-help1a5" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
<span class="t1">정답보기</span>
<i class="ic1"></i>
</a>
</div>
<div class="tg2 loaded" id="m-help1a5" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
<strong class="tt1">정답</strong>
<div class="t2">
<i class="t2n">3</i>
<span class="t2t1">
			플랫폼을 설치하거나 구축하는 것이 필요하다.			</span>
</div>
<br/>
<strong class="tt1">해설</strong>
<div class="t1">
		주어진 보기는 시각화 플랫폼에 관한 설명으로, 시각화 플랫폼은 플랫폼을 설치하거나 구축한 뒤, 플랫폼에서 제공하는 기능이나 명령어를 실행해 시각화한다.				</div>


<div class="more-c">
<strong class="tt1">비기봇 해설</strong>
<div class="t1">
				1. R과 Weka는 오픈 소스이지만, PowerPivot, Gephi, Visual Intelligence는 그렇지 않습니다. 따라서, 이 설명은 적절하지 않습니다.<br/>
<br/>
2. 일부 도구는 템플릿 기반 시각화를 지원할 수 있지만, 이 도구들의 주요 특징은 아닙니다. 따라서, 이 설명은 적절하지 않습니다.<br/>
<br/>
3. 이 도구들은 대부분 소프트웨어를 설치하거나 플랫폼을 구축해야 사용할 수 있습니다. 이는 이들 도구의 공통적인 특징입니다. 따라서, 이 설명이 가장 적절합니다.<br/>
<br/>
4. R은 API를 통해 코드를 작성해 시각화할 수 있지만, PowerPivot, Gephi, Visual Intelligence는 일반적으로 코드 작성보다는 GUI를 통해 사용됩니다. 따라서, 이 설명은 적절하지 않습니다.<br/>
</div>
<div class="t2">
									#시각화 방법									# PowerPivot									# R									# Weka									# Gephi									# Visual Intelligence							</div>
</div>

</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
<div class="sg1">
<div class="w1">
<span class="g1">5과목</span>
<span class="g1">시각화 구현 개요</span>
<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
</div>
</div>
<div class="tg1">
<strong class="tt1">
<span class="tt1n">6.</span>
<span class="tt1t1">
				다음 중 시각화 도구들 중 성질이 다른 것 하나는 무엇인가?							</span>
</strong>
<span class="tt1t1">
</span>
</div>
<ol class="lst1">
<li class="li1"><a class="a1"><span class="t1">
			Google Charts					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			Visual Insight					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			jQuery Visualize					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			Tangle					</span></a></li>
</ol>
<div class="eg1">
<a class="b2 help" href="#m-help1a6" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
<span class="t1">정답보기</span>
<i class="ic1"></i>
</a>
</div>
<div class="tg2 loaded" id="m-help1a6" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
<strong class="tt1">정답</strong>
<div class="t2">
<i class="t2n">2</i>
<span class="t2t1">
			Visual Insight			</span>
</div>
<br/>
<strong class="tt1">해설</strong>
<div class="t1">
		①, ③, ④번은 시각화 라이브러리이며, ②번은 시각화 플랫폼이다.				</div>


<div class="more-c">
<strong class="tt1">비기봇 해설</strong>
<div class="t1">
				정답은 2번입니다.<br/>
<br/>
이 문제는 시각화 도구의 성질을 비교하여 다른 성질을 가진 도구를 찾는 문제입니다. 시각화 도구는 데이터 시각화를 통해 정보를 쉽게 이해할 수 있도록 돕는 도구입니다. 각 도구는 다양한 기능과 특징을 가지고 있으며, 특정 도구는 다른 도구들과 다른 성질을 가질 수 있습니다.<br/>
<br/>
1. Google Charts<br/>
: Google Charts는 웹 기반의 데이터 시각화 도구로, 다양한 차트와 그래프를 생성할 수 있습니다. 주로 웹 애플리케이션에 통합하여 사용됩니다.<br/>
<br/>
2. Visual Insight<br/>
: Visual Insight는 비즈니스 인텔리전스 도구로, 데이터 분석과 시각화를 통해 인사이트를 제공합니다. 주로 기업 환경에서 사용됩니다.<br/>
<br/>
3. jQuery Visualize<br/>
: jQuery Visualize는 jQuery 플러그인을 기반으로 한 시각화 도구로, 웹 페이지에 쉽게 통합할 수 있는 차트와 그래프를 제공합니다.<br/>
<br/>
4. Tangle<br/>
: Tangle은 사용자가 데이터와 상호작용할 수 있는 인터랙티브한 시각화를 제공하는 도구로, 주로 데이터의 동적 변화를 시각적으로 표현하는 데 사용됩니다.<br/>
<br/>
<br/>
Visual Insight는 다른 도구들과 달리 비즈니스 인텔리전스 도구로, 주로 기업 환경에서 데이터 분석과 시각화를 통해 인사이트를 제공하는 데 중점을 둡니다. 반면, 나머지 도구들은 주로 웹 기반의 시각화 도구로, 웹 페이지에 통합하여 차트와 그래프를 생성하는 데 사용됩니다.<br/>
<br/>
따라서, 정답은 '2. Visual Insight' 입니다.<br/>
</div>
<div class="t2">
									#시각화 도구									# 데이터 시각화									# 웹 기반									# 비즈니스 인텔리전스							</div>
</div>

</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
<div class="sg1">
<div class="w1">
<span class="g1">5과목</span>
<span class="g1">분석 도구를 이용한 시각화 구현 : R</span>
<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
</div>
</div>
<div class="tg1">
<strong class="tt1">
<span class="tt1n">7.</span>
<span class="tt1t1">
				보기의 코드를 사용하여 구현되는 시각화의 특징으로 가장 부적절한 것은 무엇인가?					
					<span class="tt1t1">
						&gt; ggplot(ChickWeight, aes(x=Time, y=weight, colour=Diet)) + <br/>
   geom_point(alpha=.3) + geom_smooth(alpha=.2, size=1)					</span>
</span>
</strong>
<span class="tt1t1">
</span>
</div>
<ol class="lst1">
<li class="li1"><a class="a1"><span class="t1">
			전반적인 내용 파악은 가능하지만, 데이터 수가 많을 땐 의미를 파악하기가 어렵다. 					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			포인트 그래프와 스무스 그래프가 동시에 사용되어 인사이트를 알기 어렵게 되었다. 					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			Diet에 따라 scatter plot을 geom_point로 투명도와 사이즈를 지정해 표시했다. 					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			geom_smooth로 배경 색상의 투명도와 평균값 선의 굵기를 조정했다.					</span></a></li>
</ol>
<div class="eg1">
<a class="b2 help" href="#m-help1a7" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
<span class="t1">정답보기</span>
<i class="ic1"></i>
</a>
</div>
<div class="tg2 loaded" id="m-help1a7" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
<strong class="tt1">정답</strong>
<div class="t2">
<i class="t2n">2</i>
<span class="t2t1">
			포인트 그래프와 스무스 그래프가 동시에 사용되어 인사이트를 알기 어렵게 되었다. 			</span>
</div>
<br/>
<strong class="tt1">해설</strong>
<div class="t1">
		포인트 그래프와 스무스 그래프를 동시에 표현해 훨씬 더 분명하게 데이터를 보여준다. 즉, 데이터의 인사이트를 좀 더 얻기 쉬워진다.				</div>


<div class="more-c">
<strong class="tt1">비기봇 해설</strong>
<div class="t1">
				정답은 2번입니다.<br/>
<br/>
ggplot2는 R에서 데이터 시각화를 위한 강력한 도구로, 다양한 그래프를 쉽게 그릴 수 있도록 도와줍니다. 이 문제에서 사용된 코드는 ggplot2 패키지를 활용하여 ChickWeight 데이터셋을 시각화하는 예시입니다. aes() 함수는 시각화의 축과 색상 등을 지정하는 데 사용되며, geom_point()는 산점도를, geom_smooth()는 데이터의 추세선을 그리는 데 사용됩니다. alpha는 투명도를 조절하는 매개변수로, 값이 작을수록 더 투명해집니다. 이 코드는 시간(Time)에 따른 무게(weight)의 변화를 식단(Diet)별로 색상으로 구분하여 시각화합니다.<br/>
<br/>
1. 전반적인 내용 파악은 가능하지만, 데이터 수가 많을 땐 의미를 파악하기가 어렵다. <br/>
: 산점도는 데이터의 개별 관측치를 점으로 표시하여 전반적인 경향을 파악하는 데 유용합니다. 그러나 데이터 포인트가 많을 경우, 점들이 겹쳐져서 개별 데이터의 의미를 파악하기 어려울 수 있습니다. 이는 시각화의 일반적인 한계로, 데이터의 밀집도를 파악하기 위해 투명도를 조절하거나 다른 시각화 기법을 병행할 수 있습니다.<br/>
<br/>
2. 포인트 그래프와 스무스 그래프가 동시에 사용되어 인사이트를 알기 어렵게 되었다. <br/>
: 산점도와 추세선이 함께 사용되면, 개별 데이터 포인트와 데이터의 전반적인 경향을 동시에 파악할 수 있습니다. 그러나 이 두 그래프가 서로 다른 정보를 제공하기 때문에, 시각적으로 복잡해질 수 있습니다. 이는 시각화의 복잡성을 증가시킬 수 있지만, 인사이트를 얻기 어렵게 한다는 것은 부적절한 해석입니다.<br/>
<br/>
3. Diet에 따라 scatter plot을 geom_point로 투명도와 사이즈를 지정해 표시했다. <br/>
: aes() 함수 내에서 colour 매개변수를 사용하여 Diet에 따라 점의 색상을 지정하고, geom_point()에서 alpha 매개변수를 통해 점의 투명도를 조절했습니다. 이는 데이터의 분포를 더 명확히 파악할 수 있도록 도와줍니다. 이 설명은 코드의 기능을 정확히 반영하고 있습니다.<br/>
<br/>
4. geom_smooth로 배경 색상의 투명도와 평균값 선의 굵기를 조정했다. <br/>
: geom_smooth() 함수는 데이터의 추세선을 그리며, alpha 매개변수로 선의 투명도를, size 매개변수로 선의 굵기를 조절할 수 있습니다. 이는 시각적으로 추세선을 강조하거나 배경과의 대비를 조절하는 데 유용합니다. 이 설명은 코드의 기능을 정확히 반영하고 있습니다.<br/>
<br/>
선지 2는 포인트 그래프와 스무스 그래프가 동시에 사용되어 인사이트를 알기 어렵게 되었다고 주장하지만, 실제로는 두 그래프가 서로 보완적인 정보를 제공하여 데이터의 개별 포인트와 전반적인 경향을 동시에 파악할 수 있게 합니다. 따라서 이 설명은 부적절합니다. 나머지 선지들은 코드의 기능을 정확히 설명하고 있습니다.<br/>
따라서, 정답은 '2. 포인트 그래프와 스무스 그래프가 동시에 사용되어 인사이트를 알기 어렵게 되었다.' 입니다.<br/>
</div>
<div class="t2">
									#ggplot2									# 산점도									# 추세선									# 투명도									# 시각화							</div>
</div>

</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
<div class="sg1">
<div class="w1">
<span class="g1">5과목</span>
<span class="g1">분석 도구를 이용한 시각화 구현 : R</span>
<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
</div>
</div>
<div class="tg1">
<strong class="tt1">
<span class="tt1n">8.</span>
<span class="tt1t1">
				분석 도구를 이용해 시각화를 구현하고자 할 때, 막대그래프의 내부 색상을 바꾸기 위해 사용할 수 있는 명령어로 적절한 것은 무엇인가?							</span>
</strong>
<span class="tt1t1">
</span>
</div>
<ol class="lst1">
<li class="li1"><a class="a1"><span class="t1">
			fill					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			translate					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			axis					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			colour					</span></a></li>
</ol>
<div class="eg1">
<a class="b2 help" href="#m-help1a8" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
<span class="t1">정답보기</span>
<i class="ic1"></i>
</a>
</div>
<div class="tg2 loaded" id="m-help1a8" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
<strong class="tt1">정답</strong>
<div class="t2">
<i class="t2n">1</i>
<span class="t2t1">
			fill			</span>
</div>
<br/>
<strong class="tt1">해설</strong>
<div class="t1">
		내부 색상을 바꾸고자할 때는 fill을 이용한다.				</div>


<div class="more-c">
<strong class="tt1">비기봇 해설</strong>
<div class="t1">
				정답은 1번입니다.<br/>
<br/>
막대그래프의 내부 색상을 변경하는 것은 데이터 시각화에서 중요한 요소입니다. 이를 통해 그래프의 가독성을 높이고, 특정 데이터를 강조할 수 있습니다. 다양한 시각화 도구에서 색상을 변경하는 방법은 다를 수 있지만, 일반적으로 'fill'이나 'colour'와 같은 명령어를 사용합니다.<br/>
<br/>
1. fill<br/>
: 'fill'은 그래프의 내부 색상을 채우는 데 사용되는 명령어로, 데이터 시각화에서 자주 사용됩니다.<br/>
<br/>
2. translate<br/>
: 'translate'는 그래프의 위치를 이동시키는 데 사용되는 명령어로, 색상 변경과는 관련이 없습니다.<br/>
<br/>
3. axis<br/>
: 'axis'는 그래프의 축을 설정하거나 조정하는 데 사용되는 명령어로, 색상 변경과는 관련이 없습니다.<br/>
<br/>
4. colour<br/>
: 'colour'는 색상을 지정하는 데 사용될 수 있지만, 일반적으로 'fill'이 내부 색상 변경에 더 적합합니다.<br/>
<br/>
<br/>
'fill'은 막대그래프의 내부 색상을 변경하는 데 가장 적합한 명령어입니다. 'translate'과 'axis'는 색상 변경과 관련이 없으며, 'colour'는 색상 지정에 사용될 수 있지만, 내부 색상 변경에는 'fill'이 더 일반적으로 사용됩니다.<br/>
<br/>
따라서, 정답은 '1. fill' 입니다.<br/>
</div>
<div class="t2">
									#막대그래프									# 색상 변경									# fill									# 데이터 시각화							</div>
</div>

</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
<div class="sg1">
<div class="w1">
<span class="g1">5과목</span>
<span class="g1">분석 도구를 이용한 시각화 구현 : R</span>
<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
</div>
</div>
<div class="tg1">
<strong class="tt1">
<span class="tt1n">9.</span>
<span class="tt1t1">
				포인트 그래프에서 변경할 수 있는 옵션과 그 결과의 매치로 부적절한 것은 무엇인가?							</span>
</strong>
<span class="tt1t1">
</span>
</div>
<ol class="lst1">
<li class="li1"><a class="a1"><span class="t1">
			p + geom_point(shape="h", size=2) : 점을 사이즈가 2인 h 모양으로 변경 					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			p + geom_point(aes(size=qsec)) : 점의 크기를 다르게 변경					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			p + geom_point(shape=NA) : 점의 옵션을 따로 지정하지 않음 					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			p + geom_point(shape=5) : 점을 5번 모형으로 변경					</span></a></li>
</ol>
<div class="eg1">
<a class="b2 help" href="#m-help1a9" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
<span class="t1">정답보기</span>
<i class="ic1"></i>
</a>
</div>
<div class="tg2 loaded" id="m-help1a9" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
<strong class="tt1">정답</strong>
<div class="t2">
<i class="t2n">3</i>
<span class="t2t1">
			p + geom_point(shape=NA) : 점의 옵션을 따로 지정하지 않음 			</span>
</div>
<br/>
<strong class="tt1">해설</strong>
<div class="t1">
		점의 모양을 없애는 명령으로, 그래프에 아무것도 나타나지 않게 된다. 점의 옵션을 따로 지정하지 않는 경우는 p + geom_point( )로 작성해야 한다.				</div>


<div class="more-c">
<strong class="tt1">비기봇 해설</strong>
<div class="t1">
				1. shape="h"는 점의 모양을 "h"로 변경하고, size=2는 점의 크기를 2로 설정합니다. <br/>
<br/>
2. aes(size=qsec)는 qsec 변수의 값에 따라 점의 크기를 다르게 설정합니다. 이는 적절한 매치입니다.<br/>
<br/>
3. shape=NA는 점의 모양을 지정하지 않는 것이 아니라, 점을 그리지 않도록 설정합니다. 따라서, 점이 나타나지 않게 됩니다. 이는 "점의 옵션을 따로 지정하지 않음"과는 다른 결과를 초래합니다.<br/>
<br/>
4. shape=5는 점의 모양을 숫자 5에 해당하는 모양으로 변경합니다. 이는 일반적으로 작은 다이아몬드 모양입니다. 따라서, 이 설명은 적절합니다.<br/>
</div>
<div class="t2">
									# 포인트 그래프									# 포인트 그래프 옵션							</div>
</div>

</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
<div class="sg1">
<div class="w1">
<span class="g1">5과목</span>
<span class="g1">분석 도구를 이용한 시각화 구현 : R</span>
<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
</div>
</div>
<div class="tg1">
<strong class="tt1">
<span class="tt1n">10.</span>
<span class="tt1t1">
				시각화로 구현된 그래프에서 alpha 값을 이용해 투명도를 조절한다고 할 때, 분포가 중앙에 집중되었다는 것을 가장 명확히 알 수 있는 그래프는 무엇인가?							</span>
</strong>
<span class="tt1t1">
</span>
</div>
<ol class="lst1">
<li class="li1"><a class="a1"><span class="t1">
			h + geom_point(alpha=0.5) 					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			h + geom_point(alpha=1) 					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			h + geom_point(alpha=10) 					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			h + geom_point(alpha=0.1)					</span></a></li>
</ol>
<div class="eg1">
<a class="b2 help" href="#m-help1a10" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
<span class="t1">정답보기</span>
<i class="ic1"></i>
</a>
</div>
<div class="tg2 loaded" id="m-help1a10" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
<strong class="tt1">정답</strong>
<div class="t2">
<i class="t2n">4</i>
<span class="t2t1">
			h + geom_point(alpha=0.1)			</span>
</div>
<br/>
<strong class="tt1">해설</strong>
<div class="t1">
		alpha를 0.1 수준으로 지정하면 분포가 중앙에 집중되었다는 것이 더욱 명확하게 드러난다.				</div>


<div class="more-c">
<strong class="tt1">비기봇 해설</strong>
<div class="t1">
				정답은 4번입니다.<br/>
<br/>
그래프에서 alpha 값은 포인트의 투명도를 조절하는 데 사용됩니다. alpha 값이 낮을수록 포인트가 더 투명해지며, 이는 데이터가 어디에 집중되어 있는지를 더 명확하게 보여줍니다. 특히, 데이터가 중앙에 집중되어 있는 경우, 낮은 alpha 값은 겹치는 포인트들이 더 잘 드러나게 하여 분포의 밀집도를 시각적으로 강조합니다. 따라서, alpha 값을 적절히 조절하면 데이터의 분포 특성을 더 잘 파악할 수 있습니다.<br/>
<br/>
1. h + geom_point(alpha=0.5) <br/>
: alpha 값이 0.5인 경우, 포인트의 투명도가 중간 정도로 설정됩니다. 이는 데이터의 밀집도를 어느 정도 보여주지만, 완전히 명확하게 하지는 못합니다. 데이터가 중앙에 집중되어 있다면, 이 정도의 투명도로는 겹치는 부분이 충분히 드러나지 않을 수 있습니다.<br/>
<br/>
2. h + geom_point(alpha=1) <br/>
: alpha 값이 1인 경우, 포인트는 완전히 불투명하게 표시됩니다. 이는 데이터의 개별 포인트를 명확히 보여주지만, 포인트가 겹치는 부분을 시각적으로 드러내지 못해 데이터의 밀집도를 파악하기 어렵습니다.<br/>
<br/>
3. h + geom_point(alpha=10) <br/>
: alpha 값이 10인 경우, 이는 잘못된 설정입니다. alpha 값은 0과 1 사이의 값으로 설정해야 하므로, 10이라는 값은 비정상적인 값이며, 실제로는 적용되지 않습니다.<br/>
<br/>
4. h + geom_point(alpha=0.1) <br/>
: alpha 값이 0.1인 경우, 포인트의 투명도가 매우 높아져 겹치는 부분이 더 잘 드러납니다. 이는 데이터가 중앙에 집중되어 있는 경우, 그 밀집도를 가장 명확하게 보여줄 수 있는 설정입니다.<br/>
<br/>
정답은 4번입니다. alpha 값이 0.1로 설정되면 포인트가 매우 투명해져, 데이터가 중앙에 집중되어 있을 때 겹치는 부분이 더 잘 드러나게 됩니다. 이는 데이터의 밀집도를 시각적으로 가장 명확하게 보여줍니다. 반면, alpha 값이 0.5나 1인 경우에는 포인트가 덜 투명하거나 불투명하여 데이터의 밀집도를 파악하기 어렵습니다. alpha 값이 10인 경우는 잘못된 설정으로, 실제로 적용되지 않습니다.<br/>
따라서, 정답은 '4. h + geom_point(alpha=0.1)' 입니다.<br/>
</div>
<div class="t2">
									#alpha 값									# 투명도									# 데이터 밀집도									# 포인트 그래프									# ggplot							</div>
</div>

</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
<div class="sg1">
<div class="w1">
<span class="g1">5과목</span>
<span class="g1">분석 도구를 이용한 시각화 구현 : R</span>
<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
</div>
</div>
<div class="tg1">
<strong class="tt1">
<span class="tt1n">11.</span>
<span class="tt1t1">
				아래 보기의 코드를 사용하여 구현되는 시각화 그래프로 가장 적절한 것은 무엇인가?					
					<span class="tt1t1">
						m &lt;- ggplot(movies, aes(x=rating)) <br/>
m + geom_histogram( )<br/>
m + geom_histogram(aes(fill = ..count.. )) 					</span>
</span>
</strong>
<span class="tt1t1">
</span>
</div>
<ol class="lst1">
<li class="li1"><a class="a1"><span class="t1">
<img alt="보기에 포함된 이미지" src="https://www.dataedupt.kr/data/img/question/acc491ad-8924-37fb-2033-19b2890546b3.png"/> </span></a></li>
<li class="li1"><a class="a1"><span class="t1">
<img alt="보기에 포함된 이미지" src="https://www.dataedupt.kr/data/img/question/b47cc29a-9435-7c9e-21ff-f450f4dbbd16.png"/> </span></a></li>
<li class="li1"><a class="a1"><span class="t1">
<img alt="보기에 포함된 이미지" src="https://www.dataedupt.kr/data/img/question/43afa822-0dfd-71ea-a8d2-55aa104eee95.png"/> </span></a></li>
<li class="li1"><a class="a1"><span class="t1">
<img alt="보기에 포함된 이미지" src="https://www.dataedupt.kr/data/img/question/688e3f42-3ee5-cf7b-2d53-7df117b9da2d.png"/> </span></a></li>
</ol>
<div class="eg1">
<a class="b2 help" href="#m-help1a11" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
<span class="t1">정답보기</span>
<i class="ic1"></i>
</a>
</div>
<div class="tg2 loaded" id="m-help1a11" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
<strong class="tt1">정답</strong>
<div class="t2">
<i class="t2n">2</i>
<span class="t2t1">
</span>
</div>
<br/>
<strong class="tt1">해설</strong>
<div class="t1">
		히스토그램 형식으로 표시한 뒤, 연속형 count를 색상으로 표시한 것이다.				</div>


<div class="more-c">
<strong class="tt1">비기봇 해설</strong>
<div class="t1">
				주어진 코드에 따르면, ggplot을 사용하여 movies 데이터프레임의 rating 변수를 x축으로 하는 히스토그램을 그리고 있습니다. geom_histogram() 함수를 사용하여 히스토그램을 그리고 있으며, 두 번째 히스토그램에서는 fill을 ..count..로 설정하여 막대의 높이에 따라 색을 채우고 있습니다.<br/>
<br/>
따라서, 보기 2번의 그래프가 옳습니다. <br/>
</div>
<div class="t2">
									# ggplot2									# 히스토그램									# geom_histogram									# aes									# fill									# count							</div>
</div>

</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
<div class="sg1">
<div class="w1">
<span class="g1">5과목</span>
<span class="g1">분석 도구를 이용한 시각화 구현 : R</span>
<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
</div>
</div>
<div class="tg1">
<strong class="tt1">
<span class="tt1n">12.</span>
<span class="tt1t1">
				샤이니(shiny)와 관련된 것으로 가장 부적절한 것은 무엇인가?							</span>
</strong>
<span class="tt1t1">
</span>
</div>
<ol class="lst1">
<li class="li1"><a class="a1"><span class="t1">
			dataTavles					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			MoreWidget					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			HTML_ui					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			drawImage					</span></a></li>
</ol>
<div class="eg1">
<a class="b2 help" href="#m-help1a12" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
<span class="t1">정답보기</span>
<i class="ic1"></i>
</a>
</div>
<div class="tg2 loaded" id="m-help1a12" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
<strong class="tt1">정답</strong>
<div class="t2">
<i class="t2n">4</i>
<span class="t2t1">
			drawImage			</span>
</div>
<br/>
<strong class="tt1">해설</strong>
<div class="t1">
		drawImage는 D3.js에서 canvas에 준비한 이미지를 출력할 때 필요한 함수이다.				</div>


<div class="more-c">
<strong class="tt1">비기봇 해설</strong>
<div class="t1">
				정답은 4번입니다.<br/>
<br/>
샤이니(shiny)는 R 프로그래밍 언어를 사용하여 대화형 웹 애플리케이션을 쉽게 만들 수 있도록 도와주는 프레임워크입니다. 이를 통해 사용자는 데이터를 시각화하고, 대화형 UI를 통해 데이터를 탐색할 수 있습니다.<br/>
<br/>
1. dataTavles<br/>
: dataTables는 Shiny에서 데이터 테이블을 생성하고 조작할 수 있는 기능을 제공합니다. 이를 통해 사용자는 대화형으로 데이터를 필터링하고 정렬할 수 있습니다.<br/>
<br/>
2. MoreWidget<br/>
: MoreWidget은 Shiny에서 다양한 위젯을 추가하여 사용자 인터페이스를 확장할 수 있는 기능을 제공합니다. 이를 통해 사용자는 더 많은 사용자 정의 옵션을 사용할 수 있습니다.<br/>
<br/>
3. HTML_ui<br/>
: HTML_ui는 Shiny에서 HTML을 사용하여 사용자 인터페이스를 구성할 수 있는 기능을 제공합니다. 이를 통해 사용자는 HTML 태그를 사용하여 UI를 세밀하게 조정할 수 있습니다.<br/>
<br/>
4. drawImage<br/>
: drawImage는 Shiny와 직접적인 관련이 없는 기능입니다. 이는 일반적으로 HTML5 Canvas API에서 이미지를 그리는 데 사용됩니다.<br/>
<br/>
<br/>
drawImage는 Shiny와 직접적인 관련이 없는 기능으로, HTML5 Canvas API에서 이미지를 그리는 데 사용됩니다. 반면, 나머지 선택지들은 모두 Shiny와 관련된 기능들로, Shiny 애플리케이션에서 사용될 수 있습니다.<br/>
<br/>
따라서, 정답은 '4. drawImage' 입니다.<br/>
</div>
<div class="t2">
									#Shiny									# dataTables									# MoreWidget									# HTML_ui							</div>
</div>

</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
<div class="sg1">
<div class="w1">
<span class="g1">5과목</span>
<span class="g1">라이브러리 기반의 시각화 구현 : D3.js</span>
<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
</div>
</div>
<div class="tg1">
<strong class="tt1">
<span class="tt1n">13.</span>
<span class="tt1t1">
				D3.js를 활용한 시각화 구현 절차의 세 번째 단계로 적절한 것은 무엇인가?							</span>
</strong>
<span class="tt1t1">
</span>
</div>
<ol class="lst1">
<li class="li1"><a class="a1"><span class="t1">
			데이터 표현					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			데이터 필터링					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			데이터 파싱					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			상호작용 추가					</span></a></li>
</ol>
<div class="eg1">
<a class="b2 help" href="#m-help1a13" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
<span class="t1">정답보기</span>
<i class="ic1"></i>
</a>
</div>
<div class="tg2 loaded" id="m-help1a13" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
<strong class="tt1">정답</strong>
<div class="t2">
<i class="t2n">2</i>
<span class="t2t1">
			데이터 필터링			</span>
</div>
<br/>
<strong class="tt1">해설</strong>
<div class="t1">
		D3.js를 활용한 시각화 구현 절차는 ‘데이터 획득 – 데이터 파싱 – 데이터 필터링 – 데이터 표현 – 상호작용 추가’이다.				</div>


<div class="more-c">
<strong class="tt1">비기봇 해설</strong>
<div class="t1">
				D3.js를 통한 시각화 구현 절차는 아래와 같다.<br/>
<br/>
1단계 : 데이터 획득<br/>
2단계 : 데이터 파싱<br/>
3단계 : 데이터 필터링<br/>
4단계 : 데이터 표현<br/>
5단계 : 상호작용 추가<br/>
<br/>
따라서, 세 번째 단계로 데이터 필터링이 적절하다.<br/>
</div>
<div class="t2">
									# D3js									# 시각화 구현 절차							</div>
</div>

</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
<div class="sg1">
<div class="w1">
<span class="g1">5과목</span>
<span class="g1">라이브러리 기반의 시각화 구현 : D3.js</span>
<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
</div>
</div>
<div class="tg1">
<strong class="tt1">
<span class="tt1n">14.</span>
<span class="tt1t1">
				파이차트를 구현하기 위한 명령어로 가장 적절한 것은 무엇인가?							</span>
</strong>
<span class="tt1t1">
</span>
</div>
<ol class="lst1">
<li class="li1"><a class="a1"><span class="t1">
			d3.layout.pie( )					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			d3.append.pie( ) 					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			d3.draw.pie( ) 					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			d3.svg.pie( )					</span></a></li>
</ol>
<div class="eg1">
<a class="b2 help" href="#m-help1a14" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
<span class="t1">정답보기</span>
<i class="ic1"></i>
</a>
</div>
<div class="tg2 loaded" id="m-help1a14" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
<strong class="tt1">정답</strong>
<div class="t2">
<i class="t2n">1</i>
<span class="t2t1">
			d3.layout.pie( )			</span>
</div>
<br/>
<strong class="tt1">해설</strong>
<div class="t1">
		D3는 시각화를 수월하게 구현할 수 있도록 layout을 제공한다. 파이차트를 구현하는 경우에는 pie layout을 사용한다.				</div>


<div class="more-c">
<strong class="tt1">비기봇 해설</strong>
<div class="t1">
				정답은 1번입니다.<br/>
<br/>
파이차트는 데이터를 시각적으로 표현하는 방법 중 하나로, 각 데이터의 비율을 원형으로 나타내는 그래프입니다. D3.js는 데이터 기반의 문서 조작을 위한 JavaScript 라이브러리로, 다양한 시각화 기능을 제공합니다. 파이차트를 구현하기 위해서는 데이터를 각도에 따라 나누어야 하며, 이를 위해 D3.js의 특정 레이아웃 기능을 사용합니다. D3.js에서 파이차트를 생성하기 위해서는 'd3.layout.pie()' 함수를 사용하여 데이터를 각도로 변환하고, 이를 기반으로 SVG 요소를 생성하여 시각화합니다.<br/>
<br/>
1. d3.layout.pie( ) <br/>
: d3.layout.pie()는 D3.js에서 파이차트를 생성하기 위한 핵심 함수입니다. 이 함수는 주어진 데이터 배열을 받아 각 데이터 항목에 대한 각도를 계산하여 반환합니다. 이 각도 정보는 이후 SVG 요소를 통해 시각적으로 표현됩니다. 따라서, 파이차트를 구현하기 위해서는 이 함수를 사용해야 합니다.<br/>
<br/>
2. d3.append.pie( ) <br/>
: d3.append.pie()는 D3.js의 함수 체인에서 사용되지 않는 구문입니다. D3.js에서 append는 새로운 SVG 요소를 추가할 때 사용되며, pie와 같은 레이아웃을 직접적으로 추가하는 방식은 존재하지 않습니다. 따라서 이 구문은 잘못된 사용입니다.<br/>
<br/>
3. d3.draw.pie( ) <br/>
: d3.draw.pie()는 D3.js에서 제공하는 함수가 아닙니다. D3.js는 데이터를 시각화하기 위해 layout과 shape 기능을 제공하지만, draw라는 함수는 존재하지 않습니다. 파이차트를 그리기 위해서는 layout.pie()를 사용하여 각도를 계산한 후, path 요소를 통해 그려야 합니다.<br/>
<br/>
4. d3.svg.pie( ) <br/>
: d3.svg.pie()는 D3.js에서 제공하는 함수가 아닙니다. D3.js의 svg 모듈은 주로 SVG 요소를 생성하고 조작하는 데 사용되며, 파이차트를 위한 레이아웃 기능은 layout 모듈에 포함되어 있습니다. 따라서 이 구문은 잘못된 사용입니다.<br/>
<br/>
정답은 '1'번입니다. d3.layout.pie()는 D3.js에서 파이차트를 생성하기 위한 올바른 함수로, 데이터를 각도로 변환하여 시각화할 수 있도록 합니다. 나머지 선지들은 D3.js에서 제공하지 않는 함수이거나 잘못된 구문으로, 파이차트를 구현할 수 없습니다.<br/>
따라서, 정답은 '1. d3.layout.pie( )' 입니다.<br/>
</div>
<div class="t2">
									#파이차트									# D3.js									# 데이터 시각화									# layout.pie									# SVG							</div>
</div>

</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
<div class="sg1">
<div class="w1">
<span class="g1">5과목</span>
<span class="g1">라이브러리 기반의 시각화 구현 : D3.js</span>
<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
</div>
</div>
<div class="tg1">
<strong class="tt1">
<span class="tt1n">15.</span>
<span class="tt1t1">
				다음 중 라이브러리를 기반으로 시각화를 구현하는 D3.js의 특징으로 가장 부적절한 것은 무엇인가?							</span>
</strong>
<span class="tt1t1">
</span>
</div>
<ol class="lst1">
<li class="li1"><a class="a1"><span class="t1">
			시각적 요소에 데이터를 직접 입력하는 대신, scale이라는 객체로 데이터와 시각적 요소 간의 관계를 정의한다.					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			모든 시각화 요소들은 항상 HTML 문서의 SVG 객체를 기반으로 동작한다.					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			웹 브라우저 상의 자바 스크립트 환경에서 작동하며, 현존하는 모든 웹 브라우저와 호환된다.					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			scale 객체를 통해 그린 차트나 지도는 스마트폰, 태블릿, 데스크톱 등 다양한 크기의 화면에서 동일하게 나타난다.					</span></a></li>
</ol>
<div class="eg1">
<a class="b2 help" href="#m-help1a15" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
<span class="t1">정답보기</span>
<i class="ic1"></i>
</a>
</div>
<div class="tg2 loaded" id="m-help1a15" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
<strong class="tt1">정답</strong>
<div class="t2">
<i class="t2n">2</i>
<span class="t2t1">
			모든 시각화 요소들은 항상 HTML 문서의 SVG 객체를 기반으로 동작한다.			</span>
</div>
<br/>
<strong class="tt1">해설</strong>
<div class="t1">
		D3.js는 SVG객체에만 의존하지 않고 다양한 요소를 활용할 수 있다.				</div>


<div class="more-c">
<strong class="tt1">비기봇 해설</strong>
<div class="t1">
				1. D3.js는 데이터를 시각적으로 표현할 때 scale 객체를 사용하여 데이터와 시각적 요소 간의 관계를 정의합니다. 예를 들어, 데이터 값을 픽셀 값으로 변환하는 데 사용됩니다. 이는 D3.js의 중요한 특징 중 하나입니다.<br/>
<br/>
2. D3.js는 SVG를 많이 사용하지만, 모든 시각화가 SVG를 기반으로 동작하는 것은 아닙니다. D3.js는 HTML, SVG, Canvas 등 다양한 DOM 요소를 사용하여 시각화를 구현할 수 있습니다. 따라서, "항상 SVG 객체를 기반으로 동작한다"는 부적절한 설명입니다.<br/>
<br/>
3. D3.js는 자바스크립트 라이브러리로, 웹 브라우저 환경에서 작동하며, 주요 웹 브라우저와 호환됩니다. 이는 D3.js의 기본적인 특징입니다.<br/>
<br/>
4. D3.js의 scale 객체와 반응형 디자인을 활용하면, 차트나 지도가 다양한 크기의 화면에서 적절하게 나타날 수 있습니다. D3.js는 반응형 시각화를 지원하기 때문에, 이는 적절한 설명입니다.<br/>
</div>
<div class="t2">
									# D3js							</div>
</div>

</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
<div class="sg1">
<div class="w1">
<span class="g1">5과목</span>
<span class="g1">라이브러리 기반의 시각화 구현 : D3.js</span>
<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
</div>
</div>
<div class="tg1">
<strong class="tt1">
<span class="tt1n">16.</span>
<span class="tt1t1">
				D3.js에서 구현된 시각화 요소를 왼쪽으로 20, 위쪽으로 5 이동하고, 반시계 방향으로 45도 회전하기 위한 코드로 적절한 것은 무엇인가?							</span>
</strong>
<span class="tt1t1">
</span>
</div>
<ol class="lst1">
<li class="li1"><a class="a1"><span class="t1">
			translate(-20, -5) rotate(-45) 					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			translate(20, 5) rotate(-45) 					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			translate(20, -5) rotate(45) 					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			translate(-20, -5) rotate(45)					</span></a></li>
</ol>
<div class="eg1">
<a class="b2 help" href="#m-help1a16" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
<span class="t1">정답보기</span>
<i class="ic1"></i>
</a>
</div>
<div class="tg2 loaded" id="m-help1a16" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
<strong class="tt1">정답</strong>
<div class="t2">
<i class="t2n">1</i>
<span class="t2t1">
			translate(-20, -5) rotate(-45) 			</span>
</div>
<br/>
<strong class="tt1">해설</strong>
<div class="t1">
		translate(a,b)는 a만큼 x축의 방향(오른쪽)으로, b만큼 y축의 아래쪽으로 이동한다는 의미이며, a나 b앞에 – 가 붙으면 반대방향으로 이동한다는 의미이다. rotate(c)는 c만큼 시계 방향으로 회전한다는 의미이며, -c는 반시계 방향이다.				</div>


<div class="more-c">
<strong class="tt1">비기봇 해설</strong>
<div class="t1">
				정답은 1번입니다.<br/>
<br/>
이 문제는 D3.js에서 시각화 요소의 위치와 회전을 조정하는 방법에 대한 이해를 평가합니다. 'translate(x, y)'는 요소를 x축과 y축으로 이동시키는 함수이며, 'rotate(angle)'는 요소를 지정된 각도로 회전시키는 함수입니다. 이때, 이동과 회전의 방향에 주의해야 합니다.<br/>
<br/>
1. translate(-20, -5) rotate(-45)<br/>
: 이 선택지는 요소를 왼쪽으로 20, 위쪽으로 5 이동시키고, 반시계 방향으로 45도 회전시키는 것을 정확히 설명합니다.<br/>
<br/>
2. translate(20, 5) rotate(-45)<br/>
: 이 선택지는 요소를 오른쪽으로 20, 아래로 5 이동시키고, 반시계 방향으로 45도 회전시키는 것으로, 이동 방향이 문제의 요구와 반대입니다.<br/>
<br/>
3. translate(20, -5) rotate(45)<br/>
: 이 선택지는 요소를 오른쪽으로 20, 위쪽으로 5 이동시키고, 시계 방향으로 45도 회전시키는 것으로, 이동 방향과 회전 방향 모두 문제의 요구와 반대입니다.<br/>
<br/>
4. translate(-20, -5) rotate(45)<br/>
: 이 선택지는 요소를 왼쪽으로 20, 위쪽으로 5 이동시키고, 시계 방향으로 45도 회전시키는 것으로, 회전 방향이 문제의 요구와 반대입니다.<br/>
<br/>
<br/>
정답은 1번입니다. 이 선택지는 문제에서 요구한 대로 요소를 왼쪽으로 20, 위쪽으로 5 이동시키고, 반시계 방향으로 45도 회전시키는 것을 정확히 설명합니다. 다른 선택지들은 이동 방향이나 회전 방향이 문제의 요구와 일치하지 않습니다.<br/>
<br/>
따라서, 정답은 '1. translate(-20, -5) rotate(-45)' 입니다.<br/>
</div>
<div class="t2">
									#D3.js									# translate									# rotate									# 시각화									# 좌표 변환							</div>
</div>

</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
<div class="sg1">
<div class="w1">
<span class="g1">5과목</span>
<span class="g1">라이브러리 기반의 시각화 구현 : D3.js</span>
<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
</div>
</div>
<div class="tg1">
<strong class="tt1">
<span class="tt1n">17.</span>
<span class="tt1t1">
				라이브러리를 기반으로 시각화를 구현할 때 축의 눈금 크기를 지정하는 함수는 무엇인가?							</span>
</strong>
<span class="tt1t1">
</span>
</div>
<ol class="lst1">
<li class="li1"><a class="a1"><span class="t1">
			style					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			orient					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			ticks					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			attr					</span></a></li>
</ol>
<div class="eg1">
<a class="b2 help" href="#m-help1a17" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
<span class="t1">정답보기</span>
<i class="ic1"></i>
</a>
</div>
<div class="tg2 loaded" id="m-help1a17" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
<strong class="tt1">정답</strong>
<div class="t2">
<i class="t2n">3</i>
<span class="t2t1">
			ticks			</span>
</div>
<br/>
<strong class="tt1">해설</strong>
<div class="t1">
		ticks 함수는 축의 눈금의 크기를 지정하는 함수이다.				</div>


<div class="more-c">
<strong class="tt1">비기봇 해설</strong>
<div class="t1">
				정답은 3번입니다.<br/>
<br/>
문제는 데이터 시각화에서 축의 눈금 크기를 지정하는 함수에 대한 이해를 요구합니다. 데이터 시각화 라이브러리에서는 축의 눈금을 조정하여 그래프의 가독성을 높일 수 있습니다.<br/>
<br/>
1. style<br/>
: style은 일반적으로 그래프의 스타일을 지정하는 데 사용되며, 축의 눈금 크기와는 직접적인 관련이 없습니다.<br/>
<br/>
2. orient<br/>
: orient는 축의 방향을 설정하는 데 사용되며, 눈금의 크기를 조정하는 기능은 없습니다.<br/>
<br/>
3. ticks<br/>
: ticks는 축의 눈금 크기와 간격을 조정하는 데 사용되는 함수로, 문제에서 요구하는 기능과 일치합니다.<br/>
<br/>
4. attr<br/>
: attr은 속성을 설정하는 데 사용되며, 축의 눈금 크기와는 관련이 없습니다.<br/>
<br/>
<br/>
ticks 함수는 축의 눈금 크기와 간격을 조정하는 데 사용되므로, 문제에서 요구하는 기능과 정확히 일치합니다. 다른 선택지들은 각각 스타일, 방향, 속성 설정과 관련된 기능을 제공하지만, 축의 눈금 크기를 조정하는 기능은 제공하지 않습니다.<br/>
<br/>
따라서, 정답은 '3. ticks' 입니다.<br/>
</div>
<div class="t2">
									#데이터 시각화									# 축									# 눈금									# ticks							</div>
</div>

</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
<div class="sg1">
<div class="w1">
<span class="g1">5과목</span>
<span class="g1">라이브러리 기반의 시각화 구현 : D3.js</span>
<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
</div>
</div>
<div class="tg1">
<strong class="tt1">
<span class="tt1n">18.</span>
<span class="tt1t1">
				아래 그림과 같이 시각화를 구현하기 위해서 코드를 작성할 때, 가장 부적절한 코드는 무엇인가?(단, /는 enter의 의미로 사용되었다.)							</span>
</strong>
<span class="tt1t1">
<a class="p1" href="exam1view1img1.php?img=2025ADP_EXP_S5_C3_18.jpg" rel="noopener" target="_blank" title="새 창">
<img alt="문제에 포함된 이미지" src="https://www.dataedupt.kr/data/img/question/2025ADP_EXP_S5_C3_18.jpg"/>
</a>
</span>
</div>
<ol class="lst1">
<li class="li1"><a class="a1"><span class="t1">
			var x = d3.scale.linear( ) / .range([0, width]);					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			var xAxis = d3.svg.axis( ) / .scale(x) / .orient("bottom"); 					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			var context = canvas.node( ).getContext("2d");					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			x.domain(d3.extent(data, function(d) { return d.x; })).nice( );					</span></a></li>
</ol>
<div class="eg1">
<a class="b2 help" href="#m-help1a18" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
<span class="t1">정답보기</span>
<i class="ic1"></i>
</a>
</div>
<div class="tg2 loaded" id="m-help1a18" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
<strong class="tt1">정답</strong>
<div class="t2">
<i class="t2n">3</i>
<span class="t2t1">
			var context = canvas.node( ).getContext("2d");			</span>
</div>
<br/>
<strong class="tt1">해설</strong>
<div class="t1">
		히트맵으로 비교 시각화를 구현할 때 작성될 수 있는 코드이다.				</div>


<div class="more-c">
<strong class="tt1">비기봇 해설</strong>
<div class="t1">
				정답은 3번입니다.<br/>
<br/>
D3.js는 주로 SVG(Scalable Vector Graphics)를 사용하여 데이터 기반의 문서를 조작하고 시각화를 생성합니다. SVG는 벡터 기반이므로 확대/축소 시에도 선명함을 유지하며, 각 요소가 DOM(Document Object Model)에 노드로 존재하여 상호작용(인터랙션)을 구현하기 용이하다는 장점이 있습니다.<br/>
<br/>
1. var x = d3.scale.linear( ) / .range([0, width]);<br/>
: 이 코드는 D3.js에서 선형 스케일(linear scale)을 정의하는 부분이며, d3.scale.linear()는 입력 데이터 범위를 출력 픽셀 범위(range)로 매핑하는 데 사용됩니다. 산점도에서 데이터 값을 화면의 좌표로 변환하는 데 필수적인 스케일링 함수를 설정하는 올바른 코드입니다. (단, 최신 D3.js 버전에서는 d3.scaleLinear()로 바뀌었으나, 이전 버전에서는 d3.scale.linear()도 사용되었습니다.)<br/>
<br/>
2. var xAxis = d3.svg.axis( ) / .scale(x) / .orient("bottom");<br/>
: 이 코드는 D3.js에서 축(axis)을 생성하는 부분입니다. d3.svg.axis()는 스케일을 기반으로 축을 생성하며, .scale(x)는 이 축이 사용할 스케일을 지정하고, .orient("bottom")은 축의 위치를 아래쪽으로 설정합니다. 산점도에서 x축을 그리는 데 사용되는 올바른 코드입니다.<br/>
<br/>
3. var context = canvas.node( ).getContext("2d");<br/>
: 이 코드는 HTML &lt;canvas&gt; 요소를 가져와 2D 렌더링 컨텍스트를 얻는 데 사용됩니다. &lt;canvas&gt;는 픽셀 기반의 비트맵 이미지를 그리는 HTML 요소이며, 일반적으로 D3.js가 데이터를 시각화할 때 사용하는 SVG 기반의 접근 방식과는 다릅니다. D3.js를 사용하여 웹에서 인터랙티브한 차트를 그릴 때는 주로 SVG를 사용하며, Canvas는 정적인 이미지, 게임, 고성능 애니메이션 등 픽셀 단위 제어가 필요한 경우에 사용됩니다. 주어진 산점도는 SVG로 구현하는 것이 일반적이고, D3.js의 스케일, 축 등의 기능은 SVG 기반 시각화에 더 직접적으로 연결됩니다. 따라서 이 코드는 주어진 시각화 맥락에서 가장 부적절하다.<br/>
<br/>
4. x.domain(d3.extent(data, function(d) { return d.x; })).nice( );<br/>
: 이 코드는 x 스케일의 입력 데이터 범위(domain)를 설정하는 부분이며, d3.extent()는 데이터 배열에서 최솟값과 최댓값을 찾아내어 도메인으로 설정합니다. .nice()는 축의 눈금(tick)이 보기 좋게 정수나 적절한 단위로 확장되도록 도메인을 조정하는 기능이며, 이는 데이터의 범위를 기반으로 시각화의 축 범위를 결정하는 일반적이고 올바른 D3.js 코드입니다.<br/>
<br/>
주어진 산점도 시각화는 D3.js의 SVG 기능을 활용하는 것이 일반적이며, Canvas 관련 코드는 해당 맥락에서 사용되지 않습니다. <br/>
<br/>
따라서 정답은 '3. var context = canvas.node( ).getContext("2d");'입니다.<br/>
</div>
<div class="t2">
									# D3js							</div>
</div>

</div>
</div>
<!-- /cp1question1 -->




<a href="index.html"> &lt; 돌아가기</a>
<script>
/* === AUTO-PATCH: answer-toggle-v2 === */
(function () {
  function qsa(sel, root) { return Array.from((root || document).querySelectorAll(sel)); }
  function qs(sel, root) { return (root || document).querySelector(sel); }

  function getPanelFromBtn(btn) {
    const href = btn && btn.getAttribute('href');
    if (!href || !href.startsWith('#')) return null;
    return document.querySelector(href);
  }

  function setHelpLabel(btn, open) {
    const t = btn ? btn.querySelector('.t1') : null;
    if (t) t.textContent = open ? '정답닫기' : '정답보기';
    if (btn) btn.setAttribute('aria-expanded', String(open));
  }

  function panelIsOpen(panel) {
    if (!panel) return false;
    if (panel.style.display) return panel.style.display !== 'none';
    return getComputedStyle(panel).display !== 'none';
  }

  function openPanel(btn, panel) {
    if (!panel) return;
    panel.style.display = 'block';
    panel.classList.add('loaded');     // 기존 테마 연동
    setHelpLabel(btn, true);
  }

  function closePanel(btn, panel) {
    if (!panel) return;
    panel.style.display = 'none';
    setHelpLabel(btn, false);
  }

  // ✅ 전체 정답 보기/닫기
  window.controlAllAnswers = function (show) {
    qsa('.tg2').forEach(panel => {
      panel.style.display = show ? 'block' : 'none';
      if (show) panel.classList.add('loaded');
    });
    qsa('a.b2.help').forEach(btn => setHelpLabel(btn, show));
  };

  // ✅ 개별 정답보기 토글 (이게 없으면 "클릭해도 아무 동작 없음")
  function onHelpClick(e) {
    const btn = e.target.closest('a.b2.help[href^="#"]');
    if (!btn) return;
    e.preventDefault();

    const panel = getPanelFromBtn(btn);
    if (!panel) return;

    panelIsOpen(panel) ? closePanel(btn, panel) : openPanel(btn, panel);
  }

  // ✅ 보기 클릭 → 정오답 판정 + s1/s2 적용 + 자동 정답보기
  function onOptionPick(e) {
    const li = e.target.closest('.cp1question1 .lst1 .li1');
    if (!li) return;

    const qBox = li.closest('.cp1question1');
    if (!qBox) return;

    const btn = qs('a.b2.help[href^="#"]', qBox);
    const panel = getPanelFromBtn(btn);

    // 정답 번호(i.t2n)는 해설 패널 안에 있음(1-based)
    const n = panel ? panel.querySelector('i.t2n') : null;
    const correctIdx = n ? parseInt((n.textContent || '').trim(), 10) : NaN;

    const options = qsa('.lst1 .li1', qBox);
    const idx = options.indexOf(li) + 1; // 1-based

    if (!Number.isFinite(correctIdx) || correctIdx <= 0) return;

    const isCorrect = idx === correctIdx;
    qBox.setAttribute('data-answer-state', isCorrect ? 'correct' : 'wrong');

    // 헤더 표시 (정답 s1 | 오답 s2)
    const b = qs('.w1 b', qBox);
    if (b) b.className = isCorrect ? 's1' : 's2';

    // 보기에도 클래스 부여(원하면 CSS로 강조)
    options.forEach((opt, i) => {
      opt.classList.remove('is-correct', 'is-wrong');
      if (i + 1 === correctIdx) opt.classList.add('is-correct');
    });
    li.classList.add(isCorrect ? 'is-correct' : 'is-wrong');

    // 자동 정답보기
    openPanel(btn, panel);
  }

  // capture로 등록: 다른 스크립트가 click을 막아도 최대한 동작
  document.addEventListener('click', onHelpClick, true);
  document.addEventListener('click', onOptionPick, true);
})();
</script>

<!-- AUTO:score-counter start -->
<script>
(function () {
  function qsa(sel, root) { return Array.from((root || document).querySelectorAll(sel)); }
  function qs(sel, root) { return (root || document).querySelector(sel); }

  function setText(el, n) {
    if (!el) return;
    el.textContent = String(n) + '개';
  }

  function updateTotal(total) {
    const block = qs('.cp1dlist2');
    if (!block) return;
    qsa('.cp1dlist2 .di1', block).forEach(li => {
      const label = (qs('.dt1', li)?.textContent || '').trim();
      if (label === '총 문제') {
        const dd = qs('.dd1', li);
        if (dd) dd.textContent = String(total) + '개';
      }
    });
  }

  function getPanelFromQ(qBox) {
    const btn = qBox.querySelector('a.b2.help[href^="#"]');
    if (!btn) return null;
    const href = btn.getAttribute('href');
    if (!href || !href.startsWith('#')) return null;
    return document.querySelector(href);
  }

  function getCorrectIndex(panel) {
    const n = panel ? panel.querySelector('i.t2n') : null;
    if (!n) return null;
    const v = parseInt((n.textContent || '').trim(), 10);
    return Number.isFinite(v) ? v : null; // 1-based
  }

  function recompute() {
    const total = qsa('.cp1question1').length;
    let correct = 0;
    let wrong = 0;

    qsa('.cp1question1').forEach(qBox => {
      const state = qBox.getAttribute('data-answer-state');
      if (state === 'correct') correct += 1;
      else if (state === 'wrong') wrong += 1;
    });

    const unanswered = Math.max(0, total - (correct + wrong));

    updateTotal(total);
    setText(qs('.cp1dlist2 .em1'), correct);
    setText(qs('.cp1dlist2 .em2'), wrong);
    setText(qs('.cp1dlist2 .em3'), unanswered);
  }

  function handle(e) {
    const li = e.target.closest('.cp1question1 .lst1 .li1');
    if (!li) return;

    const qBox = li.closest('.cp1question1');
    if (!qBox) return;

    const options = qsa('.lst1 .li1', qBox);
    const idx = options.indexOf(li) + 1; // 1-based
    if (idx <= 0) return;

    const panel = getPanelFromQ(qBox);
    const correctIdx = getCorrectIndex(panel);
    if (!correctIdx) {
      qBox.removeAttribute('data-answer-state');
      recompute();
      return;
    }

    qBox.setAttribute('data-answer-state', (idx === correctIdx) ? 'correct' : 'wrong');
    recompute();
  }

  // click이 막혀도 동작하도록 pointerup도 함께 수신(충돌 방어)
  document.addEventListener('click', handle, true);
  document.addEventListener('pointerup', handle, true);

  function init() { recompute(); }
  if (document.readyState === 'loading') document.addEventListener('DOMContentLoaded', init);
  else init();
})();
</script>
<!-- AUTO:score-counter end -->


  <style>
    /* 스크롤 시 적용될 스타일 */
    .cp1dlist2.fixed {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      z-index: 1000;
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
    }
  </style>
  <script>
    const header = document.querySelector('.cp1dlist2');
    const headerOffset = header.offsetTop;

    window.addEventListener('scroll', () => {
      if (window.scrollY > headerOffset) {
        header.classList.add('fixed');
      } else {
        header.classList.remove('fixed');
      }
    });
  </script>

</body>
</html>
