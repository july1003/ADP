<!-- https://www.dataedupt.kr/sub/study/exam1result1.php?exam=192 -->
<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <script src="https://code.jquery.com/jquery-3.7.1.min.js"></script>
  <title>모의고사 1</title>
</head>
<style>
/* AUTO:exam-ui start */
/* 클릭 가능 UX */
a.b2.help,
.cp1question1 .lst1 .li1,
.cp1question1 .lst1 .li1 a {
  cursor: pointer;
}
/* hover (navy) */
.cp1question1 .lst1 .li1:hover {
  background: rgba(31, 42, 68, 0.06);
}
/* 선택 표시 (navy) */
.cp1question1 .lst1 .li1.is-selected {
  background: rgba(31, 42, 68, 0.12);
  border-radius: 6px;
}
.cp1question1 .lst1 .li1.is-selected .t1 {
  font-weight: 600;
  color: #2980b9; /* 딥 블루 */
}
/* 정답 (navy) */
.cp1question1 .lst1 .li1.is-correct {
  background: rgba(52, 152, 219, 0.18); /* 라이트 블루 */
  border-radius: 6px;
}
.cp1question1 .lst1 .li1.is-correct .t1 {
  font-weight: 700;
  color: #2980b9; /* 딥 블루 */
}
/* 오답 */
.cp1question1 .lst1 .li1.is-wrong {
  background: rgba(160, 30, 30, 0.12);
  border-radius: 6px;
}
.cp1question1 .lst1 .li1.is-wrong .t1 {
  font-weight: 600;
  color: #7a1f1f;
}
/* 보기 버튼 (navy) */
a.b2.help {
  color: #2980b9; /* 딥 블루 */
}
a.b2.help.on {
  font-weight: 600;
}
/* AUTO:exam-ui end */


/* AUTO:clickable-ui start */
a.b2.help,
.cp1question1 .lst1 .li1,
.cp1question1 .lst1 .li1 a {
  cursor: pointer;
}
.cp1question1 .lst1 .li1:hover {
  background: rgba(0, 0, 0, 0.04);
}
a.b2.help:hover {
  opacity: 0.85;
}
/* AUTO:clickable-ui end */
/* AUTO:mobile-scroll-fix start */
html {
  scroll-behavior: smooth;
}
.container {
  max-width: 600px;
  width: 100%;
  margin: 0 auto;
}
/* AUTO:mobile-scroll-fix end */
body {width:100%;}
	.eg1 {padding:10px 0px; text-align:center;width:100%;}
	.tg2 {border-bottom:1px solid #ddd;padding:5% 5%;display:none}
	.cp1question1 {padding-bottom:12px;}
	img {
	  width: 100%;
	  height: 100%;
	  object-fit: contain; /* 또는 cover */
	}
h2 a {
  font-size: 16px;        /* 글씨 크기 */
  text-decoration: none;  /* 밑줄 제거 */
  color: #333;            /* 기본 글자 색 */
  font-weight: 500;       /* 약간 두껍게 */
  transition: color 0.3s ease; /* hover 시 부드럽게 색 변화 */
}
h2 a:hover {
  color: #007acc;         /* hover 시 포인트 색 */
}	

/* AUTO:cp1dlist2-style start */
.cp1dlist2 {
  display: flex;
  justify-content: flex-end;
  background-color: #f0f0f0;
  border-radius: 12px;
  padding: 10px 15px;
}

.cp1dlist2 ul {
  list-style: none;
  margin: 0;
  padding: 0;
  display: flex;
  gap: 10px;
}

.em2 {
  color: #d63031;
}
/* AUTO:cp1dlist2-style end */

</style>
<body>
<div class="container  clearfix">
<h2><a href="index.html"> &lt; 돌아가기</a></h2>

<!-- cp1dlist2 -->
<div class="cp1dlist2">
<ul class="dl1">
<li class="di1">
<a class="a1">
<b class="dt1">총 문제</b>
<span class="dd1">80개</span>
</a>
</li>
<li class="di1">
<a class="a1">
<b class="dt1">맞춘 문제</b>
<span class="dd1"><b class="em1">0개</b></span>
</a>
</li>
<li class="di1">
<a class="a1">
<b class="dt1">틀린 문제</b>
<span class="dd1"><b class="em2">0개</b></span>
</a>
</li>
<li class="di1">
<a class="a1">
<b class="dt1">안 푼 문제</b>
<span class="dd1"><b class="em3">80개</b></span>
</a>
</li>
</ul>
</div>
<!-- /cp1dlist2 -->
<h3 class="hb1 h3">1회 모의고사</h3>
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">1과목</span>
			<span class="g1">데이터베이스 정의와 특징</span>
			<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">1.</span>
			<span class="tt1t1">
				데이터베이스의 특징으로 가장 부적절한 것은?							</span>
		</strong>
		<span class="tt1t1">
				    </span> 
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			데이터베이스는 여러 사용자가 서로 다른 목적으로 데이터를 공동으로 이용할 수 있도록 구성되어 있다. 					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			데이터베이스는 통합된 데이터(integrated data)다. 					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			데이터베이스는 변화하는 데이터로 데이터의 삽입, 삭제, 갱신을 한다고 하더라도 항상 현재의 정확한 데이터를 유지해야 한다. 					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			데이터베이스는 검색기능을 가지고 있으므로 다양한 방법으로 필요한 정보를 검색할 수 있다.					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a1" class="b2 help" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a1" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">4</i>
			<span class="t2t1">
			데이터베이스는 검색기능을 가지고 있으므로 다양한 방법으로 필요한 정보를 검색할 수 있다.			</span>
					</div>
        <br>
				<strong class="tt1">해설</strong>
		<div class="t1">
		데이터베이스의 일반적인 특징 4가지는 통합된 데이터, 저장된 데이터, 공용 데이터, 운영 데이터이다.				</div>
		
				
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				정답은 4번입니다.<br>
<br>
데이터베이스의 특징을 이해하는 것은 데이터 관리와 활용에 있어 매우 중요합니다. 데이터베이스는 여러 사용자가 데이터를 효율적으로 관리하고 활용할 수 있도록 설계된 시스템입니다. 이 문제는 데이터베이스의 기본적인 특성을 이해하고 있는지를 평가합니다.<br>
<br>
1. 데이터베이스는 여러 사용자가 서로 다른 목적으로 데이터를 공동으로 이용할 수 있도록 구성되어 있다.<br>
: 데이터베이스는 여러 사용자가 동시에 접근하여 데이터를 사용할 수 있도록 설계되어 있습니다. 이는 데이터의 공유성을 높이고, 다양한 사용자 요구를 충족시키기 위한 중요한 특징입니다.<br>
<br>
2. 데이터베이스는 통합된 데이터(integrated data)다.<br>
: 데이터베이스는 여러 데이터가 통합되어 관리되는 시스템입니다. 이는 데이터의 중복을 최소화하고, 데이터의 일관성을 유지하는 데 중요한 역할을 합니다.<br>
<br>
3. 데이터베이스는 변화하는 데이터로 데이터의 삽입, 삭제, 갱신을 한다고 하더라도 항상 현재의 정확한 데이터를 유지해야 한다.<br>
: 데이터베이스는 항상 최신의 정확한 데이터를 유지해야 합니다. 이를 위해 데이터의 삽입, 삭제, 갱신 등의 작업이 이루어지며, 이러한 작업은 데이터의 무결성을 보장하는 데 필수적입니다.<br>
<br>
4. 데이터베이스는 검색기능을 가지고 있으므로 다양한 방법으로 필요한 정보를 검색할 수 있다.<br>
: 데이터베이스는 기본적으로 데이터를 저장하고 관리하는 시스템으로, 검색 기능은 필수적이지 않습니다. 검색 기능은 데이터베이스 관리 시스템(DBMS)의 기능 중 하나로, 데이터베이스 자체의 특징으로 보기에는 부적절합니다.<br>
<br>
<br>
데이터베이스의 본질적인 특징은 데이터의 통합, 공유, 무결성 유지 등입니다. 검색 기능은 데이터베이스 관리 시스템(DBMS)의 기능으로, 데이터베이스 자체의 특징으로 보기에는 부적절합니다. 따라서 정답은 4번입니다.<br>
<br>
따라서, 정답은 '4. 데이터베이스는 검색기능을 가지고 있으므로 다양한 방법으로 필요한 정보를 검색할 수 있다.' 입니다.<br>
			</div>
			<div class="t2">
									#데이터베이스									# 통합 데이터									# 데이터 무결성									# 검색 기능							</div>
		</div>
		
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">1과목</span>
			<span class="g1">데이터와 정보</span>
			<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">2.</span>
			<span class="tt1t1">
				DIKW 피라미드의 계층 중 “B마트 보다 상대적으로 저렴한 A마트에서 연필을 사야겠다.”의 내용에 해당하는 계층은 무엇인가? 							</span>
		</strong>
		<span class="tt1t1">
				    </span> 
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			지혜					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			지식					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			정보					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			데이터					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a2" class="b2 help" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a2" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">2</i>
			<span class="t2t1">
			지식			</span>
					</div>
        <br>
				<strong class="tt1">해설</strong>
		<div class="t1">
		DIKW 피라미드에서 "B마트 보다 상대적으로 저렴한 A마트에서 연필을 사야겠다"는 내용은 수집된 데이터(각 마트의 연필 가격)를 통해 정보(A마트가 더 저렴하다)를 얻고, 이 정보를 바탕으로 특정 목적(연필 구매)을 달성하기 위한 결론이나 행동 계획을 세우는 단계에 해당한다. 이는 지식의 정의와 일치한다.				</div>
		
				
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				정답은 2번입니다.<br>
<br>
DIKW 피라미드는 데이터(Data), 정보(Information), 지식(Knowledge), 지혜(Wisdom)의 네 가지 계층으로 이루어져 있으며, 아래에서 위로 갈수록 추상성과 가치가 높아지는 구조를 가집니다.<br>
<br>
1. 지혜<br>
: 지혜는 DIKW 피라미드의 가장 높은 단계에 위치합니다 . 이는 단순히 정보를 아는 것과 지식을 응용하는 것을 넘어, 상황을 깊이 이해하고 근본 원리를 파악하여 최적의 결정을 내리는 능력을 의미합니다 . 예를 들어, "A마트의 다른 상품들도 B마트보다 더 저렴할 것으로 예상되니, 앞으로 A마트를 주로 이용해야겠다"와 같이 미래를 예측하고 더 넓은 범위에 적용하는 통찰이 지혜에 해당합니다. 문제의 내용은 특정 구매 결정에 대한 것이므로 지혜 단계는 아닙니다.<br>
<br>
2. 지식<br>
: 지식은 정보를 이해하고, 경험과 학습을 통해 구조화 및 일반화하여 얻은 것입니다 . 정보들을 모으고 분석하여 일반적인 특성을 파악하고, 이를 바탕으로 '어떻게 목표를 이룰 수 있는지'를 알려줍니다 . 문제의 내용인 "B마트 보다 상대적으로 저렴한 A마트에서 연필을 사야겠다"는 'A마트가 더 저렴하다'는 정보를 바탕으로 'A마트에서 연필을 사는 것이 더 유리하다'는 결론을 내리고 행동 계획을 세운 것입니다. 이는 정보를 실제 상황에 적용하여 얻은 유의미한 결론이므로 지식에 해당합니다.<br>
<br>
3. 정보<br>
: 정보는 의미가 부여되지 않은 단편적인 데이터들을 가공하고 처리하여 연관 관계나 의미를 도출한 것입니다 . 예를 들어, "A마트의 연필 가격이 B마트보다 저렴하다"와 같이 단답형 질문에 대한 답이나 데이터를 비교하여 얻은 사실이 정보에 해당합니다 . 문제의 내용은 단순히 정보를 얻는 것을 넘어, 그 정보를 바탕으로 '무엇을 할 것인가'에 대한 결정을 내린 것이므로 정보 단계보다 한 단계 위입니다.<br>
<br>
4. 데이터<br>
: 데이터는 맥락이나 의미가 부여되지 않은 단편적인 값이나 객관적 사실을 말합니다 . 예를 들어, "A마트 연필 100원", "B마트 연필 150원"과 같이 단순히 나열된 숫자나 사실들이 데이터에 해당합니다 . 문제의 내용은 이러한 원시 데이터를 가공하여 의미를 부여하고, 나아가 행동 계획까지 세운 것이므로 데이터 단계보다 훨씬 상위 개념입니다.<br>
<br>
<br>
문제에서 제시된 문장은 특정 상황에서의 결정을 내리는 과정으로, 이는 지식 계층에 해당합니다. 지식은 정보를 체계적으로 정리하고 이해하여 특정 상황에 적용할 수 있는 능력을 의미합니다. 따라서 'B마트보다 상대적으로 저렴한 A마트에서 연필을 사야겠다'는 결론은 정보를 바탕으로 한 지식의 활용을 보여줍니다. 다른 선택지들은 이 문장의 상황을 설명하기에 적절하지 않습니다.<br>
<br>
따라서, 정답은 '2. 지식' 입니다.<br>
			</div>
			<div class="t2">
									# DIKW 피라미드									# 데이터									# 정보									# 지식									# 지혜							</div>
		</div>
		
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">1과목</span>
			<span class="g1">전략 인사이트 도출을 위한 필요 역략</span>
			<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">3.</span>
			<span class="tt1t1">
				다음 중 데이터 사이언티스트(data scientist)에게 요구되는 소프트 역량(soft skill)이 아닌 것은?							</span>
		</strong>
		<span class="tt1t1">
				    </span> 
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			이론적 지식 					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			창의적 사고 					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			커뮤니케이션 기술					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			비쥬얼라이제이션을 활용한 설득력					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a3" class="b2 help" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a3" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">1</i>
			<span class="t2t1">
			이론적 지식 			</span>
					</div>
        <br>
				<strong class="tt1">해설</strong>
		<div class="t1">
		데이터 사이언티스트에게 요구되는 소프트 역량은 창의적 사고, 호기심, 스토리텔링, 커뮤니케이션 등이 있다. 				</div>
		
				
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				정답은 1번입니다.<br>
<br>
데이터 사이언티스트에게 요구되는 소프트 스킬은 기술적 능력 외에도 다양한 상황에서의 문제 해결 능력, 팀과의 협업, 그리고 복잡한 데이터를 이해하기 쉽게 전달하는 능력 등을 포함합니다.<br>
<br>
1. 이론적 지식<br>
: 이론적 지식은 데이터 사이언티스트에게 필수적인 하드 스킬로, 통계학, 머신러닝, 데이터 분석 등의 기술적 지식을 포함합니다. 이는 소프트 스킬이 아닌 기술적 능력에 해당합니다.<br>
<br>
2. 창의적 사고<br>
: 창의적 사고는 새로운 문제를 해결하고 혁신적인 방법을 찾는 데 중요한 역할을 합니다. 이는 데이터 분석 과정에서 새로운 인사이트를 도출하는 데 필수적입니다.<br>
<br>
3. 커뮤니케이션 기술<br>
: 커뮤니케이션 기술은 복잡한 데이터를 이해하기 쉽게 설명하고, 팀원들과 효과적으로 협력하는 데 필수적입니다. 이는 데이터 사이언티스트가 갖춰야 할 중요한 소프트 스킬입니다.<br>
<br>
4. 비쥬얼라이제이션을 활용한 설득력<br>
: 비쥬얼라이제이션을 활용한 설득력은 데이터를 시각적으로 표현하여 이해를 돕고, 의사결정자에게 효과적으로 전달하는 데 중요한 역할을 합니다. 이는 데이터 사이언티스트의 중요한 소프트 스킬 중 하나입니다.<br>
<br>
<br>
이론적 지식은 데이터 사이언티스트에게 필수적인 하드 스킬로, 소프트 스킬에 해당하지 않습니다. 반면, 창의적 사고, 커뮤니케이션 기술, 비쥬얼라이제이션을 활용한 설득력은 모두 데이터 사이언티스트가 갖춰야 할 중요한 소프트 스킬입니다.<br>
<br>
따라서, 정답은 '1. 이론적 지식' 입니다.<br>
			</div>
			<div class="t2">
									#데이터 사이언티스트									# 소프트 스킬									# 이론적 지식									# 커뮤니케이션							</div>
		</div>
		
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">1과목</span>
			<span class="g1">빅데이터의 이해</span>
			<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">4.</span>
			<span class="tt1t1">
				다음 중 빅데이터 분석에 경제성을 제공해 준 결정적인 기술로 가장 적절한 것은?							</span>
		</strong>
		<span class="tt1t1">
				    </span> 
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			저장장치 비용의 지속적인 하락 					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			텍스트 마이닝					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			클라우드 컴퓨팅 					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			스마트폰의 급속한 확산					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a4" class="b2 help" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a4" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">3</i>
			<span class="t2t1">
			클라우드 컴퓨팅 			</span>
					</div>
        <br>
				<strong class="tt1">해설</strong>
		<div class="t1">
		클라우드 컴퓨팅의 보편화는 빅데이터의 처리 비용을 획기적으로 낮춰 경제성을 제공했다.				</div>
		
				
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				정답은 3번입니다.<br>
<br>
빅데이터 분석의 경제성은 대량의 데이터를 효율적으로 저장하고 처리할 수 있는 기술에 의해 크게 향상됩니다. 이러한 기술은 데이터의 저장, 처리, 분석을 보다 저렴하고 빠르게 수행할 수 있도록 지원합니다.<br>
<br>
1. 저장장치 비용의 지속적인 하락<br>
: 데이터 저장 비용의 감소는 대량의 데이터를 저장하는 데 드는 비용을 줄여주지만, 데이터 처리와 분석의 경제성을 직접적으로 향상시키는 기술은 아닙니다.<br>
<br>
2. 텍스트 마이닝<br>
: 텍스트 마이닝은 비정형 데이터에서 유용한 정보를 추출하는 기술로, 데이터 분석의 한 부분을 담당하지만, 전체적인 경제성을 제공하는 기술은 아닙니다.<br>
<br>
3. 클라우드 컴퓨팅<br>
: 클라우드 컴퓨팅은 대량의 데이터를 저장하고 처리할 수 있는 유연한 인프라를 제공하여 초기 투자 비용을 줄이고, 필요에 따라 자원을 확장할 수 있어 경제성을 크게 향상시킵니다.<br>
<br>
4. 스마트폰의 급속한 확산<br>
: 스마트폰의 확산은 데이터 생성의 증가를 가져왔지만, 데이터 분석의 경제성을 직접적으로 제공하는 기술은 아닙니다.<br>
<br>
<br>
클라우드 컴퓨팅은 대량의 데이터를 효율적으로 저장하고 처리할 수 있는 인프라를 제공하여 초기 비용을 절감하고, 필요에 따라 자원을 확장할 수 있어 경제성을 크게 향상시킵니다. 다른 선택지들은 데이터 분석의 특정 측면에 기여할 수 있지만, 전체적인 경제성을 제공하는 데는 한계가 있습니다.<br>
<br>
따라서, 정답은 '3. 클라우드 컴퓨팅' 입니다.<br>
			</div>
			<div class="t2">
									#빅데이터									# 경제성									# 클라우드 컴퓨팅									# 데이터 저장							</div>
		</div>
		
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">1과목</span>
			<span class="g1">빅데이터 그리고 데이터 사이언스의 미래</span>
			<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">5.</span>
			<span class="tt1t1">
				아래와 같은 SQL 문장을 사용할 때, 출력되는 결과로 옳은 것은?					
					<span class="tt1t1">
						select customer_name as "고객명", e_customer_name as "고객 영문명"<br>
from customer <br>
where e_customer_name like '_A%';					</span>
							</span>
		</strong>
		<span class="tt1t1">
				    </span> 
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			영문명이 A로 시작하는 고객들의 이름 					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			영문명에 A를 포함한 고객들의 비율 					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			위치 상관없이 영문명에 A를 포함하는 고객들의 이름 					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			영문명에 두 번째 문자가 A인 고객들의 이름					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a5" class="b2 help" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a5" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">4</i>
			<span class="t2t1">
			영문명에 두 번째 문자가 A인 고객들의 이름			</span>
					</div>
        <br>
				<strong class="tt1">해설</strong>
		<div class="t1">
		SQL을 통해 특정 데이터셋에서 필요한 데이터를 추출하고자 할 때 명령문은 “select(특정 변수들) from(데이터셋) where(조건절 형태의 표현)”으로 사용하면 된다. 조건절 형태의 표현에서 ①번은 ‘A%’로 표현되고, ②번은 where 절에서 나올 수 없는 답이며 ③번은 ‘%A%’로 표현하여야 한다. 				</div>
		
				
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				정답은 4번입니다.<br>
<br>
SQL의 LIKE 연산자는 문자열 패턴을 검색하는 데 사용됩니다. 이 연산자는 와일드카드 문자인 '%'와 '_'를 사용하여 문자열의 특정 패턴을 찾습니다. '%'는 0개 이상의 임의의 문자와 일치하며, '_'는 정확히 하나의 임의의 문자와 일치합니다. 예를 들어, '_A%' 패턴은 두 번째 문자가 'A'인 문자열을 찾습니다. 이는 SQL 쿼리에서 특정 패턴을 가진 데이터를 필터링할 때 매우 유용합니다.<br>
<br>
1. 영문명이 A로 시작하는 고객들의 이름 <br>
: 이 선지는 영문명이 A로 시작하는 고객들의 이름을 찾는 것을 의미합니다. 그러나 '_A%' 패턴은 두 번째 문자가 'A'인 경우를 찾기 때문에, 이 선지는 틀렸습니다. 만약 'A%' 패턴을 사용했다면, 영문명이 A로 시작하는 경우를 찾을 수 있습니다.<br>
<br>
2. 영문명에 A를 포함한 고객들의 비율 <br>
: 이 선지는 영문명에 A를 포함한 고객들의 비율을 찾는 것을 의미합니다. 그러나 LIKE 연산자는 비율을 계산하는 것이 아니라, 특정 패턴을 가진 문자열을 필터링하는 데 사용됩니다. 따라서 이 선지는 틀렸습니다.<br>
<br>
3. 위치 상관없이 영문명에 A를 포함하는 고객들의 이름 <br>
: 이 선지는 위치에 상관없이 영문명에 A를 포함하는 고객들의 이름을 찾는 것을 의미합니다. 그러나 '_A%' 패턴은 두 번째 문자가 'A'인 경우만 찾기 때문에, 이 선지는 틀렸습니다. 만약 '%A%' 패턴을 사용했다면, 위치에 상관없이 A를 포함하는 경우를 찾을 수 있습니다.<br>
<br>
4. 영문명에 두 번째 문자가 A인 고객들의 이름 <br>
: 이 선지는 영문명에 두 번째 문자가 A인 고객들의 이름을 찾는 것을 의미합니다. '_A%' 패턴은 정확히 두 번째 문자가 'A'인 경우를 찾기 때문에, 이 선지가 맞습니다.<br>
<br>
정답은 4번입니다. '_A%' 패턴은 두 번째 문자가 'A'인 문자열을 찾는 데 사용됩니다. 다른 선지들은 이 패턴의 의미를 잘못 해석했거나, LIKE 연산자의 기능과 맞지 않는 설명을 하고 있습니다. 따라서 4번이 정답입니다.<br>
따라서, 정답은 '4. 영문명에 두 번째 문자가 A인 고객들의 이름' 입니다.<br>
			</div>
			<div class="t2">
									#SQL									# LIKE 연산자									# 와일드카드									# 패턴 매칭									# 문자열 필터링							</div>
		</div>
		
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">1과목</span>
			<span class="g1">비즈니스 모델</span>
			<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">6.</span>
			<span class="tt1t1">
				인터넷 등 각종 경로로 정보를 수집하는 구글은 이미 지난 2010년에 서비스 이용자가 1시간 뒤에 어떤 일을 할지 87% 정확도로 예측할 수 있는 데이터와 분석 신뢰도를 확보하고 있다고 했다. 또, 여행사실을 트위트한 사람의 집을 강도가 노리는 고전적 사례도 발생했다. 이러한 사례를 통해 알 수 있는 빅데이터 시대의 위기 요인으로 적절한 것은?							</span>
		</strong>
		<span class="tt1t1">
				    </span> 
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			소셜 네트워크 					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			책임 원칙 훼손 					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			데이터 오용 					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			사생활 침해					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a6" class="b2 help" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a6" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">4</i>
			<span class="t2t1">
			사생활 침해			</span>
					</div>
        <br>
				<strong class="tt1">해설</strong>
		<div class="t1">
		사생활 침해에 대한 설명이다.				</div>
		
				
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				정답은 4번입니다.<br>
<br>
이 문제는 빅데이터 시대에 발생할 수 있는 위기 요인을 묻고 있습니다. 구글의 데이터 분석 능력과 소셜 미디어의 정보 노출 사례를 통해 개인의 사생활이 침해될 수 있는 가능성을 제시하고 있습니다.<br>
<br>
1. 소셜 네트워크<br>
: 소셜 네트워크는 정보가 빠르게 확산되는 경로로, 개인 정보가 쉽게 노출될 수 있는 환경을 제공합니다. 그러나 이 자체가 위기 요인이라기보다는 정보 노출의 매개체로 작용합니다.<br>
<br>
2. 책임 원칙 훼손<br>
: 책임 원칙 훼손은 데이터 사용에 대한 책임이 명확하지 않을 때 발생할 수 있는 문제입니다. 이는 데이터 관리와 관련된 윤리적 문제로, 위기 요인 중 하나일 수 있습니다.<br>
<br>
3. 데이터 오용<br>
: 데이터 오용은 수집된 데이터가 원래 의도와 다르게 사용될 때 발생하는 문제입니다. 이는 데이터 관리의 부주의로 인한 문제로, 위기 요인으로 작용할 수 있습니다.<br>
<br>
4. 사생활 침해<br>
: 사생활 침해는 개인의 정보가 무단으로 수집, 분석, 사용될 때 발생하는 문제로, 빅데이터 시대에 가장 큰 위기 요인 중 하나입니다. 개인의 프라이버시가 보호되지 않을 때 발생할 수 있는 심각한 문제입니다.<br>
<br>
<br>
문제에서 제시한 사례들은 개인의 사생활이 침해될 수 있는 가능성을 보여주고 있습니다. 구글의 데이터 분석 능력과 소셜 미디어의 정보 노출 사례는 개인의 행동과 위치가 쉽게 예측되고 노출될 수 있음을 시사합니다. 따라서, 빅데이터 시대의 가장 큰 위기 요인은 '사생활 침해'입니다. 다른 선택지들은 데이터 관리와 관련된 문제이지만, 문제에서 제시한 사례와 직접적으로 관련된 것은 사생활 침해입니다.<br>
<br>
따라서, 정답은 '4. 사생활 침해' 입니다.<br>
			</div>
			<div class="t2">
									#빅데이터									# 사생활 침해									# 데이터 분석									# 정보 노출							</div>
		</div>
		
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">1과목</span>
			<span class="g1">빅데이터 분석과 전략 인사이트</span>
			<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">7.</span>
			<span class="tt1t1">
				사물끼리 정보를 주고 받는 사물인터넷 시대를 빅데이터의 관점에서 바라볼 때 다음 중 사물인터넷의 의미로 가장 적절한 것은?							</span>
		</strong>
		<span class="tt1t1">
				    </span> 
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			모든 것의 데이터화(datafication) 					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			서비스 지능화(intelligent service) 					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			분석 고급화(advanced analytics) 					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			정보 공유화(information sharing)					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a7" class="b2 help" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a7" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">1</i>
			<span class="t2t1">
			모든 것의 데이터화(datafication) 			</span>
					</div>
        <br>
				<strong class="tt1">해설</strong>
		<div class="t1">
		빅데이터 관점에서 사물인터넷은 사물에서 나오는 데이터를 활용해 더욱 지능화 된 기기 활용을 할 수 있도록 데이터를 수집하여야 하므로 모든 사물에서 데이터를 추출할 수 있어야 된다.				</div>
		
				
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				정답은 1번입니다.<br>
<br>
사물인터넷(IoT)은 다양한 사물들이 인터넷을 통해 서로 연결되어 정보를 주고받는 기술을 의미합니다. 이는 데이터를 수집하고 분석하여 더 나은 서비스를 제공하는 데 중점을 둡니다.<br>
<br>
1. 모든 것의 데이터화(datafication)<br>
: 모든 사물에서 발생하는 데이터를 수집하고 이를 활용하여 다양한 분석과 서비스를 제공하는 것이 사물인터넷의 핵심입니다. 이는 사물인터넷의 본질을 가장 잘 설명합니다.<br>
<br>
2. 서비스 지능화(intelligent service)<br>
: 서비스 지능화는 사물인터넷의 결과로 나타날 수 있는 현상 중 하나입니다. 그러나 사물인터넷 자체의 정의를 설명하는 데는 적합하지 않습니다.<br>
<br>
3. 분석 고급화(advanced analytics)<br>
: 분석 고급화는 사물인터넷을 통해 수집된 데이터를 처리하는 과정에서 나타날 수 있는 기술적 발전을 의미합니다. 하지만 사물인터넷의 정의를 직접적으로 설명하지는 않습니다.<br>
<br>
4. 정보 공유화(information sharing)<br>
: 정보 공유화는 사물인터넷의 기능 중 하나로, 사물 간의 정보 교환을 통해 효율성을 높이는 것을 의미합니다. 그러나 사물인터넷의 전체적인 의미를 설명하는 데는 부족합니다.<br>
<br>
<br>
사물인터넷은 모든 사물의 데이터를 수집하고 이를 통해 다양한 서비스를 제공하는 것을 의미합니다. 따라서 모든 것의 데이터화가 사물인터넷의 정의에 가장 부합합니다. 다른 선택지들은 사물인터넷의 결과나 기능을 설명할 수 있지만, 정의 자체를 설명하는 데는 적절하지 않습니다.<br>
<br>
따라서, 정답은 '1. 모든 것의 데이터화(datafication)' 입니다.<br>
			</div>
			<div class="t2">
									#사물인터넷									# 데이터화									# 정보 교환									# 서비스 제공							</div>
		</div>
		
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">1과목</span>
			<span class="g1">전략 인사이트 도출을 위한 필요 역략</span>
			<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">8.</span>
			<span class="tt1t1">
				빅데이터와 데이터 사이언스의 미래를 위한 외부 환경적 측면에서 인문학의 열풍의 원인을 설명한것 중 옳지 않은 것은?							</span>
		</strong>
		<span class="tt1t1">
				    </span> 
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			단순 세계화에서 복잡한 세계화로 변화하는 과정에서 인문학의 중요성을 인식하여야 한다. 					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			비즈니스의 화두가 글로벌 네트워크를 통한 대량 공급으로 변함에 따라 가격 인하 정책의 성공을 위해서는 인문학이 중요하다. 					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			비즈니스 중심이 제품생산에서 서비스로 이동함에 따라 인문학의 중요성이 증가하고 있다. 					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			경제와 산업의 논리가 생산에서 시장 창조로 변화하면서 인문학의 중요성이 증가하고 있다.					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a8" class="b2 help" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a8" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">2</i>
			<span class="t2t1">
			비즈니스의 화두가 글로벌 네트워크를 통한 대량 공급으로 변함에 따라 가격 인하 정책의 성공을 위해서는 인문학이 중요하다. 			</span>
					</div>
        <br>
				<strong class="tt1">해설</strong>
		<div class="t1">
		대량 생산을 통한 가격 경쟁력 확보와 글로벌 네트워크를 통한 판매 확대는 과거의 비즈니스 전략이다.				</div>
		
				
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				정답은 2번입니다.<br>
<br>
인문학의 중요성은 현대 사회의 복잡한 변화와 밀접하게 연결되어 있습니다. 단순한 세계화에서 복잡한 세계화로의 변화는 다양한 문화와 가치가 공존하는 환경을 만들어내고, 이러한 환경에서 인문학은 사람들 간의 관계와 창의성을 이해하는 데 필수적입니다. 비즈니스의 중심이 제품 생산에서 서비스로 이동하면서, 고객의 내면적 요구를 이해하고 뛰어난 서비스를 제공하는 능력이 중요해졌습니다. 또한, 경제와 산업의 논리가 생산 중심에서 시장 창조로 변화하면서, 인문학적 통찰력은 새로운 시장을 창출하는 데 중요한 역할을 합니다.<br>
<br>
1. 단순 세계화에서 복잡한 세계화로 변화하는 과정에서 인문학의 중요성을 인식하여야 한다. <br>
: 세계화의 변화는 단순히 경제적 규모의 확장만을 의미하지 않습니다. 복잡한 세계화는 다양한 문화와 가치가 공존하는 환경을 만들어내며, 이러한 환경에서 인문학은 사람들 간의 관계와 창의성을 이해하는 데 필수적입니다. 인문학은 복잡한 세계에서의 다양성과 연결성을 이해하는 데 중요한 역할을 합니다.<br>
<br>
2. 비즈니스의 화두가 글로벌 네트워크를 통한 대량 공급으로 변함에 따라 가격 인하 정책의 성공을 위해서는 인문학이 중요하다. <br>
: 비즈니스의 화두가 글로벌 네트워크를 통한 대량 공급으로 변함에 따라 가격 인하 정책이 중요해졌다는 주장은 인문학의 중요성과 직접적인 관련이 없습니다. 인문학은 주로 사람들의 내면적 요구와 창의성을 이해하는 데 중점을 두며, 가격 인하와 같은 경제적 전략과는 다른 차원의 문제입니다.<br>
<br>
3. 비즈니스 중심이 제품생산에서 서비스로 이동함에 따라 인문학의 중요성이 증가하고 있다. <br>
: 비즈니스 중심이 제품 생산에서 서비스로 이동하면서, 고객의 내면적 요구를 이해하고 뛰어난 서비스를 제공하는 능력이 중요해졌습니다. 인문학은 이러한 서비스 중심의 비즈니스 환경에서 고객과의 관계를 이해하고, 창의적이고 직관적인 서비스를 제공하는 데 필수적입니다.<br>
<br>
4. 경제와 산업의 논리가 생산에서 시장 창조로 변화하면서 인문학의 중요성이 증가하고 있다. <br>
: 경제와 산업의 논리가 생산 중심에서 시장 창조로 변화하면서, 인문학적 통찰력은 새로운 시장을 창출하는 데 중요한 역할을 합니다. 인문학은 시장의 변화와 고객의 내면적 요구를 이해하는 데 도움을 주며, 이는 새로운 비즈니스 기회를 창출하는 데 필수적입니다.<br>
<br>
선지 2는 인문학의 중요성과 직접적인 관련이 없는 경제적 전략을 언급하고 있습니다. 인문학은 주로 사람들의 내면적 요구와 창의성을 이해하는 데 중점을 두며, 가격 인하와 같은 경제적 전략과는 다른 차원의 문제입니다. 다른 선지들은 인문학이 현대 사회의 변화와 비즈니스 환경에서 어떻게 중요한 역할을 하는지를 잘 설명하고 있습니다.<br>
따라서, 정답은 '2. 비즈니스의 화두가 글로벌 네트워크를 통한 대량 공급으로 변함에 따라 가격 인하 정책의 성공을 위해서는 인문학이 중요하다.' 입니다.<br>
			</div>
			<div class="t2">
									#인문학									# 세계화									# 서비스									# 시장 창조									# 창의성							</div>
		</div>
		
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">1과목</span>
			<span class="g1">빅데이터 그리고 데이터 사이언스의 미래</span>
			<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">9.</span>
			<span class="tt1t1">
				개인정보의 식별성을 제거하거나 데이터 셋과 정보주체의 연관성을 제거하는 과정을 개인정보 비식별화라고 한다. 비식별화가 적용된 아래의 예시에 해당하는 기법은 무엇인가?					
					<span class="tt1t1">
						한국데이터진흥원 → A1234					</span>
							</span>
		</strong>
		<span class="tt1t1">
				    </span> 
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			가명처리 					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			데이터마스킹 					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			범주화 					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			총계처리					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a9" class="b2 help" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a9" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">1</i>
			<span class="t2t1">
			가명처리 			</span>
					</div>
        <br>
				<strong class="tt1">해설</strong>
		<div class="t1">
		가명처리는 개인정보주체의 이름을 다른 이름으로 변경하는 기술로 다른 값으로 대체하는 일정한 규칙이 노출되지 않도록 주의해야 한다.				</div>
		
				
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				정답은 1번입니다.<br>
<br>
문제는 개인정보 비식별화 기법에 대한 이해를 요구합니다. 개인정보 비식별화는 데이터에서 개인을 식별할 수 있는 정보를 제거하거나 변형하여 개인의 프라이버시를 보호하는 방법입니다. 주어진 보기에서는 '한국데이터진흥원'이라는 정보를 'A1234'로 변환하여 식별성을 제거하고 있습니다.<br>
<br>
1. 가명처리<br>
: 가명처리는 원래의 데이터를 다른 값으로 대체하여 식별성을 제거하는 방법입니다. 이는 데이터의 원래 의미를 유지하면서도 개인을 식별할 수 없도록 합니다.<br>
<br>
2. 데이터마스킹<br>
: 데이터마스킹은 데이터의 일부를 숨기거나 변형하여 민감한 정보를 보호하는 방법입니다. 주로 데이터의 특정 부분을 가려서 보이지 않게 합니다.<br>
<br>
3. 범주화<br>
: 범주화는 데이터를 특정 범주로 묶어 개별 데이터의 식별성을 줄이는 방법입니다. 이는 데이터의 세부 정보를 일반화하여 식별 가능성을 낮춥니다.<br>
<br>
4. 총계처리<br>
: 총계처리는 데이터를 집계하여 개별 데이터의 식별성을 제거하는 방법입니다. 이는 데이터의 개별 항목을 합산하여 전체적인 통계만을 제공합니다.<br>
<br>
<br>
보기에서 '한국데이터진흥원'을 'A1234'로 변환한 것은 원래의 데이터를 다른 값으로 대체하여 식별성을 제거하는 가명처리 기법에 해당합니다. 다른 선택지들은 각각 데이터의 특정 부분을 숨기거나, 범주로 묶거나, 집계하는 방법으로, 보기의 예시와는 맞지 않습니다.<br>
<br>
따라서, 정답은 '1. 가명처리' 입니다.<br>
			</div>
			<div class="t2">
									#비식별화									# 가명처리									# 데이터마스킹									# 범주화									# 총계처리							</div>
		</div>
		
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">1과목</span>
			<span class="g1">빅데이터의 이해</span>
			<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">10.</span>
			<span class="tt1t1">
				특정 그룹의 편중된 의견으로 인해 왜곡된 결과를 초래하는 문제가 빅데이터의 도입으로 해결되고 있다. 다음 중 이와 관련 있는 변화는 무엇인가?							</span>
		</strong>
		<span class="tt1t1">
				    </span> 
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			사후처리로의 변화 					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			전수조사로의 변화 					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			인과관계로의 변화 					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			상관관계로의 변화					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a10" class="b2 help" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a10" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">2</i>
			<span class="t2t1">
			전수조사로의 변화 			</span>
					</div>
        <br>
				<strong class="tt1">해설</strong>
		<div class="t1">
		데이터 수집 비용 감소와 클라우드 컴퓨팅 기술의 발전으로 표본을 조사하는 기존의 지식 발견의 방식이 전수조사를 통해 샘플링이 주지 못하는 패턴이나 정보를 제공해준다.				</div>
		
				
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				정답은 2번입니다.<br>
<br>
문제는 빅데이터의 도입으로 인해 특정 그룹의 편중된 의견으로 왜곡된 결과를 해결할 수 있는 변화를 묻고 있습니다. 빅데이터는 대량의 데이터를 수집하고 분석하여 보다 객관적이고 신뢰할 수 있는 결과를 도출하는 데 도움을 줍니다.<br>
<br>
1. 사후처리로의 변화<br>
: 사후처리는 이미 발생한 사건이나 데이터를 분석하여 결과를 도출하는 방법입니다. 이는 빅데이터의 도입과는 직접적인 관련이 없습니다.<br>
<br>
2. 전수조사로의 변화<br>
: 전수조사는 전체 데이터를 수집하여 분석하는 방법으로, 빅데이터의 도입으로 인해 가능해진 변화 중 하나입니다. 이는 특정 그룹의 편중된 의견을 최소화하고 보다 객관적인 결과를 도출할 수 있게 합니다.<br>
<br>
3. 인과관계로의 변화<br>
: 인과관계는 두 변수 간의 원인과 결과를 설명하는 관계입니다. 빅데이터는 인과관계를 분석하는 데 도움을 줄 수 있지만, 문제에서 묻는 변화와는 직접적인 관련이 없습니다.<br>
<br>
4. 상관관계로의 변화<br>
: 상관관계는 두 변수 간의 관계를 설명하는 것으로, 빅데이터를 통해 상관관계를 분석할 수 있지만, 문제에서 묻는 변화와는 직접적인 관련이 없습니다.<br>
<br>
<br>
전수조사는 빅데이터의 도입으로 인해 가능해진 변화로, 특정 그룹의 편중된 의견을 최소화하고 보다 객관적인 결과를 도출할 수 있게 합니다. 다른 선택지들은 빅데이터의 도입과 직접적인 관련이 없거나 문제에서 묻는 변화와는 관련이 없습니다.<br>
<br>
따라서, 정답은 '2. 전수조사로의 변화' 입니다.<br>
			</div>
			<div class="t2">
									#빅데이터									# 전수조사									# 편중된 의견									# 객관적 결과							</div>
		</div>
		
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">2과목</span>
			<span class="g1">ETL(Extraction, Trans formation and Load)</span>
			<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">11.</span>
			<span class="tt1t1">
				데이터 웨어하우스의 테이블 모델링 기법 중 하나인 스타 스키마에 대한 설명으로 가장 적절한 것은? 							</span>
		</strong>
		<span class="tt1t1">
				    </span> 
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			차원 테이블을 제3정규형으로 정규화한 형태이다.					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			복잡도가 낮아서 쿼리 작성이 용이하고, 조인 테이블 개수가 적은 장점을 갖는다. 					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			데이터의 중복이 제거돼 데이터 적재 시간이 단축되는 장점이 있다.					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			데이터베이스 내에서 관리해야 할 테이블의 수가 스노우 플레이크 스키마보다 증가한다.					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a11" class="b2 help" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a11" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">2</i>
			<span class="t2t1">
			복잡도가 낮아서 쿼리 작성이 용이하고, 조인 테이블 개수가 적은 장점을 갖는다. 			</span>
					</div>
        <br>
				<strong class="tt1">해설</strong>
		<div class="t1">
		①, ③번은 스노우 플레이크 스키마와 관련된 설명이다. 또한 스노우 플레이크 스키가 스타 스키마보다 데이터베이스 내 테이블의 수를 더 많이 가진다.				</div>
		
				
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				정답은 2번입니다.<br>
<br>
스타 스키마는 데이터 웨어하우스의 테이블 모델링 기법 중 하나로, 단일 사실 테이블을 중심으로 여러 차원 테이블이 연결된 구조입니다. 이 구조는 데이터베이스의 복잡도를 낮추고 쿼리 작성이 용이하게 하며, 조인 테이블의 개수를 줄이는 장점이 있습니다. 반면, 차원 테이블이 비정규화되어 데이터 중복이 발생할 수 있으며, 이는 데이터 적재 시 시간이 더 소요될 수 있습니다. 스타 스키마는 스노우 플레이크 스키마와 비교했을 때 구조가 단순하여 이해하기 쉽고, 쿼리 작성이 용이하다는 특징이 있습니다.<br>
<br>
1. 차원 테이블을 제3정규형으로 정규화한 형태이다. <br>
: 스타 스키마의 차원 테이블은 일반적으로 비정규화된 형태로 모델링됩니다. 이는 데이터 중복을 허용하여 쿼리 성능을 높이기 위한 것입니다. 제3정규형으로 정규화된 형태는 스노우 플레이크 스키마의 특징입니다. 정규화는 데이터 중복을 줄이고 데이터 무결성을 유지하는 데 유리하지만, 쿼리 시 조인 연산이 많아져 성능이 저하될 수 있습니다.<br>
<br>
2. 복잡도가 낮아서 쿼리 작성이 용이하고, 조인 테이블 개수가 적은 장점을 갖는다. <br>
: 스타 스키마는 구조가 단순하여 이해하기 쉽고, 쿼리 작성이 용이합니다. 이는 차원 테이블이 비정규화되어 있어 조인 테이블의 개수가 적기 때문입니다. 이러한 특성 덕분에 데이터 분석가들이 데이터를 빠르게 조회하고 분석할 수 있습니다. 이는 스타 스키마의 주요 장점 중 하나입니다.<br>
<br>
3. 데이터의 중복이 제거돼 데이터 적재 시간이 단축되는 장점이 있다. <br>
: 데이터의 중복이 제거되어 데이터 적재 시간이 단축되는 것은 스노우 플레이크 스키마의 장점입니다. 스노우 플레이크 스키마는 차원 테이블을 정규화하여 데이터 중복을 최소화하고, 데이터 적재 시 효율성을 높입니다. 그러나 이는 스타 스키마의 특징이 아닙니다.<br>
<br>
4. 데이터베이스 내에서 관리해야 할 테이블의 수가 스노우 플레이크 스키마보다 증가한다. <br>
: 스타 스키마는 스노우 플레이크 스키마에 비해 테이블의 수가 적습니다. 스노우 플레이크 스키마는 차원 테이블을 정규화하여 더 많은 테이블을 생성하므로, 데이터베이스 내에서 관리해야 할 테이블의 수가 증가합니다. 따라서 이 설명은 스타 스키마에 해당하지 않습니다.<br>
<br>
스타 스키마는 차원 테이블이 비정규화되어 있어 구조가 단순하고, 쿼리 작성이 용이하며 조인 테이블의 개수가 적습니다. 이는 선지 2의 설명과 일치합니다. 반면, 선지 1은 스노우 플레이크 스키마의 특징을 설명하고 있으며, 선지 3과 4는 스타 스키마의 특성과 맞지 않습니다.<br>
따라서, 정답은 '2. 복잡도가 낮아서 쿼리 작성이 용이하고, 조인 테이블 개수가 적은 장점을 갖는다.' 입니다.<br>
			</div>
			<div class="t2">
									#스타 스키마									# 데이터 웨어하우스									# 차원 테이블									# 비정규화									# 쿼리 작성							</div>
		</div>
		
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">2과목</span>
			<span class="g1">분산 데이터 저장 기술</span>
			<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">12.</span>
			<span class="tt1t1">
				다음 중 데이터베이스 클러스터에 대한 설명으로 가장 적절한 것은?							</span>
		</strong>
		<span class="tt1t1">
				    </span> 
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			오픈소스인  MySQL 클러스터는 비공유형으로써 메모리 기반 데이터베이스의 클러스터링을 지원한다.					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			데이터베이스 클러스터를 구성했을 때 성능의 특정 파티션에서 장애가 발생하면 서비스가 중단될 수도 있다.					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			공유 디스크 클러스터에서는 SAN(Storage Area Network)과 같은 네트워크가 없어도 데이터의 공유가 가능하다.					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			공유 디스크의 경우 클러스터의 규모가 커질 때 디스크의 성능이 높아진다는 것이 최대 장점이다.					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a12" class="b2 help" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a12" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">1</i>
			<span class="t2t1">
			오픈소스인  MySQL 클러스터는 비공유형으로써 메모리 기반 데이터베이스의 클러스터링을 지원한다.			</span>
					</div>
        <br>
				<strong class="tt1">해설</strong>
		<div class="t1">
		MySQL 클러스터는 비공유형으로서 메모리(최근 디스크도 제공) 기반 데이터베이스의 클러스터링을 지원한다.				</div>
		
				
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				정답은 1번입니다.<br>
<br>
데이터베이스 클러스터는 여러 서버나 가상 서버에 하나의 데이터베이스를 구축하여 성능과 가용성을 높이는 기술입니다. 클러스터링은 데이터베이스를 여러 부분으로 나누어 병렬 처리와 고가용성을 제공하며, 데이터베이스의 성능을 선형적으로 증가시킬 수 있습니다. 클러스터링 방식에는 공유 디스크와 무공유 디스크 방식이 있으며, 각각의 장단점을 이해하는 것이 중요합니다. MySQL 클러스터는 비공유형으로 메모리 기반의 클러스터링을 지원하며, 장애 발생 시에도 지속적인 데이터 서비스를 제공합니다.<br>
<br>
1. 오픈소스인  MySQL 클러스터는 비공유형으로써 메모리 기반 데이터베이스의 클러스터링을 지원한다. <br>
: MySQL 클러스터는 비공유형 클러스터로, 각 데이터베이스 인스턴스가 자신이 관리하는 데이터 파일을 로컬 디스크에 저장합니다. 이는 노드 간 데이터 공유가 없음을 의미합니다. MySQL 클러스터는 메모리 기반으로 동작하며, 최근에는 디스크 기반 클러스터링도 지원합니다. 이러한 구조는 특정 하드웨어나 소프트웨어에 의존하지 않고 병렬 서버 구조로 확장 가능하며, 장애 발생 시에도 데이터 가용성을 높이기 위해 데이터를 다른 노드에 복제합니다.<br>
<br>
2. 데이터베이스 클러스터를 구성했을 때 성능의 특정 파티션에서 장애가 발생하면 서비스가 중단될 수도 있다. <br>
: 데이터베이스 클러스터는 고가용성을 제공하기 때문에 특정 파티션에서 장애가 발생하더라도 서비스가 중단되지 않습니다. 이는 클러스터링의 주요 장점 중 하나로, 데이터베이스의 가용성을 높여줍니다. 따라서 성능의 특정 파티션에서 장애가 발생하더라도 서비스가 중단될 가능성은 낮습니다.<br>
<br>
3. 공유 디스크 클러스터에서는 SAN(Storage Area Network)과 같은 네트워크가 없어도 데이터의 공유가 가능하다. <br>
: 공유 디스크 클러스터는 SAN과 같은 네트워크를 통해 데이터의 공유가 가능합니다. SAN은 고속 네트워크로, 여러 서버가 동일한 디스크에 접근할 수 있도록 지원합니다. 따라서 SAN과 같은 네트워크가 없으면 데이터의 공유가 불가능합니다.<br>
<br>
4. 공유 디스크의 경우 클러스터의 규모가 커질 때 디스크의 성능이 높아진다는 것이 최대 장점이다. <br>
: 공유 디스크 클러스터의 경우, 클러스터의 규모가 커질 때 디스크의 성능이 높아지는 것이 아니라, 오히려 디스크 I/O 병목 현상이 발생할 수 있습니다. 이는 여러 서버가 동일한 디스크에 접근하기 때문입니다. 따라서 디스크 성능이 높아지는 것이 최대 장점이라고 할 수 없습니다.<br>
<br>
정답은 1번입니다. MySQL 클러스터는 비공유형으로 메모리 기반 데이터베이스의 클러스터링을 지원합니다. 2번은 클러스터의 고가용성 특성상 서비스가 중단되지 않으며, 3번은 SAN과 같은 네트워크가 필요하고, 4번은 디스크 성능이 높아지는 것이 아니라 병목 현상이 발생할 수 있습니다.<br>
따라서, 정답은 '1. 오픈소스인  MySQL 클러스터는 비공유형으로써 메모리 기반 데이터베이스의 클러스터링을 지원한다.' 입니다.<br>
			</div>
			<div class="t2">
									#데이터베이스 클러스터									# MySQL 클러스터									# 비공유형									# 고가용성									# 공유 디스크							</div>
		</div>
		
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">2과목</span>
			<span class="g1">ETL(Extraction, Trans formation and Load)</span>
			<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">13.</span>
			<span class="tt1t1">
				다음 중 ETL(Extraction, Transformation and Load)에 대한 설명으로 부적절한 것은? 							</span>
		</strong>
		<span class="tt1t1">
				    </span> 
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			ETL은 다수 시스템들 간의 대용량 또는 복잡도가 높은 비즈니스 룰 적용이 필요한 데이터 교환에 활용된다.					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			ETL의 작업 단계 중 프로파일링(Profiling) 단계는 스테이징 테이블에서 데이터 특성을 식별하고 품질을 측정하는 과정이다. 					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			ETL의 기능 중 변환(Transaction)은 데이터 클렌징, 형식변환, 표준화, 통합 또는 다수의 어플리케이션에 내장된 비즈니스 룰을 적용하는 과정이다.					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			ETL은 배치 프로세스 중심이며, MPP(Massive Parallel Processing)를 지원하지 않는다.					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a13" class="b2 help" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a13" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">4</i>
			<span class="t2t1">
			ETL은 배치 프로세스 중심이며, MPP(Massive Parallel Processing)를 지원하지 않는다.			</span>
					</div>
        <br>
				<strong class="tt1">해설</strong>
		<div class="t1">
		ETL은 대규모 병렬 처리(MPP, Massive Parallel Processing)를 지원한다.				</div>
		
				
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				정답은 4번입니다.<br>
<br>
ETL은 데이터의 추출, 변환, 적재 과정을 통해 다양한 데이터 원천으로부터 데이터를 수집하고, 이를 분석 가능한 형태로 변환하여 데이터 웨어하우스나 데이터 마트에 적재하는 프로세스입니다. 이 과정은 대용량 데이터 처리와 복잡한 비즈니스 룰 적용이 필요한 경우에 특히 유용합니다. ETL은 일반적으로 배치 프로세스로 수행되며, MPP(Massive Parallel Processing)를 통해 대규모 병렬 처리를 지원하여 효율성을 높입니다.<br>
<br>
1. ETL은 다수 시스템들 간의 대용량 또는 복잡도가 높은 비즈니스 룰 적용이 필요한 데이터 교환에 활용된다. <br>
: ETL은 다양한 시스템 간의 대용량 데이터 교환과 복잡한 비즈니스 룰 적용이 필요한 경우에 사용됩니다. 이는 ETL의 주요 기능 중 하나로, 여러 데이터 원천에서 데이터를 추출하고 변환하여 통합된 형태로 적재하는 과정을 통해 이루어집니다. 예를 들어, 여러 부서에서 생성된 데이터를 하나의 데이터 웨어하우스에 통합하여 분석할 수 있습니다.<br>
<br>
2. ETL의 작업 단계 중 프로파일링(Profiling) 단계는 스테이징 테이블에서 데이터 특성을 식별하고 품질을 측정하는 과정이다. <br>
: 프로파일링 단계는 스테이징 테이블에서 데이터의 특성을 식별하고 품질을 측정하는 과정입니다. 이 단계에서는 데이터의 정확성, 일관성, 완전성을 평가하여 이후 변환 및 적재 과정에서 데이터 품질을 보장합니다. 예를 들어, 고객 데이터의 중복 여부를 확인하고, 누락된 정보를 식별하는 작업이 포함됩니다.<br>
<br>
3. ETL의 기능 중 변환(Transaction)은 데이터 클렌징, 형식변환, 표준화, 통합 또는 다수의 어플리케이션에 내장된 비즈니스 룰을 적용하는 과정이다. <br>
: 변환 단계는 데이터 클렌징, 형식 변환, 표준화, 통합 등의 작업을 포함합니다. 이 단계에서는 데이터의 일관성을 확보하고, 다양한 애플리케이션에서 사용 가능한 형태로 변환합니다. 예를 들어, 날짜 형식을 통일하거나, 여러 소스에서 수집된 데이터를 하나의 표준 형식으로 변환하는 작업이 이루어집니다.<br>
<br>
4. ETL은 배치 프로세스 중심이며, MPP(Massive Parallel Processing)를 지원하지 않는다. <br>
: ETL은 일반적으로 배치 프로세스로 수행되지만, MPP를 지원하여 대규모 병렬 처리를 통해 효율성을 높일 수 있습니다. MPP는 여러 프로세서가 동시에 작업을 수행하여 처리 속도를 향상시키는 기술로, 대용량 데이터 처리에 적합합니다. 따라서 ETL이 MPP를 지원하지 않는다는 설명은 부적절합니다.<br>
<br>
선지 4는 ETL이 MPP를 지원하지 않는다고 설명하고 있지만, 실제로 ETL은 MPP를 지원하여 대규모 병렬 처리를 통해 효율성을 높일 수 있습니다. 따라서 이 설명은 부적절합니다. 다른 선지들은 ETL의 기능과 작업 단계에 대한 올바른 설명을 제공하고 있습니다.<br>
따라서, 정답은 '4. ETL은 배치 프로세스 중심이며, MPP(Massive Parallel Processing)를 지원하지 않는다.' 입니다.<br>
			</div>
			<div class="t2">
									#ETL									# 데이터 추출									# 데이터 변환									# 데이터 적재									# MPP									# 대용량 데이터 처리							</div>
		</div>
		
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">2과목</span>
			<span class="g1">클라우드 인프라 기술</span>
			<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">14.</span>
			<span class="tt1t1">
				VMware과 관련된 메모리 가상화 기법에 대한 설명으로 가장 부적절한 것은? 							</span>
		</strong>
		<span class="tt1t1">
				    </span> 
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			VMware 하이퍼바이저의 핵심 모듈인 VMKernal은 Service Console, 디바이스 드라이버들의 메모리 영역을 제외한 나머지 전체 메모리 영역을 모두 관리하면서 가상머신에 메모리를 할당한다.					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			하나의 물리적인 머신에 여러 개의 가상머신이 운영되는 경우, 각 가상머신에 할당된 메모리 중 동일한 내용을 담고 있는 페이지는 물리적인 메모리 영역에 하나만 존재시키고 모든 가상머신이 공유하도록 하는 것을 ‘Memory Ballooning’이라고 한다.					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			주소의 중간 변환을 하드웨어적으로 돕는 과정에서 사용되는 캐시메모리를 TLB라고 한다. 					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			VMware는 하이퍼바이저 내에 Shadow Page Table을 별도로 두는데 이 테이블은 마치 연속된 빈 공간의 메모리가 실제 존재하는 것처럼 게스트 운영체제에게 매핑해주는 역할을 한다.					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a14" class="b2 help" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a14" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">2</i>
			<span class="t2t1">
			하나의 물리적인 머신에 여러 개의 가상머신이 운영되는 경우, 각 가상머신에 할당된 메모리 중 동일한 내용을 담고 있는 페이지는 물리적인 메모리 영역에 하나만 존재시키고 모든 가상머신이 공유하도록 하는 것을 ‘Memory Ballooning’이라고 한다.			</span>
					</div>
        <br>
				<strong class="tt1">해설</strong>
		<div class="t1">
		②번은 Transparent page sharing에 관한 설명이다.				</div>
		
				
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				정답은 2번입니다.<br>
<br>
VMware의 메모리 가상화 기법은 물리적 메모리 자원을 효율적으로 관리하고 가상머신 간의 메모리 사용을 최적화하는 데 중점을 둡니다. 이러한 기법에는 메모리 오버커밋, 메모리 공유, 메모리 압축 등이 포함됩니다.<br>
<br>
1. VMware 하이퍼바이저의 핵심 모듈인 VMKernal은 Service Console, 디바이스 드라이버들의 메모리 영역을 제외한 나머지 전체 메모리 영역을 모두 관리하면서 가상머신에 메모리를 할당한다.<br>
: VMKernal은 VMware 하이퍼바이저의 핵심 모듈로, 가상머신에 메모리를 할당하는 역할을 합니다. Service Console과 디바이스 드라이버의 메모리 영역을 제외한 나머지 메모리를 관리합니다.<br>
<br>
2. 하나의 물리적인 머신에 여러 개의 가상머신이 운영되는 경우, 각 가상머신에 할당된 메모리 중 동일한 내용을 담고 있는 페이지는 물리적인 메모리 영역에 하나만 존재시키고 모든 가상머신이 공유하도록 하는 것을 ‘Memory Ballooning’이라고 한다.<br>
: Memory Ballooning은 가상머신의 메모리 사용량을 조절하기 위한 기법으로, 메모리 공유와는 다른 개념입니다. 메모리 공유는 동일한 내용을 가진 페이지를 공유하는 것이며, Memory Ballooning은 가상머신의 메모리 사용량을 줄이기 위해 사용됩니다.<br>
<br>
3. 주소의 중간 변환을 하드웨어적으로 돕는 과정에서 사용되는 캐시메모리를 TLB라고 한다.<br>
: TLB는 Translation Lookaside Buffer의 약자로, 주소 변환을 빠르게 하기 위해 사용되는 캐시 메모리입니다. 이는 하드웨어적으로 주소 변환을 돕는 역할을 합니다.<br>
<br>
4. VMware는 하이퍼바이저 내에 Shadow Page Table을 별도로 두는데 이 테이블은 마치 연속된 빈 공간의 메모리가 실제 존재하는 것처럼 게스트 운영체제에게 매핑해주는 역할을 한다.<br>
: Shadow Page Table은 하이퍼바이저가 게스트 운영체제에게 실제 물리적 메모리와는 다른 연속된 메모리 공간을 제공하기 위해 사용하는 구조입니다. 이는 가상 메모리와 물리적 메모리 간의 매핑을 관리합니다.<br>
<br>
<br>
Memory Ballooning은 가상머신의 메모리 사용량을 조절하기 위한 기법으로, 동일한 내용을 가진 페이지를 공유하는 것과는 다릅니다. 따라서 2번 선택지가 부적절한 설명입니다. 다른 선택지들은 VMware의 메모리 가상화 기법에 대한 올바른 설명을 포함하고 있습니다.<br>
<br>
따라서, 정답은 '2. 하나의 물리적인 머신에 여러 개의 가상머신이 운영되는 경우, 각 가상머신에 할당된 메모리 중 동일한 내용을 담고 있는 페이지는 물리적인 메모리 영역에 하나만 존재시키고 모든 가상머신이 공유하도록 하는 것을 ‘Memory Ballooning’이라고 한다.' 입니다.<br>
			</div>
			<div class="t2">
									#VMware									# 메모리 가상화									# Memory Ballooning									# Shadow Page Table							</div>
		</div>
		
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">2과목</span>
			<span class="g1">분산 컴퓨팅 기술</span>
			<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">15.</span>
			<span class="tt1t1">
				다음 중 SQL on 하둡에 대한 설명으로 적절하지 않은 것은? 							</span>
		</strong>
		<span class="tt1t1">
				    </span> 
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			대부분의 SQL on 하둡 시스템들은 하둡 프레임워크의 맵리듀스를 이용하지 않고, 새로운 분산 처리 모델과 프레임워크를 기반으로 구현되어 있다. 					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			SQL on 하둡의 한 종류인 샤크(Shark)는 인메모리 기반의 대용량 데이터웨어하우스 시스템이다. 					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			SQL on 하둡 기술은 SQL을 이용하여 데이터를 분석할 수 있지만 실시간 처리는 지원하지 않는다. 					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			클라우데라 임팔라, 아파치 타조는 대표적인 상용 SQL on 하둡 솔루션이다.					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a15" class="b2 help" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a15" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">3</i>
			<span class="t2t1">
			SQL on 하둡 기술은 SQL을 이용하여 데이터를 분석할 수 있지만 실시간 처리는 지원하지 않는다. 			</span>
					</div>
        <br>
				<strong class="tt1">해설</strong>
		<div class="t1">
		SQL on 하둡은 실시간 SQL 질의 분석 기술이므로 ③번은 틀린 설명이다.				</div>
		
				
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				정답은 3번입니다.<br>
<br>
SQL on 하둡은 하둡 환경에서 SQL을 사용하여 데이터를 처리하고 분석할 수 있는 기술입니다. 이 기술은 하둡의 대용량 데이터 처리 능력을 SQL의 편리함과 결합하여 사용자가 익숙한 SQL 문법으로 데이터를 다룰 수 있게 합니다.<br>
<br>
1. 대부분의 SQL on 하둡 시스템들은 하둡 프레임워크의 맵리듀스를 이용하지 않고, 새로운 분산 처리 모델과 프레임워크를 기반으로 구현되어 있다.<br>
: 대부분의 SQL on 하둡 시스템들은 하둡의 맵리듀스 대신 새로운 분산 처리 모델을 사용하여 성능을 향상시킵니다. 이는 맵리듀스의 단점을 보완하기 위한 것입니다.<br>
<br>
2. SQL on 하둡의 한 종류인 샤크(Shark)는 인메모리 기반의 대용량 데이터웨어하우스 시스템이다.<br>
: 샤크(Shark)는 인메모리 기반으로 설계되어 빠른 데이터 처리와 분석을 가능하게 하는 시스템입니다. 이는 대용량 데이터웨어하우스 시스템의 특성을 가지고 있습니다.<br>
<br>
3. SQL on 하둡 기술은 SQL을 이용하여 데이터를 분석할 수 있지만 실시간 처리는 지원하지 않는다.<br>
: SQL on 하둡 기술은 실시간 데이터 처리를 지원하는 시스템도 존재합니다. 예를 들어, 아파치 드릴이나 클라우데라 임팔라 같은 시스템은 실시간 쿼리 처리를 지원합니다.<br>
<br>
4. 클라우데라 임팔라, 아파치 타조는 대표적인 상용 SQL on 하둡 솔루션이다.<br>
: 클라우데라 임팔라와 아파치 타조는 SQL on 하둡 솔루션으로 널리 사용되고 있으며, 상용 및 오픈 소스 형태로 제공됩니다.<br>
<br>
<br>
SQL on 하둡 기술은 실시간 처리를 지원하는 시스템도 존재하기 때문에, 'SQL on 하둡 기술은 SQL을 이용하여 데이터를 분석할 수 있지만 실시간 처리는 지원하지 않는다'는 설명은 부적절합니다. 다른 선택지들은 각각의 기술적 특성과 일치합니다.<br>
<br>
따라서, 정답은 '3. SQL on 하둡 기술은 SQL을 이용하여 데이터를 분석할 수 있지만 실시간 처리는 지원하지 않는다.' 입니다.<br>
			</div>
			<div class="t2">
									#SQL on 하둡									# 맵리듀스									# 인메모리									# 실시간 처리							</div>
		</div>
		
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">2과목</span>
			<span class="g1">CDC(Change Data Capture)</span>
			<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">16.</span>
			<span class="tt1t1">
				CDC(Change Data Capture)의 구현 기법에 관한 설명으로 가장 적절한 것은?							</span>
		</strong>
		<span class="tt1t1">
				    </span> 
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			Log Scanner on Database : 로그에 대한 스캐닝 및 변경 내역에 대한 해석을 통해 CDC 매커니즘을 구현하는 기법으로, 데이터베이스 스키마의 변경을 필요로 한다.					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			Status on Rows : 데이터 변경 여부에 대해 True/False의 논리값으로 표현하는 칼럼을 두는 기법으로, 레코드에 대한 변경 여부는 사람이 직접 판단할 수 없다.					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			Triggers on Tables : 데이터베이스 트리거를 활용해 사전에 등록된 다수의 대상 시스템에 변경 데이터를 배포하는 형태로 CDC를 구현하는 기법이다.					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			Time/Version/Status on Rows : 타임스탬프, 버전 넘버, 상태 값을 모두 활용하는 기법으로 정교한 쿼리 생성은 불가능할 수 있다.					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a16" class="b2 help" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a16" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">3</i>
			<span class="t2t1">
			Triggers on Tables : 데이터베이스 트리거를 활용해 사전에 등록된 다수의 대상 시스템에 변경 데이터를 배포하는 형태로 CDC를 구현하는 기법이다.			</span>
					</div>
        <br>
				<strong class="tt1">해설</strong>
		<div class="t1">
		Log Scanner on Database는 데이터베이스 스키마의 변경을 필요로 하진 않는다. ②번은 Version on Rows 기법에 대한 설명이다. Status on Rows 기법을 이용하면 레코드에 대한 변경 여부를 사람이 직접 판단할 수 있도록 유보하는 업무 규칙을 정할 수 있다. Time/Version/Status on Rows 기법은 정교한 쿼리 생성에 활용할 수 있다.				</div>
		
				
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				정답은 3번입니다.<br>
<br>
CDC(Change Data Capture)는 데이터베이스의 변경 사항을 추적하고 이를 다른 시스템에 전달하는 기술입니다. 이 기술은 데이터 일관성을 유지하고 실시간 데이터 동기화를 가능하게 합니다.<br>
<br>
1. Log Scanner on Database : 로그에 대한 스캐닝 및 변경 내역에 대한 해석을 통해 CDC 매커니즘을 구현하는 기법으로, 데이터베이스 스키마의 변경을 필요로 한다.<br>
: 로그 스캐너를 사용하여 데이터베이스의 변경 사항을 추적하는 방법은 데이터베이스의 로그 파일을 분석하여 변경 사항을 캡처합니다. 이 방법은 데이터베이스 스키마의 변경이 필요할 수 있습니다.<br>
<br>
2. Status on Rows : 데이터 변경 여부에 대해 True/False의 논리값으로 표현하는 칼럼을 두는 기법으로, 레코드에 대한 변경 여부는 사람이 직접 판단할 수 없다.<br>
: 행의 상태를 나타내는 컬럼을 추가하여 데이터 변경 여부를 추적하는 방법은 간단하지만, 사람이 직접 변경 여부를 판단하기 어렵습니다. 이는 자동화된 시스템에서 사용하기에 적합하지 않을 수 있습니다.<br>
<br>
3. Triggers on Tables : 데이터베이스 트리거를 활용해 사전에 등록된 다수의 대상 시스템에 변경 데이터를 배포하는 형태로 CDC를 구현하는 기법이다.<br>
: 데이터베이스 트리거를 사용하여 변경 사항을 캡처하고 이를 사전에 등록된 시스템에 배포하는 방법은 실시간으로 데이터를 동기화할 수 있는 장점이 있습니다. 이는 CDC 구현에 효과적입니다.<br>
<br>
4. Time/Version/Status on Rows : 타임스탬프, 버전 넘버, 상태 값을 모두 활용하는 기법으로 정교한 쿼리 생성은 불가능할 수 있다.<br>
: 타임스탬프, 버전 넘버, 상태 값을 사용하여 변경 사항을 추적하는 방법은 복잡한 쿼리를 생성하기 어려울 수 있습니다. 이는 데이터의 정확한 변경 시점을 파악하는 데 한계가 있을 수 있습니다.<br>
<br>
<br>
데이터베이스 트리거를 사용하여 변경 사항을 실시간으로 캡처하고 이를 다른 시스템에 배포하는 방법은 CDC 구현에 매우 효과적입니다. 다른 선택지들은 각각의 단점이 있어 CDC 구현에 적합하지 않을 수 있습니다. 예를 들어, 로그 스캐너는 데이터베이스 스키마의 변경이 필요하고, 상태 컬럼을 사용하는 방법은 자동화에 적합하지 않으며, 타임스탬프와 버전 넘버를 사용하는 방법은 복잡한 쿼리 생성에 한계가 있습니다.<br>
<br>
따라서, 정답은 '3. Triggers on Tables : 데이터베이스 트리거를 활용해 사전에 등록된 다수의 대상 시스템에 변경 데이터를 배포하는 형태로 CDC를 구현하는 기법이다.' 입니다.<br>
			</div>
			<div class="t2">
									#CDC									# 데이터베이스 트리거									# 로그 스캐너									# 상태 컬럼							</div>
		</div>
		
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">2과목</span>
			<span class="g1">분산 데이터 저장 기술</span>
			<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">17.</span>
			<span class="tt1t1">
				다음 중 NoSQL 솔루션 Hbase에 대한 설명으로 가장 적절한 것은?							</span>
		</strong>
		<span class="tt1t1">
				    </span> 
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			로우키에 대한 인덱싱만 지원하며 작은 데이터를 저장하는 용도로 사용하는 것은 적절하지 않다. 					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			인메모리 기반의 대용량 데이터웨어하우스 시스템이며, 하이브와 호환되기 때문에 하이브 SQL 질의와 사용자 정의 함수를 사용할 수 있다.					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			Hbase는 구글의 빅테이블(Big Table)을 본보기로 삼아 만들어졌으며, 자체적인 분산파일 시스템을 사용한다.					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			Hbase는 NoSQL 기술에 해당하며, 표준 Anal-SQL을 지원한다.					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a17" class="b2 help" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a17" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">1</i>
			<span class="t2t1">
			로우키에 대한 인덱싱만 지원하며 작은 데이터를 저장하는 용도로 사용하는 것은 적절하지 않다. 			</span>
					</div>
        <br>
				<strong class="tt1">해설</strong>
		<div class="t1">
		Hbase는 하둡 분산파일 시스템을 사용하며, SQL을 지원하지 않는다. ②번은 샤크(Shark)와 관련된 설명이다.				</div>
		
				
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				정답은 1번입니다.<br>
<br>
HBase는 NoSQL 데이터베이스로, 구글의 빅테이블을 모델로 하여 개발되었습니다. HBase는 하둡 분산 파일 시스템(HDFS)을 기반으로 하며, 대규모의 비구조화된 데이터를 실시간으로 읽고 쓸 수 있는 기능을 제공합니다. 이는 관계형 데이터베이스와 달리 수평적 확장성을 가지고 있어, 노드를 추가함으로써 용량을 쉽게 확장할 수 있습니다. HBase는 SQL을 지원하지 않으며, 로우키에 대한 인덱싱만을 지원합니다. 이러한 특성으로 인해 HBase는 대규모 데이터 처리에 적합하며, 실시간 데이터 접근이 필요한 환경에서 주로 사용됩니다.<br>
<br>
1. 로우키에 대한 인덱싱만 지원하며 작은 데이터를 저장하는 용도로 사용하는 것은 적절하지 않다. <br>
: HBase는 로우키에 대한 인덱싱만을 지원합니다. 이는 데이터의 행을 기준으로 인덱싱을 하여 빠른 검색을 가능하게 합니다. 그러나, HBase는 작은 데이터를 저장하는 데는 적합하지 않습니다. 이는 HBase가 대규모 데이터를 처리하기 위해 설계되었기 때문입니다. 따라서, 작은 데이터보다는 대규모 데이터에서 그 진가를 발휘합니다.<br>
<br>
2. 인메모리 기반의 대용량 데이터웨어하우스 시스템이며, 하이브와 호환되기 때문에 하이브 SQL 질의와 사용자 정의 함수를 사용할 수 있다. <br>
: 이 설명은 HBase가 아닌 Apache Hive에 대한 설명에 가깝습니다. Hive는 하둡과 호환되며, SQL과 유사한 HiveQL을 사용하여 데이터를 질의할 수 있습니다. HBase는 인메모리 기반이 아니며, Hive와는 다른 목적과 구조를 가지고 있습니다.<br>
<br>
3. Hbase는 구글의 빅테이블(Big Table)을 본보기로 삼아 만들어졌으며, 자체적인 분산파일 시스템을 사용한다. <br>
: HBase는 구글의 빅테이블을 본보기로 삼아 만들어졌습니다. 그러나, 자체적인 분산 파일 시스템을 사용하지 않고, 하둡의 분산 파일 시스템(HDFS)을 기반으로 합니다. 이는 HBase가 하둡 생태계의 일부로서, 하둡의 장점을 활용하기 위함입니다.<br>
<br>
4. Hbase는 NoSQL 기술에 해당하며, 표준 Anal-SQL을 지원한다. <br>
: HBase는 NoSQL 데이터베이스로, 표준 SQL을 지원하지 않습니다. 대신, HBase는 자체적인 API를 통해 데이터에 접근하고 조작합니다. 이는 HBase가 비구조화된 데이터를 처리하기 위해 설계되었기 때문입니다.<br>
<br>
선지 1은 HBase의 특성을 정확히 설명하고 있습니다. HBase는 로우키에 대한 인덱싱만을 지원하며, 대규모 데이터 처리에 적합합니다. 다른 선지들은 HBase의 특성을 잘못 설명하거나 다른 기술에 대한 설명을 포함하고 있습니다. 예를 들어, 선지 2는 Hive에 대한 설명이며, 선지 3은 HBase의 파일 시스템에 대한 잘못된 설명을 포함하고 있습니다. 선지 4는 HBase가 SQL을 지원한다고 잘못 설명하고 있습니다.<br>
따라서, 정답은 '1. 로우키에 대한 인덱싱만 지원하며 작은 데이터를 저장하는 용도로 사용하는 것은 적절하지 않다.' 입니다.<br>
			</div>
			<div class="t2">
									#HBase									# NoSQL									# 로우키 인덱싱									# 빅테이블									# HDFS							</div>
		</div>
		
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">2과목</span>
			<span class="g1">EAI(Enterprise Application Intergration)</span>
			<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">18.</span>
			<span class="tt1t1">
				다음 중 EAI(Enterprise Application Integration)에 대한 설명으로 옳지 않은 것은?							</span>
		</strong>
		<span class="tt1t1">
				    </span> 
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			EAI는 어댑터, 버스, 브로커, 트랜스포머로 구성된다.					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			Hub and Spoke 방식을 기반으로 하기 때문에 복잡한 데이터 연계 경로가 발생할 수 있다. 					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			EAI의 구현 유형 중 Mediation(Intra-Communication)은 EAI 엔진이 중개자로 동작한다. 					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			EAI를 활용하면 지역적으로 분리되어 있는 정보 시스템들 간의 데이터 동기화가 가능하게 된다.					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a18" class="b2 help" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a18" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">2</i>
			<span class="t2t1">
			Hub and Spoke 방식을 기반으로 하기 때문에 복잡한 데이터 연계 경로가 발생할 수 있다. 			</span>
					</div>
        <br>
				<strong class="tt1">해설</strong>
		<div class="t1">
		hub and spoke 방식이 아니라 point to point 방식에서 복잡한 데이터 연계 경로가 발생할 수 있다.				</div>
		
				
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				정답은 2번입니다.<br>
<br>
EAI(Enterprise Application Integration)는 기업 내 다양한 애플리케이션을 통합하여 비즈니스 프로세스를 자동화하고 실시간으로 연계할 수 있도록 하는 솔루션입니다. EAI는 주로 Hub and Spoke 아키텍처를 사용하여 데이터를 연계하며, 어댑터, 버스, 브로커, 트랜스포머와 같은 구성 요소를 통해 시스템 간의 데이터 연동을 지원합니다. 이를 통해 기업 내 또는 기업 간의 이질적인 정보 시스템들이 상호 융화되어 동작할 수 있습니다.<br>
<br>
1. EAI는 어댑터, 버스, 브로커, 트랜스포머로 구성된다. <br>
: EAI의 구성 요소는 어댑터, 버스, 브로커, 트랜스포머로 이루어져 있습니다. 어댑터는 각 정보 시스템과 EAI 허브 간의 연결성을 확보하며, 버스는 어댑터를 통해 연결된 시스템들 간의 데이터 연동 경로를 제공합니다. 브로커는 데이터 연동 규칙을 통제하고, 트랜스포머는 데이터 형식 변환을 담당합니다. 이러한 구성 요소들은 EAI의 핵심 기능을 수행하는 데 필수적입니다.<br>
<br>
2. Hub and Spoke 방식을 기반으로 하기 때문에 복잡한 데이터 연계 경로가 발생할 수 있다. <br>
: Hub and Spoke 방식은 중앙 허브를 통해 여러 스포크(노드)와 연결되는 구조입니다. 이 방식은 데이터 연계 경로를 단순화하지만, 복잡한 데이터 연계 경로가 발생할 수 있다는 설명은 잘못된 것입니다. 오히려 이 방식은 데이터 흐름을 중앙에서 관리하여 복잡성을 줄이는 데 기여합니다.<br>
<br>
3. EAI의 구현 유형 중 Mediation(Intra-Communication)은 EAI 엔진이 중개자로 동작한다. <br>
: Mediation(Intra-Communication)은 EAI 엔진이 중개자로 동작하는 구현 유형입니다. 이 방식에서는 EAI 엔진이 특정 정보 시스템 내의 데이터 생성, 갱신, 트랜잭션 완료 등의 이벤트를 식별하고, 이를 미리 약속된 다른 시스템에 전달합니다. 이는 Publish/Subscribe 모델로도 불리며, 데이터의 실시간 연동을 가능하게 합니다.<br>
<br>
4. EAI를 활용하면 지역적으로 분리되어 있는 정보 시스템들 간의 데이터 동기화가 가능하게 된다. <br>
: EAI는 지역적으로 분리된 정보 시스템들 간의 데이터 동기화를 가능하게 합니다. 이를 통해 기업 내 다양한 시스템들이 실시간으로 데이터를 공유하고, 비즈니스 프로세스를 자동화할 수 있습니다. 이는 EAI의 주요 장점 중 하나로, 기업의 정보 시스템을 통합하여 효율성을 높이는 데 기여합니다.<br>
<br>
선지 2는 Hub and Spoke 방식에 대한 잘못된 설명을 포함하고 있습니다. 이 방식은 중앙 허브를 통해 데이터 흐름을 관리하여 복잡성을 줄이는 데 기여합니다. 다른 선지들은 EAI의 구성 요소와 기능에 대한 정확한 설명을 제공하고 있습니다.<br>
따라서, 정답은 '2. Hub and Spoke 방식을 기반으로 하기 때문에 복잡한 데이터 연계 경로가 발생할 수 있다.' 입니다.<br>
			</div>
			<div class="t2">
									#EAI									# Hub and Spoke									# 어댑터									# 버스									# 브로커									# 트랜스포머									# Mediation									# 데이터 동기화							</div>
		</div>
		
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">2과목</span>
			<span class="g1">분산 컴퓨팅 기술</span>
			<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">19.</span>
			<span class="tt1t1">
				맵리듀스(MapReduce)가 실행되는 절차로 적절한 것은?							</span>
		</strong>
		<span class="tt1t1">
				    </span> 
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			Input - Split - Shuffle &amp; Sort - Map - Combine - Reduce - Output 					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			Input - Split - Map - Shuffle &amp; Sort - Combine - Reduce - Output 					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			Input - Map - Sprit - Combine - Shuffle &amp; Sort - Reduce - Output 					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			Input - Split - Map - Combine - Shuffle &amp; Sort - Reduce - Output					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a19" class="b2 help" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a19" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">4</i>
			<span class="t2t1">
			Input - Split - Map - Combine - Shuffle &amp; Sort - Reduce - Output			</span>
					</div>
        <br>
				<strong class="tt1">해설</strong>
		<div class="t1">
		맵리듀스의 절차는 input – split – map – combine – shuffle &amp; sort – reduce – output이다.				</div>
		
				
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				맵리듀스(MapReduce)는 대규모 데이터 처리를 위한 프로그래밍 모델로, 다음과 같은 절차로 실행됩니다<br>
<br>
- Input: 원본 데이터가 입력됩니다.<br>
- Split: 입력된 데이터가 여러 조각으로 나뉩니다.<br>
- Map: 각 조각에 대해 맵 함수가 실행되어 키-값 쌍을 생성합니다.<br>
- Combine: 맵 함수의 출력이 로컬에서 결합되어 중간 결과를 만듭니다.<br>
- Shuffle &amp; Sort: 중간 결과가 키를 기준으로 정렬되고, 같은 키를 가진 값들이 그룹화됩니다.<br>
- Reduce: 그룹화된 값을 기반으로 리듀스 함수가 실행되어 최종 결과를 생성합니다.<br>
- Output: 최종 결과가 출력됩니다.<br>
<br>
따라서, 4번의 절차가 맵리듀스의 실행 절차와 일치합니다.<br>
			</div>
			<div class="t2">
									# 맵리듀스									# 맵리듀스 실행 절차							</div>
		</div>
		
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">2과목</span>
			<span class="g1">분산 데이터 저장 기술</span>
			<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">20.</span>
			<span class="tt1t1">
				분산 응용 프로그램을 지원하는 플랫폼인 하둡(Hadoop)에 대한 설명으로 적절하지 않은 것은 무엇인가?							</span>
		</strong>
		<span class="tt1t1">
				    </span> 
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			맵리듀스 작업 수행 중에 특정 태스크에서 장애가 발생하면 시스템이 스스로 장애를 감지하여 전체 작업을 중단한 다음 문제를 해결한 후 다시 작업 수행을 시작한다.					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			맵리듀스는 맵과 리듀스라는 두개의 함수만 구현하면서 동작하는 시스템이다.					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			하둡을 구축할 때 이론적으로 클러스터를 구성할 수 있는 서버의 대수에는 제한이 없지만, 통상적으로 최소 클러스터 대수는 5대정도이다.					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			하둡은 비공유 분산 아키텍처를 사용하기 때문에 서버를 추가하여 클러스터를 확장하면 연산 기능과 저장 기능이 서버의 대수에 비례하여 증가한다.					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a20" class="b2 help" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a20" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">1</i>
			<span class="t2t1">
			맵리듀스 작업 수행 중에 특정 태스크에서 장애가 발생하면 시스템이 스스로 장애를 감지하여 전체 작업을 중단한 다음 문제를 해결한 후 다시 작업 수행을 시작한다.			</span>
					</div>
        <br>
				<strong class="tt1">해설</strong>
		<div class="t1">
		맵리듀스 작업을 수행하다가 특정 태스크에서 장애가 생기면 시스템이 자동으로 감지해 장애가 발생한 특정 태스크만 다른 서버에서 재실행을 할 수 있다. 				</div>
		
				
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				정답은 1번입니다.<br>
<br>
하둡(Hadoop)은 대량의 데이터를 분산 처리하기 위한 오픈 소스 프레임워크로, 주로 맵리듀스(MapReduce) 프로그래밍 모델을 사용하여 데이터를 처리합니다. 하둡은 비공유 분산 아키텍처를 사용하여 확장성이 뛰어나며, 장애 발생 시에도 데이터 손실을 최소화하고 작업을 지속할 수 있는 기능을 제공합니다.<br>
<br>
1. 맵리듀스 작업 수행 중에 특정 태스크에서 장애가 발생하면 시스템이 스스로 장애를 감지하여 전체 작업을 중단한 다음 문제를 해결한 후 다시 작업 수행을 시작한다.<br>
: 맵리듀스 작업 중 특정 태스크에서 장애가 발생하면 하둡은 해당 태스크만 재시작하여 전체 작업을 중단하지 않고 계속 진행할 수 있습니다. 이는 하둡의 장애 복구 메커니즘의 핵심입니다.<br>
<br>
2. 맵리듀스는 맵과 리듀스라는 두개의 함수만 구현하면서 동작하는 시스템이다.<br>
: 맵리듀스는 맵과 리듀스라는 두 개의 함수로 구성된 프로그래밍 모델로, 데이터를 분산 처리하는 데 사용됩니다. 이 두 함수는 데이터의 분할과 집계를 담당합니다.<br>
<br>
3. 하둡을 구축할 때 이론적으로 클러스터를 구성할 수 있는 서버의 대수에는 제한이 없지만, 통상적으로 최소 클러스터 대수는 5대정도이다.<br>
: 하둡 클러스터는 이론적으로 서버의 대수에 제한이 없지만, 실제로는 최소한의 안정성을 위해 5대 이상의 서버로 구성하는 것이 일반적입니다.<br>
<br>
4. 하둡은 비공유 분산 아키텍처를 사용하기 때문에 서버를 추가하여 클러스터를 확장하면 연산 기능과 저장 기능이 서버의 대수에 비례하여 증가한다.<br>
: 하둡은 비공유 분산 아키텍처를 사용하여 서버를 추가하면 연산 및 저장 기능이 서버의 대수에 비례하여 증가합니다. 이는 하둡의 확장성의 장점 중 하나입니다.<br>
<br>
<br>
선지 1은 하둡의 장애 복구 메커니즘에 대한 잘못된 설명입니다. 하둡은 전체 작업을 중단하지 않고, 장애가 발생한 특정 태스크만 재시작하여 작업을 지속할 수 있습니다. 다른 선택지들은 하둡의 특성과 기능을 올바르게 설명하고 있습니다.<br>
<br>
따라서, 정답은 '1. 맵리듀스 작업 수행 중에 특정 태스크에서 장애가 발생하면 시스템이 스스로 장애를 감지하여 전체 작업을 중단한 다음 문제를 해결한 후 다시 작업 수행을 시작한다.' 입니다.<br>
			</div>
			<div class="t2">
									#하둡									# 맵리듀스									# 비공유 분산 아키텍처									# 장애 복구							</div>
		</div>
		
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">3과목</span>
			<span class="g1">분석 기획 방향성 도출</span>
			<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">21.</span>
			<span class="tt1t1">
				분석은 분석의 대상(What) 및 분석의 방법(How)에 따라 4가지 분석 주제로 나눌 수 있다. 분석의 대상이 명확하게 무엇인지 모르면서 기존 분석 방법으로 새로운 분석을 수행하는 방식의 분석 주제 유형은 무엇인가?							</span>
		</strong>
		<span class="tt1t1">
				    </span> 
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			최적화(Optimization) 					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			통찰(Insight) 					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			솔루션(Solution) 					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			발견(Discovery)					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a21" class="b2 help" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a21" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">2</i>
			<span class="t2t1">
			통찰(Insight) 			</span>
					</div>
        <br>
				<strong class="tt1">해설</strong>
		<div class="t1">
		분석 대상이 명확하게 무엇인지 모르면서 기존 분석 방법으로 새로운 분석을 수행하는 방식은 통찰(Insight)을 도출해 문제의 도출 및 해결에 기여한다.				</div>
		
				
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				정답은 4번입니다.<br>
<br>
문제는 분석의 대상과 방법에 따라 나뉘는 분석 주제 유형을 묻고 있습니다. 특히, 분석의 대상이 명확하지 않은 상태에서 기존의 분석 방법을 사용하여 새로운 분석을 수행하는 경우를 찾는 것입니다.<br>
<br>
1. 최적화(Optimization)<br>
: 최적화는 주어진 조건 하에서 가장 효율적인 결과를 찾는 방법으로, 분석의 대상이 명확해야 합니다.<br>
<br>
2. 통찰(Insight)<br>
: 통찰은 데이터를 통해 새로운 이해나 인식을 얻는 과정으로, 분석의 대상이 명확하지 않을 수 있습니다.<br>
<br>
3. 솔루션(Solution)<br>
: 솔루션은 문제 해결을 위한 구체적인 방법을 제시하는 것으로, 분석의 대상이 명확해야 합니다.<br>
<br>
4. 발견(Discovery)<br>
: 발견은 기존에 알지 못했던 패턴이나 정보를 찾아내는 과정으로, 분석의 대상이 명확하지 않을 때도 가능합니다.<br>
<br>
<br>
발견은 분석의 대상이 명확하지 않은 상태에서도 기존의 분석 방법을 통해 새로운 정보를 찾아내는 과정입니다. 다른 선택지들은 분석의 대상이 명확해야 하거나, 문제 해결을 위한 구체적인 방법을 제시하는 경우에 해당합니다.<br>
<br>
따라서, 정답은 '4. 발견(Discovery)' 입니다.<br>
			</div>
			<div class="t2">
									#분석									# 대상									# 방법									# 발견							</div>
		</div>
		
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">3과목</span>
			<span class="g1">분석 기획 방향성 도출</span>
			<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">22.</span>
			<span class="tt1t1">
				다음 중 성공적인 분석을 위해서 고려해야 할 요소로 가장 부적절한 것은?							</span>
		</strong>
		<span class="tt1t1">
				    </span> 
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			분석 데이터에 대한 고려					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			활용 가능한 유즈케이스 탐색 					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			원점에서 솔루션 탐색					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			장애 요소에 대한 사전 계획 수립					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a22" class="b2 help" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a22" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">3</i>
			<span class="t2t1">
			원점에서 솔루션 탐색			</span>
					</div>
        <br>
				<strong class="tt1">해설</strong>
		<div class="t1">
		분석 기획 시 고려사항은 분석의 기본이 되는 데이터에 대한 고려, 활용 가능한 유즈케이스 탐색, 분석 수행에 있어 발생하는 장애요소들에 대한 사전 계획 수립이다.				</div>
		
				
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				정답은 3번입니다.<br>
<br>
문제는 성공적인 분석을 위해 고려해야 할 요소 중 부적절한 것을 찾는 것입니다. 분석의 성공은 데이터의 품질, 활용 가능한 유즈케이스, 장애 요소에 대한 사전 계획 등이 중요합니다.<br>
<br>
1. 분석 데이터에 대한 고려<br>
: 데이터의 품질과 적절성은 분석의 기초입니다. 데이터가 정확하고 신뢰할 수 있어야 분석 결과도 신뢰할 수 있습니다. 따라서 데이터에 대한 고려는 필수적입니다.<br>
<br>
2. 활용 가능한 유즈케이스 탐색<br>
: 유즈케이스를 탐색하는 것은 분석의 방향성을 설정하는 데 중요합니다. 다양한 활용 사례를 통해 분석의 목표를 명확히 하고, 실질적인 가치를 창출할 수 있습니다.<br>
<br>
3. 원점에서 솔루션 탐색<br>
: 문제를 해결하기 위해 원점에서 솔루션을 탐색하는 것은 비효율적일 수 있습니다. 기존의 데이터와 사례를 활용하여 문제를 해결하는 것이 더 효과적입니다.<br>
<br>
4. 장애 요소에 대한 사전 계획 수립<br>
: 장애 요소를 사전에 계획하는 것은 분석 과정에서 발생할 수 있는 문제를 미리 대비하는 데 중요합니다. 이를 통해 분석의 연속성을 유지할 수 있습니다.<br>
<br>
<br>
원점에서 솔루션을 탐색하는 것은 기존의 데이터와 사례를 활용하지 않는 비효율적인 접근입니다. 다른 선택지들은 모두 분석의 성공을 위해 필수적인 요소들입니다.<br>
<br>
따라서, 정답은 '3. 원점에서 솔루션 탐색' 입니다.<br>
			</div>
			<div class="t2">
									#데이터 품질									# 유즈케이스									# 솔루션 탐색									# 장애 요소							</div>
		</div>
		
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">3과목</span>
			<span class="g1">분석 과제 발굴</span>
			<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">23.</span>
			<span class="tt1t1">
				분석 과제를 발굴하기 위한 접근법 중 하향식 접근방법의 과정이 아닌 것은?							</span>
		</strong>
		<span class="tt1t1">
				    </span> 
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			기업의 내/외부 환경을 포괄하는 비즈니스 모델과 외부 사례를 기반으로 문제를 탐색한다. 					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			기업내부의 과거 데이터를 무조건 결합 및 활용한다. 					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			식별된 비즈니스 문제를 데이터의 문제로 변화하여 정의한다. 					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			도출된 분석 문제나 가설에 대한 대안을 과제화하기 위해 타당성을 평가한다.					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a23" class="b2 help" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a23" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">2</i>
			<span class="t2t1">
			기업내부의 과거 데이터를 무조건 결합 및 활용한다. 			</span>
					</div>
        <br>
				<strong class="tt1">해설</strong>
		<div class="t1">
		하향식 접근법은 문제탐색 → 문제정의 → 해결방안 탐색 → 타당성 검토로 전개된다.				</div>
		
				
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				정답은 2번입니다.<br>
<br>
하향식 접근방법은 주로 전체적인 비즈니스 모델과 외부 환경을 분석하여 문제를 정의하고, 이를 데이터 문제로 변환하여 해결책을 찾는 방식입니다. 이 과정은 일반적으로 비즈니스 문제를 식별하고, 이를 데이터 문제로 변환한 후, 해결책을 찾기 위한 대안을 평가하는 순서로 진행됩니다.<br>
<br>
1. 기업의 내/외부 환경을 포괄하는 비즈니스 모델과 외부 사례를 기반으로 문제를 탐색한다.<br>
: 비즈니스 모델과 외부 사례를 기반으로 문제를 탐색하는 것은 하향식 접근방법의 핵심입니다. 이는 기업의 내외부 환경을 포괄적으로 분석하여 문제를 정의하는 과정입니다.<br>
<br>
2. 기업내부의 과거 데이터를 무조건 결합 및 활용한다.<br>
: 과거 데이터를 무조건 결합 및 활용하는 것은 하향식 접근방법과는 거리가 멉니다. 하향식 접근은 데이터보다는 비즈니스 문제의 정의와 해결책 모색에 중점을 둡니다.<br>
<br>
3. 식별된 비즈니스 문제를 데이터의 문제로 변화하여 정의한다.<br>
: 비즈니스 문제를 데이터 문제로 변환하는 것은 하향식 접근방법의 중요한 단계입니다. 이는 비즈니스 문제를 구체적인 데이터 분석 문제로 정의하여 해결책을 찾기 위한 기초를 마련합니다.<br>
<br>
4. 도출된 분석 문제나 가설에 대한 대안을 과제화하기 위해 타당성을 평가한다.<br>
: 도출된 분석 문제나 가설에 대한 대안을 평가하는 것은 하향식 접근방법의 마지막 단계 중 하나입니다. 이는 문제 해결을 위한 다양한 대안을 검토하고 타당성을 평가하는 과정입니다.<br>
<br>
<br>
하향식 접근방법은 비즈니스 문제를 정의하고 이를 데이터 문제로 변환하여 해결책을 찾는 과정입니다. 2번은 과거 데이터를 무조건 결합 및 활용하는 것으로, 이는 하향식 접근방법의 과정과 맞지 않습니다. 다른 선택지들은 모두 하향식 접근방법의 과정에 해당합니다.<br>
<br>
따라서, 정답은 '2. 기업내부의 과거 데이터를 무조건 결합 및 활용한다.' 입니다.<br>
			</div>
			<div class="t2">
									#하향식 접근방법									# 비즈니스 모델									# 데이터 문제									# 문제 정의							</div>
		</div>
		
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">3과목</span>
			<span class="g1">분석 과제 발굴</span>
			<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">24.</span>
			<span class="tt1t1">
				분석기회 발굴의 범위 중 시장니즈 탐색 관점에서 고객니즈의 변화에 해당하는 것이 아닌 것은?							</span>
		</strong>
		<span class="tt1t1">
				    </span> 
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			고객					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			채널					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			영향자들					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			대체제					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a24" class="b2 help" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a24" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">4</i>
			<span class="t2t1">
			대체제			</span>
					</div>
        <br>
				<strong class="tt1">해설</strong>
		<div class="t1">
		시장 니즈 탐색 관점에서 고객 니즈의 변화는 고객, 채널, 영향자들에 의해 진행된다.				</div>
		
				
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				정답은 4번입니다.<br>
<br>
시장 니즈 탐색은 고객의 변화하는 요구를 이해하고, 이를 통해 새로운 분석 기회를 발굴하는 과정입니다. 이 과정에서는 고객과 직접적으로 상호작용하는 채널, 고객의 구매 결정에 영향을 미치는 영향자들, 그리고 고객의 구매 동향을 분석하여 제품과 서비스의 개선 기회를 도출합니다. 이러한 분석은 고객의 니즈 변화에 민감하게 반응하여 시장에서의 경쟁력을 유지하는 데 필수적입니다.<br>
<br>
1. 고객 <br>
: 고객은 시장 니즈 탐색의 핵심 요소로, 그들의 구매 동향과 컨텍스트를 깊이 이해하는 것이 중요합니다. 고객의 변화하는 요구를 파악함으로써 제품과 서비스의 개선 기회를 도출할 수 있습니다. 따라서 고객은 시장 니즈 탐색 관점에서 필수적인 요소입니다.<br>
<br>
2. 채널 <br>
: 채널은 고객과의 접점을 형성하는 경로로, 고객에게 제품과 서비스를 전달하는 다양한 경로를 포함합니다. 이러한 채널을 통해 고객의 니즈를 파악하고, 각 채널별로 분석 기회를 확대할 수 있습니다. 따라서 채널은 시장 니즈 탐색에 중요한 역할을 합니다.<br>
<br>
3. 영향자들 <br>
: 영향자들은 고객의 구매 결정에 영향을 미치는 사람들로, 이들의 의견과 행동은 고객의 니즈 변화에 큰 영향을 미칩니다. 따라서 영향자들을 분석하는 것은 시장 니즈 탐색에서 중요한 부분을 차지합니다.<br>
<br>
4. 대체제 <br>
: 대체제는 고객이 선택할 수 있는 다른 제품이나 서비스로, 시장에서의 경쟁 요소로 작용합니다. 그러나 대체제는 고객의 니즈 변화보다는 경쟁 환경의 변화와 관련이 있습니다. 따라서 대체제는 시장 니즈 탐색 관점에서 고객 니즈의 변화에 직접적으로 해당하지 않습니다.<br>
<br>
고객, 채널, 영향자들은 모두 고객의 니즈 변화와 직접적으로 관련이 있으며, 시장 니즈 탐색의 중요한 요소입니다. 반면, 대체제는 고객이 선택할 수 있는 다른 옵션으로, 고객의 니즈 변화보다는 경쟁 환경의 변화와 관련이 있습니다. 따라서 대체제는 고객 니즈의 변화에 해당하지 않습니다.<br>
따라서, 정답은 '4. 대체제' 입니다.<br>
			</div>
			<div class="t2">
									#시장 니즈 탐색									# 고객									# 채널									# 영향자									# 대체제									# 고객 니즈 변화							</div>
		</div>
		
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">3과목</span>
			<span class="g1">분석 과제 발굴</span>
			<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">25.</span>
			<span class="tt1t1">
				거시적 관점의 메가 트랜드에서 현재의 조직과 해당 산업에 폭넓게 영향을 미치는 사회·경제적 요인인 STEEP로 폭넓게 기회를 탐색한다. STEEP 중 Political(정치영역)의 주요관점에 대한 설명으로 가장 적절한 것은? 							</span>
		</strong>
		<span class="tt1t1">
				    </span> 
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			주요 정책방향, 정세, 지정학적 동향 등 거시적인 흐름을 토대로 분석기회를 도출한다. 					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			산업과 경제 구조 변화 동향에 따른 시장의 흐름을 파악하여 분석기회를 도출한다. 					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			정부, 사회단체, 시민사회의 환경에 관한 관심과 규제 동향을 파악하여 분석기회를 도출한다. 					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			과학, 기술, 의학 등 최신 기술의 등장 및 변화를 파악하여 분석기회를 도출한다.					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a25" class="b2 help" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a25" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">1</i>
			<span class="t2t1">
			주요 정책방향, 정세, 지정학적 동향 등 거시적인 흐름을 토대로 분석기회를 도출한다. 			</span>
					</div>
        <br>
				<strong class="tt1">해설</strong>
		<div class="t1">
		Political(정치영역)은 주요 정책 방향, 정세, 지정학적 동향 등의 거시적인 흐름을 토대로 분석 기회를 도출한다.				</div>
		
				
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				정답은 1번입니다.<br>
<br>
문제는 STEEP 분석에서 Political(정치영역)의 주요 관점을 이해하는 것입니다. STEEP는 사회적, 기술적, 경제적, 환경적, 정치적 요인을 분석하여 기회를 탐색하는 방법론입니다. 정치적 요인은 정책, 법률, 정부의 안정성 등과 관련이 있습니다.<br>
<br>
1. 주요 정책방향, 정세, 지정학적 동향 등 거시적인 흐름을 토대로 분석기회를 도출한다.<br>
: 정치적 요인은 국가의 정책 방향, 국제 정세, 지정학적 동향 등을 포함합니다. 이러한 요소들은 기업의 전략적 결정에 큰 영향을 미치며, 거시적인 흐름을 이해하는 것이 중요합니다.<br>
<br>
2. 산업과 경제 구조 변화 동향에 따른 시장의 흐름을 파악하여 분석기회를 도출한다.<br>
: 경제적 요인은 산업 구조의 변화와 경제 성장률, 인플레이션 등과 관련이 있습니다. 이는 시장의 흐름을 이해하는 데 중요하지만, 정치적 요인과는 구분됩니다.<br>
<br>
3. 정부, 사회단체, 시민사회의 환경에 관한 관심과 규제 동향을 파악하여 분석기회를 도출한다.<br>
: 환경적 요인은 정부와 사회단체의 환경 보호 정책, 규제 동향 등을 포함합니다. 이는 환경적 측면에서의 분석 기회를 제공하지만, 정치적 요인과는 다릅니다.<br>
<br>
4. 과학, 기술, 의학 등 최신 기술의 등장 및 변화를 파악하여 분석기회를 도출한다.<br>
: 기술적 요인은 과학과 기술의 발전, 혁신 등을 포함합니다. 이는 기술적 측면에서의 분석 기회를 제공하며, 정치적 요인과는 구분됩니다.<br>
<br>
<br>
정치적 요인은 국가의 정책 방향과 국제 정세, 지정학적 동향을 포함하여 거시적인 흐름을 분석하는 데 중점을 둡니다. 이는 기업의 전략적 결정에 직접적인 영향을 미치기 때문에 중요합니다. 다른 선택지들은 각각 경제적, 환경적, 기술적 요인에 해당하며, 정치적 요인과는 구분됩니다.<br>
<br>
따라서, 정답은 '1. 주요 정책방향, 정세, 지정학적 동향 등 거시적인 흐름을 토대로 분석기회를 도출한다.' 입니다.<br>
			</div>
			<div class="t2">
									#STEEP									# Political									# 정책 방향									# 지정학적 동향							</div>
		</div>
		
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">3과목</span>
			<span class="g1">분석 프로젝트 관리 방안</span>
			<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">26.</span>
			<span class="tt1t1">
				분석 프로젝트 영역별 주요 관리 항목이 아닌 것은? 							</span>
		</strong>
		<span class="tt1t1">
				    </span> 
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			품질					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			시간					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			가격					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			자원					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a26" class="b2 help" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a26" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">3</i>
			<span class="t2t1">
			가격			</span>
					</div>
        <br>
				<strong class="tt1">해설</strong>
		<div class="t1">
		분석 프로젝트 영역별 주요 관리 항목에는 범위, 시간, 원가, 품질, 통합, 조달, 자원, 리스트, 의사소통, 이해관계자 등이 있다.				</div>
		
				
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				정답은 3번입니다.<br>
<br>
분석 프로젝트에서 관리해야 할 주요 항목은 프로젝트의 성공적인 완료를 위해 필수적인 요소들입니다. 일반적으로 프로젝트 관리의 주요 영역은 품질, 시간, 비용, 자원 등이 포함됩니다. 품질은 프로젝트 결과물의 적합성과 완성도를 의미하며, 시간은 프로젝트 완료까지의 일정 관리, 자원은 프로젝트 수행에 필요한 인력과 물자 등을 포함합니다. 비용은 프로젝트 수행에 필요한 예산 관리입니다. 이러한 요소들은 프로젝트의 목표를 달성하기 위해 서로 유기적으로 관리되어야 합니다.<br>
<br>
1. 품질 <br>
: 품질은 프로젝트의 결과물이 요구사항을 얼마나 충족하는지를 평가하는 기준입니다. 이는 프로젝트의 성공 여부를 결정짓는 중요한 요소로, 품질 관리가 제대로 이루어지지 않으면 프로젝트의 최종 산출물이 기대에 미치지 못할 수 있습니다.<br>
<br>
2. 시간 <br>
: 시간은 프로젝트의 일정 관리와 관련이 있습니다. 프로젝트는 정해진 기간 내에 완료되어야 하며, 이를 위해 각 단계별로 세부 일정이 계획되고 관리됩니다. 시간 관리는 프로젝트의 효율성을 높이고, 지연을 방지하는 데 필수적입니다.<br>
<br>
3. 가격 <br>
: 가격은 일반적으로 프로젝트 관리의 주요 항목으로 간주되지 않습니다. 대신, 비용이 주요 관리 항목으로 포함됩니다. 비용은 프로젝트 수행에 필요한 모든 자원의 금전적 가치를 포함하며, 예산 내에서 프로젝트를 완료하기 위해 철저히 관리되어야 합니다.<br>
<br>
4. 자원 <br>
: 자원은 프로젝트 수행에 필요한 인력, 장비, 재료 등을 의미합니다. 자원 관리는 이러한 요소들이 적시에 적절한 양으로 제공되도록 하여 프로젝트가 원활히 진행되도록 합니다.<br>
<br>
정답은 '가격'입니다. 프로젝트 관리의 주요 항목으로는 품질, 시간, 비용, 자원이 포함되며, 가격은 일반적으로 이러한 항목에 포함되지 않습니다. 가격은 시장에서의 제품이나 서비스의 판매 금액을 의미하며, 프로젝트 관리에서는 비용 관리가 더 적절한 용어입니다. 따라서 가격은 분석 프로젝트의 주요 관리 항목이 아닙니다.<br>
따라서, 정답은 '3. 가격' 입니다.<br>
			</div>
			<div class="t2">
									#프로젝트 관리									# 품질									# 시간									# 비용									# 자원									# 가격							</div>
		</div>
		
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">3과목</span>
			<span class="g1">분석 거버넌스 체계 수립</span>
			<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">27.</span>
			<span class="tt1t1">
				다음 중 분석 과제 관리 프로세스에 대한 설명으로 가장 적절하지 않은 것은 무엇인가?							</span>
		</strong>
		<span class="tt1t1">
				    </span> 
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			분석 아이디어 발굴, 분석과제 후보제안, 분석과제 확정 프로세스는 과제 발굴 단계에 속해있다.					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			분석과제로 확정되면 분석 과제를 풀(pool)로 관리한다.					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			분석과제 중에 발생된 시사점과 분석 결과물은 풀(pool)로 관리하고 공유된다.					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			과제 수행 단계에서는 팀 구성, 분 석과제 식별, 분 석과제 진행관리, 결과 공유 프로세스가 있다.					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a27" class="b2 help" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a27" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">2</i>
			<span class="t2t1">
			분석과제로 확정되면 분석 과제를 풀(pool)로 관리한다.			</span>
					</div>
        <br>
				<strong class="tt1">해설</strong>
		<div class="t1">
		분석과제 중에 발생된 시사점과 분석 결과물이 풀(pool)로 관리하고 공유된다. 확정된 분석과제는 풀(pool)로 관리하지 않는다.				</div>
		
				
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				정답은 3번입니다.<br>
<br>
분석 과제 관리 프로세스는 분석 아이디어의 발굴부터 과제의 수행 및 결과 공유까지의 전 과정을 포함합니다. 이 과정은 크게 과제 발굴 단계와 과제 수행 단계로 나뉘며, 각 단계는 특정한 프로세스를 포함하고 있습니다.<br>
<br>
1. 분석 아이디어 발굴, 분석과제 후보제안, 분석과제 확정 프로세스는 과제 발굴 단계에 속해있다.<br>
: 과제 발굴 단계는 분석 아이디어를 발굴하고, 이를 바탕으로 분석과제 후보를 제안하며, 최종적으로 분석과제를 확정하는 과정을 포함합니다.<br>
<br>
2. 분석과제로 확정되면 분석 과제를 풀(pool)로 관리한다.<br>
: 분석과제로 확정된 과제는 풀(pool)로 관리되며, 이는 여러 과제들을 체계적으로 관리하기 위한 방법입니다.<br>
<br>
3. 분석과제 중에 발생된 시사점과 분석 결과물은 풀(pool)로 관리하고 공유된다.<br>
: 분석과제의 시사점과 결과물은 풀(pool)로 관리되지만, 이는 공유의 목적보다는 관리의 목적이 더 큽니다. 따라서 공유보다는 관리에 중점을 두고 있습니다.<br>
<br>
4. 과제 수행 단계에서는 팀 구성, 분 석과제 식별, 분 석과제 진행관리, 결과 공유 프로세스가 있다.<br>
: 과제 수행 단계에서는 팀을 구성하고, 분석과제를 식별하며, 과제의 진행을 관리하고, 결과를 공유하는 프로세스가 포함됩니다.<br>
<br>
<br>
3번 선지는 분석과제의 시사점과 결과물이 풀(pool)로 관리되고 공유된다고 설명하고 있습니다. 그러나 실제로는 이러한 요소들은 주로 관리의 목적으로 풀(pool)로 관리되며, 공유는 부차적인 목적입니다. 따라서 3번 선지가 가장 적절하지 않은 설명입니다.<br>
<br>
따라서, 정답은 '3. 분석과제 중에 발생된 시사점과 분석 결과물은 풀(pool)로 관리하고 공유된다.' 입니다.<br>
			</div>
			<div class="t2">
									#분석 과제 관리									# 과제 발굴									# 과제 수행									# 풀 관리							</div>
		</div>
		
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">3과목</span>
			<span class="g1">분석 거버넌스 체계 수립</span>
			<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">28.</span>
			<span class="tt1t1">
				다음 데이터 분석 조직의 유형 중 별도의 분석 조직이 없고 해당 업무부서에서 분석을 수행하는 방식에 해당하는 것은?							</span>
		</strong>
		<span class="tt1t1">
				    </span> 
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			기능형					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			분산형					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			복합형					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			집중형					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a28" class="b2 help" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a28" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">1</i>
			<span class="t2t1">
			기능형			</span>
					</div>
        <br>
				<strong class="tt1">해설</strong>
		<div class="t1">
		기능구조는 별도 분석조직이 없고 해당 업무부서에서 분석을 수행한다. 전사적 핵심분석이 어려우며, 부서 현황 및 실적 통계 등 과거 실적에 국한된 분석 수행 가능성이 높다.				</div>
		
				
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				분산형 조직은 별도의 분석 조직을 두지 않고 각 업무 부서에서 자체적으로 분석을 수행하는 방식을 의미합니다. 이 방식은 각 부서가 독립적으로 분석 작업을 수행하므로, 부서 별로 특화된 분석이 가능하지만, 분석의 일관성과 효율성 측면에서는 도전 과제가 있을 수 있습니다. 반면, 기능형 조직은 분석 기능을 특정 부서에 집중시키는 방식이고, 복합형 조직은 기능형과 분산형의 장점을 결합한 형태입니다. 집중형 조직은 분석 기능을 중앙 집중화하여 관리하는 방식입니다.<br>
<br>
			</div>
			<div class="t2">
									# 데이터 분석 조직									# 분산형									# 기능형									# 복합형									# 집중형							</div>
		</div>
		
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">3과목</span>
			<span class="g1">분석 방법론</span>
			<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">29.</span>
			<span class="tt1t1">
				다음 중 CRISP-DM 방법론의 모델링 단계에서 수행하는 테스크(task)로 적절하지 않은 것은 무엇인가?							</span>
		</strong>
		<span class="tt1t1">
				    </span> 
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			모델 테스트 계획 설계 					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			모델 적용성 평가 					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			모델 평가					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			모델링 기법 선택					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a29" class="b2 help" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a29" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">2</i>
			<span class="t2t1">
			모델 적용성 평가 			</span>
					</div>
        <br>
				<strong class="tt1">해설</strong>
		<div class="t1">
		CRISP-DM 방법론의 모델링 단계에서의 수행 업무는 모델링 기법 선택, 모델 테스트 계획 설계, 모델 작성, 모델 평가가 있다.				</div>
		
				
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				정답은 2번입니다.<br>
<br>
CRISP-DM 방법론은 데이터 마이닝 프로젝트를 위한 표준 프로세스 모델로, 비즈니스 이해, 데이터 이해, 데이터 준비, 모델링, 평가, 배포의 6단계로 구성됩니다. 모델링 단계에서는 데이터 마이닝 기법을 적용하여 모델을 생성하고, 이를 테스트하고 평가하는 작업이 포함됩니다.<br>
<br>
1. 모델 테스트 계획 설계<br>
: 모델링 단계에서는 모델을 생성한 후, 이를 테스트하기 위한 계획을 설계하는 것이 중요합니다. 이는 모델의 성능을 검증하고, 실제 적용 가능성을 평가하기 위한 필수적인 과정입니다.<br>
<br>
2. 모델 적용성 평가<br>
: 모델 적용성 평가는 모델링 단계가 아닌 평가 단계에서 수행됩니다. 평가 단계에서는 모델이 비즈니스 목표에 부합하는지, 그리고 실제 환경에서 적용 가능한지를 판단합니다.<br>
<br>
3. 모델 평가<br>
: 모델 평가는 모델링 단계의 일부로, 생성된 모델의 성능을 측정하고, 이를 통해 모델의 유효성을 판단하는 과정입니다.<br>
<br>
4. 모델링 기법 선택<br>
: 모델링 기법 선택은 모델링 단계의 초기 작업으로, 데이터의 특성과 문제의 유형에 맞는 적절한 기법을 선택하는 것이 중요합니다.<br>
<br>
<br>
모델 적용성 평가는 CRISP-DM의 평가 단계에서 수행되는 작업입니다. 모델링 단계에서는 주로 모델을 생성하고, 이를 테스트하고 평가하는 작업이 이루어집니다. 따라서 모델 적용성 평가가 모델링 단계에서 수행하는 테스크로 적절하지 않습니다.<br>
<br>
따라서, 정답은 '2. 모델 적용성 평가' 입니다.<br>
			</div>
			<div class="t2">
									#CRISP-DM									# 모델링 단계									# 모델 테스트									# 모델 평가							</div>
		</div>
		
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">3과목</span>
			<span class="g1">마스터 플랜 수립 프레임 워크</span>
			<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">30.</span>
			<span class="tt1t1">
				빅데이터의 특성을 고려한 분석 ROI 요소에서 비용 요소로 적절하지 않은 것은 무엇인가?							</span>
		</strong>
		<span class="tt1t1">
				    </span> 
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			Volume					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			Variety					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			Velocity					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			Value					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a30" class="b2 help" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a30" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">4</i>
			<span class="t2t1">
			Value			</span>
					</div>
        <br>
				<strong class="tt1">해설</strong>
		<div class="t1">
		분석 ROI 요소에서 비용 요소는 Volume, Variety, Velocity이다.				</div>
		
				
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				정답은 4번입니다.<br>
<br>
빅데이터의 특성은 흔히 3V로 불리는 Volume(크기), Variety(다양성), Velocity(속도)와 더불어 Value(가치)를 포함하여 4V로 설명됩니다. 이 중 3V는 데이터의 양, 종류, 처리 속도에 중점을 두고 있으며, 이는 데이터를 저장하고 처리하기 위한 기술적, 물리적 투자가 필요하다는 점에서 투자비용 요소로 간주됩니다. 반면, Value는 데이터를 통해 창출되는 비즈니스 효과를 의미하며, 이는 투자에 대한 수익(Return) 요소로 분류됩니다. 따라서 빅데이터의 특성을 분석할 때, 3V는 주로 비용과 관련이 있고, Value는 수익과 관련이 있다는 점을 이해하는 것이 중요합니다.<br>
<br>
1. Volume <br>
: Volume은 데이터의 양과 규모를 의미합니다. 대량의 데이터를 저장하고 처리하기 위해서는 새로운 기술과 인프라에 대한 투자가 필요합니다. 따라서 Volume은 빅데이터 분석에서 투자비용 요소로 간주됩니다.<br>
<br>
2. Variety <br>
: Variety는 데이터의 다양성을 나타내며, 다양한 형태와 종류의 데이터를 수집하고 처리하기 위해서는 다양한 기술과 시스템이 필요합니다. 이러한 이유로 Variety는 투자비용 요소로 분류됩니다.<br>
<br>
3. Velocity <br>
: Velocity는 데이터가 생성되고 처리되는 속도를 의미합니다. 빠른 데이터 처리와 분석을 위해서는 고속의 처리 기술과 시스템이 필요하며, 이는 추가적인 투자를 요구합니다. 따라서 Velocity는 투자비용 요소에 해당합니다.<br>
<br>
4. Value <br>
: Value는 데이터를 통해 얻을 수 있는 비즈니스 가치를 의미합니다. 이는 데이터를 활용하여 새로운 가치를 창출하고, 비즈니스 효과를 극대화하는 데 중점을 두고 있습니다. 따라서 Value는 투자비용이 아닌 수익(Return) 요소로 분류됩니다.<br>
<br>
Volume, Variety, Velocity는 모두 데이터를 저장하고 처리하기 위한 기술적, 물리적 투자가 필요하다는 점에서 투자비용 요소로 간주됩니다. 반면, Value는 데이터를 통해 창출되는 비즈니스 효과를 의미하며, 이는 투자에 대한 수익(Return) 요소로 분류됩니다. 따라서 비용 요소로 적절하지 않은 것은 Value입니다.<br>
따라서, 정답은 '4. Value' 입니다.<br>
			</div>
			<div class="t2">
									#빅데이터									# 3V									# 4V									# 투자비용									# 비즈니스 효과									# ROI							</div>
		</div>
		
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">4과목</span>
			<span class="g1">데이터 마이닝 개요</span>
			<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">31.</span>
			<span class="tt1t1">
				모형을 개발하여 운영상황에서 실제 테스트를 할 때 모형 개발 데이터를 통해서는 높은 적중률을 보이지만 테스트 데이터에서는 적중률이 떨어져 적중률을 유지하지 못하는 것을 무엇이라고 하는가? 							</span>
		</strong>
		<span class="tt1t1">
				    </span> 
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			일반화					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			과대적합					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			미적합					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			과소평가					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a31" class="b2 help" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a31" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">2</i>
			<span class="t2t1">
			과대적합			</span>
					</div>
        <br>
				<strong class="tt1">해설</strong>
		<div class="t1">
		모형을 개발하기 위해서는 학습 데이터와 테스트 데이터로 구분을 해서 학습 데이터로 모델을 개발하고 테스트 데이터로 모델의 적중률을 확인한다. 학습 데이터를 너무 과대하게 학습한 경우, 과대 적합의 문제가 발생하여 테스트 데이터의 적중률은 떨어지고 일반화하기 힘들어 진다. 				</div>
		
				
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				정답은 2번입니다.<br>
<br>
머신러닝 모델을 개발할 때, 데이터는 보통 모델 학습에 사용되는 훈련 데이터(Training Data)와 모델의 성능을 평가하는 데 사용되는 테스트 데이터(Test Data) 또는 검증 데이터(Validation Data)로 나눕니다. 모델이 훈련 데이터를 통해서는 높은 성능을 보이지만, 실제 운영 상황이나 새로운 테스트 데이터에서는 성능이 현저히 떨어지는 현상은 모델의 일반화 능력과 관련하여 중요한 문제입니다.<br>
<br>
1. 일반화<br>
: 일반화는 모형이 새로운 데이터에 대해 잘 작동하는 능력을 의미합니다. 이는 모형이 학습 데이터에만 치우치지 않고 다양한 데이터에 대해 적절히 대응할 수 있는 능력을 나타냅니다.<br>
<br>
2. 과대적합<br>
: 과대적합은 모형이 학습 데이터에 너무 맞춰져서 새로운 데이터에 대한 예측 성능이 떨어지는 현상을 설명합니다. 이는 모형이 학습 데이터의 노이즈까지 학습하여 일반화 능력이 부족해지는 경우를 의미합니다.<br>
<br>
3. 미적합<br>
: 미적합은 모형이 학습 데이터에 대해 충분히 학습하지 못하여 예측 성능이 떨어지는 경우를 설명합니다. 이는 학습이 부족하여 데이터의 패턴을 제대로 파악하지 못한 경우입니다.<br>
<br>
4. 과소평가<br>
: 과소평가는 모형이 데이터의 중요성을 제대로 평가하지 못하여 예측 성능이 떨어지는 경우를 설명합니다. 이는 데이터의 특성을 제대로 반영하지 못한 경우를 의미합니다.<br>
<br>
<br>
문제에서 설명하는 현상은 모형이 학습 데이터에서는 높은 적중률을 보이지만, 테스트 데이터에서는 성능이 떨어지는 경우입니다. 이는 과대적합의 전형적인 예로, 모형이 학습 데이터에 너무 맞춰져 일반화 능력이 부족한 경우를 설명합니다. 다른 선택지들은 각각 일반화, 미적합, 과소평가에 대한 설명으로, 문제에서 묻는 현상과는 관련이 없습니다.<br>
<br>
따라서, 정답은 '2. 과대적합' 입니다.<br>
			</div>
			<div class="t2">
									#과대적합									# 일반화									# 미적합									# 과소평가							</div>
		</div>
		
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">4과목</span>
			<span class="g1">통계분석의 이해</span>
			<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">32.</span>
			<span class="tt1t1">
				측정대상이 갖고 있는 속성의 양을 측정하는 것으로 측정결과가 숫자로 표현되나 해당 속성이 전혀 없는 상태인 절대적인 영점이 없어 두 관측 값 사이의 비율은 별 의미가 없게 된다. 온도, 지수 등이 해당되는 이 척도는 무엇인가? 							</span>
		</strong>
		<span class="tt1t1">
				    </span> 
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			명목척도					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			순서척도					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			구간척도					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			비율척도					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a32" class="b2 help" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a32" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">3</i>
			<span class="t2t1">
			구간척도			</span>
					</div>
        <br>
				<strong class="tt1">해설</strong>
		<div class="t1">
		측정 대상이 갖고 있는 속성의 양을 측정하는 것으로 구간이나 구간사이의 간격이 의미가 있는 자료(온도, 지수)이다.				</div>
		
				
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				정답은 3번입니다.<br>
<br>
데이터를 측정하는 방법에는 여러 가지가 있으며, 측정의 특성에 따라 척도의 종류가 달라집니다. 척도는 크게 명목, 순서, 구간, 비율 척도로 나눌 수 있으며, 각 척도는 측정값에 대한 다른 수준의 정보를 제공합니다.<br>
<br>
1. 명목척도<br>
: 명목척도는 대상의 속성을 분류하는 데 사용되며, 숫자는 단순히 구분을 위한 기호로 사용됩니다. 따라서 숫자 간의 크기 비교나 산술 연산이 불가능합니다.<br>
<br>
2. 순서척도<br>
: 순서척도는 대상의 순서를 나타내지만, 순서 간의 간격이 일정하지 않기 때문에 산술 연산이 불가능합니다. 순서만을 중요시합니다.<br>
<br>
3. 구간척도<br>
: 구간척도는 측정된 값들 간의 차이를 비교할 수 있지만, 절대적인 영점이 없기 때문에 비율 계산이 의미가 없습니다. 온도와 같은 경우가 이에 해당합니다.<br>
<br>
4. 비율척도<br>
: 비율척도는 절대적인 영점이 존재하여 측정된 값들 간의 비율 계산이 가능합니다. 무게나 길이와 같은 경우가 이에 해당합니다.<br>
<br>
<br>
문제에서 설명하는 척도는 절대적인 영점이 없고, 두 관측 값 사이의 비율이 의미가 없는 척도를 의미합니다. 이는 구간척도의 특징으로, 온도와 같은 경우가 이에 해당합니다. 다른 선택지들은 각각 명목척도, 순서척도, 비율척도로, 문제의 설명과 일치하지 않습니다.<br>
<br>
따라서, 정답은 '3. 구간척도' 입니다.따라서, 정답은 '3. 구간척도' 입니다.<br>
			</div>
			<div class="t2">
									#구간척도									# 절대적 영점									# 온도									# 비율							</div>
		</div>
		
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">4과목</span>
			<span class="g1">R 기초</span>
			<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">33.</span>
			<span class="tt1t1">
				다음 중 아래의 R 코드를 수행한 결과에 대한 설명으로 옳은 것은?					
					<span class="tt1t1">
						&gt; c(2, 4, 6, 8) + c(1, 3, 5, 7, 9)					</span>
							</span>
		</strong>
		<span class="tt1t1">
				    </span> 
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			경고 메시지와 함께 결과가 출력된다.					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			4개의 숫자로 이루어진 벡터가 출력된다. 					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			9개의 숫자로 이루어진 벡터가 출력된다. 					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			에러 메시지가 출력되고, 명령 수행이 중단된다.					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a33" class="b2 help" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a33" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">1</i>
			<span class="t2t1">
			경고 메시지와 함께 결과가 출력된다.			</span>
					</div>
        <br>
				<strong class="tt1">해설</strong>
		<div class="t1">
		R 코드를 수행하면 다음과 같은 결과가 콘솔창에 출력된다.<br>
&gt; c(2,4,6,8) + c(1,3,5,7,9) <br>
[1]  3  7 11 15 11<br>
경고메시지(들): <br>
In c(2, 4, 6, 8) + c(1, 3, 5, 7, 9) : <br>
두 객체의 길이가 서로 배수관계에 있지 않습니다.				</div>
		
				
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				정답은 1번입니다.<br>
<br>
R에서 벡터 연산은 요소별로 수행됩니다. 두 벡터의 길이가 다를 경우, 짧은 벡터가 긴 벡터의 길이에 맞춰 반복됩니다. 이 과정에서 벡터의 길이가 서로 배수 관계가 아니면 경고 메시지가 발생합니다.<br>
<br>
1. 경고 메시지와 함께 결과가 출력된다.<br>
: R에서 두 벡터의 길이가 다를 때, 짧은 벡터가 긴 벡터의 길이에 맞춰 반복됩니다. 이 경우, 두 벡터의 길이가 배수 관계가 아니므로 경고 메시지가 발생합니다.<br>
<br>
2. 4개의 숫자로 이루어진 벡터가 출력된다.<br>
: 벡터의 길이가 다를 때, 짧은 벡터가 반복되어 연산이 수행되지만, 이 경우 경고 메시지가 발생합니다. 따라서 단순히 4개의 숫자로 이루어진 벡터가 출력된다는 설명은 부정확합니다.<br>
<br>
3. 9개의 숫자로 이루어진 벡터가 출력된다.<br>
: 벡터의 길이가 다를 때, 짧은 벡터가 반복되어 연산이 수행되지만, 이 경우 경고 메시지가 발생합니다. 9개의 숫자로 이루어진 벡터가 출력된다는 설명은 부정확합니다.<br>
<br>
4. 에러 메시지가 출력되고, 명령 수행이 중단된다.<br>
: R에서는 벡터의 길이가 다르더라도 연산이 중단되지 않고 경고 메시지와 함께 결과가 출력됩니다. 따라서 에러 메시지가 출력되고 명령이 중단된다는 설명은 부정확합니다.<br>
<br>
<br>
R에서 벡터 연산 시 두 벡터의 길이가 다르면 짧은 벡터가 반복되어 연산이 수행됩니다. 이때 길이가 배수 관계가 아니면 경고 메시지가 발생합니다. 따라서 경고 메시지와 함께 결과가 출력된다는 설명이 맞습니다. 다른 선택지들은 경고 메시지의 발생 여부나 출력 결과에 대한 설명이 부정확합니다.<br>
<br>
따라서, 정답은 '1. 경고 메시지와 함께 결과가 출력된다.' 입니다.<br>
			</div>
			<div class="t2">
									#R 프로그래밍									# 벡터 연산									# 경고 메시지									# 요소별 연산							</div>
		</div>
		
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">4과목</span>
			<span class="g1">통계분석의 이해</span>
			<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">34.</span>
			<span class="tt1t1">
				다음 중 모분산의 추론에 대한 설명으로 적절하지 않은 것은 무엇인가?							</span>
		</strong>
		<span class="tt1t1">
				    </span> 
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			이표본에 의한 분산비 검정은 두 표본의 분산이 동일한지를 비교하는 검정으로 검정통계량은 F분포를 따른다.					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			모분산이 추론의 대상이 되는 경우는 모집단의 변동성 또는 퍼짐의 정도에 관심이 있을 때이다.					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			모집단이 정규분포를 따르지 않더라도 중심극한 정리를 통해 정규 모집단으로부터의 모분산에 대한 검정을 유사하게 시행할 수 있다.					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			평균모집단에서 n개를 단순임의 추출한 표본의 분산은 자유도가 n-1인 t분포를 따른다.					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a34" class="b2 help" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a34" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">4</i>
			<span class="t2t1">
			평균모집단에서 n개를 단순임의 추출한 표본의 분산은 자유도가 n-1인 t분포를 따른다.			</span>
					</div>
        <br>
				<strong class="tt1">해설</strong>
		<div class="t1">
		표본의 분산은 카이제곱분포를 따른다.				</div>
		
				
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				평균모집단에서 n개를 단순임의 추출한 표본의 분산은 자유도가 ( n-1 )인 t분포를 따르지 않습니다. <br>
표본 분산은 자유도가 ( n-1 )인 카이제곱 분포를 따릅니다. t분포는 주로 평균에 대한 추론에서 사용됩니다. 따라서 4번의 설명은 부적절합니다.<br>
<br>
<br>
			</div>
			<div class="t2">
									# 모분산									# 분산비 검정									# F분포									# 중심극한 정리									# 정규분포									# 자유도									# t분포									# 카이제곱 분포									# 자유도							</div>
		</div>
		
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">4과목</span>
			<span class="g1">고급회귀분석</span>
			<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">35.</span>
			<span class="tt1t1">
				다음 다중회귀분석을 위해 사용되는 변수선택방법에 대한 설명 중 변수선택방법과 설명이 잘못 연결되어 있는 것은?							</span>
		</strong>
		<span class="tt1t1">
				    </span> 
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			전진선택법(forward selection)은 상수항만 포함된 모형에서 출발하여 설명력이 좋은 변수를 하나씩 추가하는 방법이다.					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			단계적 방법(stepwise method)은 설명력이 나쁜 변수를 제거하거나 모형에서 제외된 변수 중 모형의 설명력을 가장 잘 개선하는 변수를 추가하는 방법이다.					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			후진제거법(backward elimination)은 모든 변수가 포함된 모형에서 설명력이 나쁜 변수를 하나씩 제거하는 방법이다.					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			최적선택법(optimum selection)은 전진선택법과 후진제거법을 결합한 방법으로 회귀식이 최적의 변수를 선택하도록 하는 방법이다.					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a35" class="b2 help" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a35" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">4</i>
			<span class="t2t1">
			최적선택법(optimum selection)은 전진선택법과 후진제거법을 결합한 방법으로 회귀식이 최적의 변수를 선택하도록 하는 방법이다.			</span>
					</div>
        <br>
				<strong class="tt1">해설</strong>
		<div class="t1">
		다중회귀분석에서 변수선택법은 전진선택법, 후진제거법, 단계적 선택법이 있다.				</div>
		
				
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				정답은 4번입니다.<br>
<br>
다중회귀분석에서 변수선택방법은 모델의 설명력을 높이기 위해 중요한 변수만을 선택하는 과정입니다. 각 방법은 변수의 추가와 제거를 통해 최적의 모델을 찾는 데 사용됩니다.<br>
<br>
1. 전진선택법(forward selection)은 상수항만 포함된 모형에서 출발하여 설명력이 좋은 변수를 하나씩 추가하는 방법이다.<br>
: 전진선택법은 초기 모델에 상수항만 포함하고, 설명력이 높은 변수를 하나씩 추가하여 모델을 확장하는 방법입니다. 이 방법은 변수의 추가만을 고려합니다.<br>
<br>
2. 단계적 방법(stepwise method)은 설명력이 나쁜 변수를 제거하거나 모형에서 제외된 변수 중 모형의 설명력을 가장 잘 개선하는 변수를 추가하는 방법이다.<br>
: 단계적 방법은 변수의 추가와 제거를 모두 고려하여 모델의 설명력을 최적화합니다. 설명력이 낮은 변수는 제거하고, 설명력을 높이는 변수를 추가합니다.<br>
<br>
3. 후진제거법(backward elimination)은 모든 변수가 포함된 모형에서 설명력이 나쁜 변수를 하나씩 제거하는 방법이다.<br>
: 후진제거법은 모든 변수가 포함된 상태에서 시작하여 설명력이 낮은 변수를 하나씩 제거하는 방법입니다. 이 방법은 변수의 제거만을 고려합니다.<br>
<br>
4. 최적선택법(optimum selection)은 전진선택법과 후진제거법을 결합한 방법으로 회귀식이 최적의 변수를 선택하도록 하는 방법이다.<br>
: 최적선택법은 전진선택법과 후진제거법을 결합한 방법이 아닙니다. 최적선택법이라는 용어는 일반적으로 사용되지 않으며, 설명이 잘못되었습니다.<br>
<br>
<br>
최적선택법이라는 용어는 일반적으로 사용되지 않으며, 전진선택법과 후진제거법을 결합한 방법이라는 설명은 잘못되었습니다. 나머지 선택지는 각각의 변수선택방법에 대한 올바른 설명을 제공하고 있습니다.<br>
<br>
따라서, 정답은 '4. 최적선택법(optimum selection)은 전진선택법과 후진제거법을 결합한 방법으로 회귀식이 최적의 변수를 선택하도록 하는 방법이다.' 입니다.<br>
			</div>
			<div class="t2">
									#다중회귀분석									# 변수선택방법									# 전진선택법									# 후진제거법							</div>
		</div>
		
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">4과목</span>
			<span class="g1">데이터변경 및 요약</span>
			<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">36.</span>
			<span class="tt1t1">
				이상치를 찾는 것은 데이터 분석에서 데이터 전처리를 어떻게 할지 검정할 때 사용할 수 있다. 다음 중 상자그림을 이용하여 이상치를 판정하는 방법에 대한 설명으로 가장 부적절한 것은?							</span>
		</strong>
		<span class="tt1t1">
				    </span> 
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			IQR=Q3-Q1이라고 할 때, Q1-1.5*IQR&lt; X &lt;Q3+1.5*IQR을 벗어나는 X를 이상치라고 규정한다.					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			평균으로부터 3*표준편차 벗어나는 것들을 비정상이라 규정하고 제거한다.					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			이상치는 변수의 분포에서 벗어난 값으로 상자 그림을 통해 확인할 수 있다.					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			이상치는 분포를 왜곡할 수 있으나 실제 오류인자에 대해서는 통계적으로 실행하지 못하기 때문에 제거여부는 실무자들을 통해서 결정하는 것이 바람직하다.					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a36" class="b2 help" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a36" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">2</i>
			<span class="t2t1">
			평균으로부터 3*표준편차 벗어나는 것들을 비정상이라 규정하고 제거한다.			</span>
					</div>
        <br>
				<strong class="tt1">해설</strong>
		<div class="t1">
		이상치라고 규정한 자료는 분석에서 제외 할 수 있지만 무조건적으로 제거할 수는 없다.				</div>
		
				
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				정답은 2번입니다.<br>
<br>
상자그림은 데이터의 분포를 시각적으로 표현하며, 이상치를 판별하는 데 유용한 도구입니다. 이상치는 데이터 분석에서 중요한 요소로, 데이터의 왜곡을 방지하기 위해 적절히 처리해야 합니다.<br>
<br>
1. IQR=Q3-Q1이라고 할 때, Q1-1.5*IQR&lt; X &lt;Q3+1.5*IQR을 벗어나는 X를 이상치라고 규정한다.<br>
: 상자그림에서 IQR(Interquartile Range)을 이용하여 이상치를 판별하는 방법은 일반적으로 사용됩니다. Q1과 Q3는 각각 1사분위수와 3사분위수를 의미하며, 이 범위를 벗어나는 값은 이상치로 간주됩니다.<br>
<br>
2. 평균으로부터 3*표준편차 벗어나는 것들을 비정상이라 규정하고 제거한다.<br>
: 평균과 표준편차를 이용한 방법은 상자그림과는 다른 이상치 판별 방법입니다. 이는 정규분포를 가정할 때 사용되며, 상자그림과는 직접적인 관련이 없습니다.<br>
<br>
3. 이상치는 변수의 분포에서 벗어난 값으로 상자 그림을 통해 확인할 수 있다.<br>
: 상자그림은 데이터의 분포를 시각적으로 보여주며, 이상치를 확인하는 데 유용합니다. 이는 상자그림의 기본적인 기능 중 하나입니다.<br>
<br>
4. 이상치는 분포를 왜곡할 수 있으나 실제 오류인자에 대해서는 통계적으로 실행하지 못하기 때문에 제거여부는 실무자들을 통해서 결정하는 것이 바람직하다.<br>
: 이상치는 데이터 분석에 영향을 미칠 수 있으며, 제거 여부는 데이터의 특성과 분석 목적에 따라 결정됩니다. 이는 실무자의 판단에 따라 달라질 수 있습니다.<br>
<br>
<br>
정답은 2번입니다. 2번은 상자그림을 이용한 이상치 판정 방법이 아니라 평균과 표준편차를 이용한 방법을 설명하고 있습니다. 이는 상자그림과는 다른 방법이므로 부적절한 설명입니다. 다른 선택지들은 상자그림을 이용한 이상치 판정 방법에 대한 적절한 설명을 포함하고 있습니다.<br>
<br>
따라서, 정답은 '2. 평균으로부터 3*표준편차 벗어나는 것들을 비정상이라 규정하고 제거한다.' 입니다.<br>
			</div>
			<div class="t2">
									#상자그림									# 이상치									# IQR									# 데이터 분석							</div>
		</div>
		
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">4과목</span>
			<span class="g1">통계분석의 이해</span>
			<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">37.</span>
			<span class="tt1t1">
				통계분석에서 자료를 수집하고 그 수집된 자료로부터 어떤 정보를 얻고자 하는 경우에는 항상 수집된 자료가 특정한 확률분포를 따른다고 가정한다. 다음 중 연속형 확률분포가 아닌 것은?							</span>
		</strong>
		<span class="tt1t1">
				    </span> 
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			이항분포					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			정규분포					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			T분포					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			F분포					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a37" class="b2 help" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a37" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">1</i>
			<span class="t2t1">
			이항분포			</span>
					</div>
        <br>
				<strong class="tt1">해설</strong>
		<div class="t1">
		연속형 확률분포의 종류를 묻는 문제로 이항분포는 이산형 확률분포이고, 정규분포, T분포, F분포는 연속형 확률분포이다.				</div>
		
				
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				정답은 1번입니다.<br>
<br>
확률분포는 확률변수가 취할 수 있는 모든 값과 그 값들이 나타날 확률을 나타내는 함수이며, 크게 이산형 확률분포와 연속형 확률분포로 나눌 수 있습니다.<br>
<br>
1. 이항분포<br>
: 이항분포는 이산형 확률분포로, 성공과 실패 두 가지 결과를 가지는 실험을 여러 번 반복할 때 사용됩니다.<br>
<br>
2. 정규분포<br>
: 정규분포는 연속형 확률분포로, 자연계에서 많은 현상이 따르는 분포입니다. 평균과 표준편차로 정의됩니다.<br>
<br>
3. T분포<br>
: T분포는 정규분포와 유사한 연속형 확률분포로, 표본의 크기가 작을 때 사용됩니다.<br>
<br>
4. F분포<br>
: F분포는 두 개의 독립적인 카이제곱 분포를 나눈 연속형 확률분포로, 분산의 비교에 사용됩니다.<br>
<br>
<br>
이항분포는 성공과 실패의 두 가지 결과를 가지는 실험을 여러 번 반복할 때 사용되는 이산형 확률분포입니다. 반면, 정규분포, T분포, F분포는 모두 연속형 확률분포입니다. 따라서 이항분포가 연속형 확률분포가 아닌 유일한 선택지입니다.<br>
<br>
따라서, 정답은 '1. 이항분포' 입니다.<br>
			</div>
			<div class="t2">
									#확률분포									# 연속형									# 이산형									# 이항분포							</div>
		</div>
		
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">4과목</span>
			<span class="g1">통계분석의 이해</span>
			<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">38.</span>
			<span class="tt1t1">
				다음 표본 추출 방법에 관한 설명 중 잘못된 것을 무엇인가?							</span>
		</strong>
		<span class="tt1t1">
				    </span> 
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			표본의 크기를 결정할 때 가장 중요한 부분은 표본이 모집단을 얼마나 설명하는지에 대한 대표성의 확보이다. 					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			단순랜덤추출법은 모집단에서 샘플을 뽑을 때 각각의 샘플이 모두 동등한 확률을 가지고 무작위로 추출되는 방법이다. 					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			계통 추출법은 모집단을 군집으로 구분하고 선정된 군집의 원소를 모두 샘플로 추출하는 다단계 추출 방법이다.					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			층화 추출법은 모집단을 몇 개의 집단으로 구분하고, 각 집단의 크기와 분산을 고려하여 각 집단마다 샘플을 추출하는 방법이다.					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a38" class="b2 help" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a38" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">3</i>
			<span class="t2t1">
			계통 추출법은 모집단을 군집으로 구분하고 선정된 군집의 원소를 모두 샘플로 추출하는 다단계 추출 방법이다.			</span>
					</div>
        <br>
				<strong class="tt1">해설</strong>
		<div class="t1">
		모집단을 군집으로 구분하고 선정된 군집의 원소를 모두 샘플로 추출하는 다단계 추출 방법은 집락추출법이다.				</div>
		
				
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				정답은 3번입니다.<br>
<br>
표본 추출 방법은 모집단에서 샘플을 선택하는 다양한 방법을 설명합니다. 각 방법은 모집단의 특성과 연구 목적에 따라 다르게 적용됩니다.<br>
<br>
1. 표본의 크기를 결정할 때 가장 중요한 부분은 표본이 모집단을 얼마나 설명하는지에 대한 대표성의 확보이다.<br>
: 표본의 크기는 모집단을 얼마나 잘 대표하는지를 결정하는 중요한 요소입니다. 대표성이 확보되지 않으면 결과의 신뢰성이 떨어질 수 있습니다.<br>
<br>
2. 단순랜덤추출법은 모집단에서 샘플을 뽑을 때 각각의 샘플이 모두 동등한 확률을 가지고 무작위로 추출되는 방법이다.<br>
: 단순랜덤추출법은 모든 샘플이 동등한 확률로 선택되는 방법으로, 편향을 최소화할 수 있는 장점이 있습니다.<br>
<br>
3. 계통 추출법은 모집단을 군집으로 구분하고 선정된 군집의 원소를 모두 샘플로 추출하는 다단계 추출 방법이다.<br>
: 계통 추출법은 일정한 간격으로 샘플을 선택하는 방법입니다. 군집을 구분하고 모든 원소를 샘플로 추출하는 것은 군집 추출법에 해당합니다.<br>
<br>
4. 층화 추출법은 모집단을 몇 개의 집단으로 구분하고, 각 집단의 크기와 분산을 고려하여 각 집단마다 샘플을 추출하는 방법이다.<br>
: 층화 추출법은 모집단을 여러 집단으로 나누고, 각 집단의 특성을 고려하여 샘플을 추출하는 방법입니다. 이는 모집단의 다양한 특성을 반영할 수 있습니다.<br>
<br>
<br>
계통 추출법은 군집을 구분하고 모든 원소를 샘플로 추출하는 방법이 아닙니다. 이는 군집 추출법에 해당합니다. 따라서 3번이 잘못된 설명입니다. 다른 선택지들은 각각의 표본 추출 방법에 대한 올바른 설명을 제공합니다.<br>
<br>
따라서, 정답은 '3. 계통 추출법은 모집단을 군집으로 구분하고 선정된 군집의 원소를 모두 샘플로 추출하는 다단계 추출 방법이다.' 입니다.<br>
			</div>
			<div class="t2">
									#표본 추출									# 단순랜덤추출									# 계통 추출									# 층화 추출							</div>
		</div>
		
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">4과목</span>
			<span class="g1">통계분석의 이해</span>
			<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">39.</span>
			<span class="tt1t1">
				다음 중 비모수검정이 아닌 것을 고르시오. 							</span>
		</strong>
		<span class="tt1t1">
				    </span> 
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			윌콕슨의 순위합검증 					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			만-위트니의 U검정 					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			스피어만의 순위상관계수 					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			자기상관검증					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a39" class="b2 help" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a39" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">4</i>
			<span class="t2t1">
			자기상관검증			</span>
					</div>
        <br>
				<strong class="tt1">해설</strong>
		<div class="t1">
		자료가 추출된 모집단의 분포에 아무 제약을 가하지 않고 검정을 실시하는 방법이 비모수 검정이며 비모수 검정방법에는 부호검정, 윌콕슨의 순위합검정, 만-위트니의 U검정, 런 검정, 스피어만의 순위상관계수 등이 있다.				</div>
		
				
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				정답은 4번입니다.<br>
<br>
비모수 검정은 데이터가 특정 분포를 따른다는 가정 없이 수행되는 통계적 검정 방법입니다. 이는 주로 데이터가 정규분포를 따르지 않거나, 표본 크기가 작을 때 사용됩니다. <br>
<br>
1. 윌콕슨의 순위합검증 <br>
: 윌콕슨의 순위합 검정은 비모수 검정의 일종으로, 두 독립된 집단 간의 차이를 비교할 때 사용됩니다. 이는 데이터가 정규분포를 따르지 않는 경우에도 사용할 수 있으며, 순위를 기반으로 하여 두 집단의 중앙값 차이를 검정합니다. 따라서 비모수 검정에 해당합니다.<br>
<br>
2. 만-위트니의 U검정 <br>
: 만-위트니의 U검정은 두 독립된 집단의 차이를 비교하는 비모수 검정 방법입니다. 이는 윌콕슨의 순위합 검정과 유사하며, 데이터가 정규분포를 따르지 않는 경우에도 적용 가능합니다. 순위를 사용하여 두 집단 간의 차이를 평가하므로 비모수 검정에 속합니다.<br>
<br>
3. 스피어만의 순위상관계수 <br>
: 스피어만의 순위상관계수는 두 변수 간의 상관관계를 측정하는 비모수적 방법입니다. 이는 서열척도인 두 변수의 순위를 기반으로 상관관계를 분석하며, 데이터가 정규분포를 따르지 않아도 사용할 수 있습니다. 따라서 비모수 검정에 해당합니다.<br>
<br>
4. 자기상관검증 <br>
: 자기상관검증은 시계열 데이터에서 관측치 간의 상관관계를 분석하는 방법으로, 주로 모수적 접근을 통해 수행됩니다. 이는 데이터의 시간적 순서에 따른 상관성을 평가하며, 비모수 검정이 아닌 모수적 검정에 가깝습니다.<br>
<br>
자기상관검증은 시계열 데이터의 자기상관을 분석하는 방법으로, 주로 모수적 접근을 통해 수행되기 때문에 비모수 검정에 해당하지 않습니다. 반면, 윌콕슨의 순위합 검정, 만-위트니의 U검정, 스피어만의 순위상관계수는 모두 비모수 검정에 해당합니다.<br>
<br>
따라서, 정답은 '4. 자기상관검증' 입니다.<br>
			</div>
			<div class="t2">
									#비모수 검정									# 윌콕슨									# 만-위트니									# 스피어만									# 자기상관									# 모수 검정							</div>
		</div>
		
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">4과목</span>
			<span class="g1">회귀분석</span>
			<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">40.</span>
			<span class="tt1t1">
				두 변량 X, Y의 상관분석에 관한 내용이다. 설명이 옳지 않은 것은?							</span>
		</strong>
		<span class="tt1t1">
				    </span> 
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			등간척도로 측정된 두 변수간의 상관관계는 피어슨 상관계수(Pearson correlation)를 통해 확인할 수 있다. 					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			상관계수가 0이면 두 변량 X, Y사이에 선형관계가 없다. 					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			서열척도로 측정된 두 변수간의 상관관계는 스피어만 상관계수(Spearman correlation)를 통해 확인할 수 있다.					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			R에서 상관계수를 구하기 위해서는 rcor( )함수를 사용하면 되고 type인자를 통해 피어슨과 스피어만 상관계수를 선택할 수 있다.					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a40" class="b2 help" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a40" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">4</i>
			<span class="t2t1">
			R에서 상관계수를 구하기 위해서는 rcor( )함수를 사용하면 되고 type인자를 통해 피어슨과 스피어만 상관계수를 선택할 수 있다.			</span>
					</div>
        <br>
				<strong class="tt1">해설</strong>
		<div class="t1">
		R에서 상관계수를 구하기 위해서는 rcor( )함수가 아닌 cor( )함수 또는 rcorr( )함수를 사용하여야 한다. rcorr( )함수를 사용하면 type인자를 통해 피어슨과 스피어만 상관계수를 선택할 수 있다. 				</div>
		
				
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				정답은 4번입니다.<br>
<br>
상관분석은 두 변수 간의 관계를 분석하는 방법으로, 변수의 측정 척도에 따라 적절한 상관계수를 선택해야 합니다. 피어슨 상관계수는 등간척도나 비율척도로 측정된 변수에 적합하며, 스피어만 상관계수는 서열척도로 측정된 변수에 적합합니다. 상관계수가 0이라는 것은 두 변수 간에 선형관계가 없음을 의미합니다.<br>
<br>
1. 등간척도로 측정된 두 변수간의 상관관계는 피어슨 상관계수(Pearson correlation)를 통해 확인할 수 있다.<br>
: 피어슨 상관계수는 등간척도나 비율척도로 측정된 두 변수 간의 선형적 관계를 측정하는 데 사용됩니다. 이는 두 변수 간의 공분산을 표준화한 값으로, -1에서 1 사이의 값을 가집니다.<br>
<br>
2. 상관계수가 0이면 두 변량 X, Y사이에 선형관계가 없다.<br>
: 상관계수가 0이라는 것은 두 변수 간에 선형관계가 없다는 것을 의미합니다. 그러나 이는 비선형 관계가 없다는 것을 의미하지는 않으며, 두 변수 간에 다른 형태의 관계가 존재할 수 있습니다.<br>
<br>
3. 서열척도로 측정된 두 변수간의 상관관계는 스피어만 상관계수(Spearman correlation)를 통해 확인할 수 있다.<br>
: 스피어만 상관계수는 서열척도로 측정된 두 변수 간의 관계를 측정하는 데 사용됩니다. 이는 두 변수의 순위를 기반으로 계산되며, 비선형 관계도 탐지할 수 있습니다.<br>
<br>
4. R에서 상관계수를 구하기 위해서는 rcor( )함수를 사용하면 되고 type인자를 통해 피어슨과 스피어만 상관계수를 선택할 수 있다.<br>
: R에서 상관계수를 계산할 때 사용하는 함수는 cor()입니다. 이 함수는 type 인자를 통해 피어슨, 스피어만, 켄달의 세 가지 상관계수를 선택할 수 있습니다. rcor() 함수는 존재하지 않습니다.<br>
<br>
<br>
R에서 상관계수를 계산할 때 사용하는 함수는 cor()이며, rcor() 함수는 존재하지 않습니다. 따라서 이 선택지가 틀렸습니다. 다른 선택지들은 각각 피어슨 상관계수와 스피어만 상관계수의 정의 및 상관계수의 의미에 대해 올바르게 설명하고 있습니다.<br>
<br>
따라서, 정답은 '4. R에서 상관계수를 구하기 위해서는 rcor( )함수를 사용하면 되고 type인자를 통해 피어슨과 스피어만 상관계수를 선택할 수 있다.' 입니다.<br>
			</div>
			<div class="t2">
									#상관분석									# 피어슨 상관계수									# 스피어만 상관계수									# R 프로그래밍							</div>
		</div>
		
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">4과목</span>
			<span class="g1">고급회귀분석</span>
			<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">41.</span>
			<span class="tt1t1">
				다음 중 단순회귀분석에서 나온 결정계수(R²)에 대한 설명으로 옳지 않은 것은?							</span>
		</strong>
		<span class="tt1t1">
				    </span> 
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			총제곱의 합 중 설명된 제곱의 합의 비율을 뜻한다. 					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			종속변수에 미치는 영향이 적은 독립변수가 추가된다면 결정계수는 변하지 않는다. 					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			R²의 값이 클수록 회귀선으로 실제 관찰치를 예측하는데 정확성이 높아진다. 					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			독립변수와 종속변수 간의 표본 상관계수 r의 제곱값과 같다.					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a41" class="b2 help" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a41" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">2</i>
			<span class="t2t1">
			종속변수에 미치는 영향이 적은 독립변수가 추가된다면 결정계수는 변하지 않는다. 			</span>
					</div>
        <br>
				<strong class="tt1">해설</strong>
		<div class="t1">
		종속변수에 미치는 영향이 적더라도 독립변수가 추가되면 결정계수는 변한다.				</div>
		
				
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				정답은 2번입니다.<br>
<br>
단순회귀분석에서 결정계수(R²)는 회귀모형의 설명력을 나타내는 지표로, 독립변수가 종속변수를 얼마나 잘 설명하는지를 나타냅니다. R² 값은 0과 1 사이의 값을 가지며, 1에 가까울수록 회귀모형이 데이터를 잘 설명한다는 의미입니다.<br>
<br>
1. 총제곱의 합 중 설명된 제곱의 합의 비율을 뜻한다.<br>
: 결정계수는 총 변동 중 회귀모형에 의해 설명되는 변동의 비율을 나타냅니다. 이는 회귀모형이 종속변수의 변동을 얼마나 잘 설명하는지를 보여줍니다.<br>
<br>
2. 종속변수에 미치는 영향이 적은 독립변수가 추가된다면 결정계수는 변하지 않는다.<br>
: 결정계수는 독립변수가 추가되면 일반적으로 증가하거나 변하지 않지만, 설명력이 없는 변수가 추가되면 조정된 결정계수는 감소할 수 있습니다. 따라서 단순히 독립변수가 추가된다고 해서 결정계수가 변하지 않는 것은 아닙니다.<br>
<br>
3. R²의 값이 클수록 회귀선으로 실제 관찰치를 예측하는데 정확성이 높아진다.<br>
: 결정계수가 클수록 회귀모형이 데이터를 잘 설명한다는 의미이며, 이는 회귀선을 통해 실제 관찰치를 예측하는 정확성이 높아진다는 것을 의미합니다.<br>
<br>
4. 독립변수와 종속변수 간의 표본 상관계수 r의 제곱값과 같다.<br>
: 단순회귀분석에서 결정계수는 독립변수와 종속변수 간의 상관계수의 제곱으로 계산됩니다. 이는 두 변수 간의 선형 관계의 강도를 나타냅니다.<br>
<br>
<br>
결정계수는 독립변수가 추가되면 일반적으로 증가하거나 변하지 않지만, 설명력이 없는 변수가 추가되면 조정된 결정계수는 감소할 수 있습니다. 따라서 단순히 독립변수가 추가된다고 해서 결정계수가 변하지 않는 것은 아닙니다. 다른 선택지들은 결정계수의 정의와 특성을 올바르게 설명하고 있습니다.<br>
<br>
따라서, 정답은 '2. 종속변수에 미치는 영향이 적은 독립변수가 추가된다면 결정계수는 변하지 않는다.' 입니다.<br>
			</div>
			<div class="t2">
									#결정계수									# 회귀모형									# 설명력									# 상관계수							</div>
		</div>
		
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">4과목</span>
			<span class="g1">시계열분석</span>
			<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">42.</span>
			<span class="tt1t1">
				다음 시계열 분석의 기초가 되는 개념인 정상성(stationarity)의 특징에 관한 설명이다. 설명이 옳지 않은 것은?							</span>
		</strong>
		<span class="tt1t1">
				    </span> 
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			평균이 일정하다. 즉 모든 시점에 대한 일정한 평균을 가진다. 					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			시계열 분석에서 비정상 시계열 자료는 시계열 분석을 할 수 없다. 					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			분산도 시점에 의존하지 않는다. 					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			공분산은 단지 시차에만 의존하고 실제 어느 시점 t,s에는 의존하지 않는다.					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a42" class="b2 help" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a42" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">2</i>
			<span class="t2t1">
			시계열 분석에서 비정상 시계열 자료는 시계열 분석을 할 수 없다. 			</span>
					</div>
        <br>
				<strong class="tt1">해설</strong>
		<div class="t1">
		시계열 자료는 대부분이 비정상 자료이며 이런 경우 비정상 자료를 정상성 조건을 만족시켜 정성 시계열로 만든 후 시계열 분석을 실시한다. 				</div>
		
				
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				정답은 2번입니다.<br>
<br>
정상성(stationarity)은 시계열 분석에서 중요한 개념으로, 시계열 데이터의 통계적 특성이 시간에 따라 변하지 않는 것을 의미합니다. 이는 시계열 모델링의 기본 가정 중 하나로, 정상성을 만족하지 않는 데이터는 분석 전에 변환이 필요합니다.<br>
<br>
1. 평균이 일정하다. 즉 모든 시점에 대한 일정한 평균을 가진다. <br>
: 정상성의 첫 번째 조건은 평균이 일정하다는 것입니다. 이는 시계열 데이터의 평균이 시간에 따라 변하지 않고 일정하게 유지된다는 것을 의미합니다. 이러한 특성은 시계열 데이터가 시간에 따라 예측 가능하게 만들어 줍니다.<br>
<br>
2. 시계열 분석에서 비정상 시계열 자료는 시계열 분석을 할 수 없다. <br>
: 비정상 시계열은 정상성의 조건을 만족하지 않는 시계열을 의미합니다. 비정상 시계열도 분석이 가능하지만, 직접적인 시계열 분석을 위해서는 정상화 과정이 필요합니다. 차분이나 변환을 통해 비정상 시계열을 정상 시계열로 변환하여 분석할 수 있습니다. 따라서 비정상 시계열도 분석이 가능하므로 이 설명은 옳지 않습니다.<br>
<br>
3. 분산도 시점에 의존하지 않는다. <br>
: 정상성의 두 번째 조건은 분산이 일정하다는 것입니다. 이는 시계열 데이터의 분산이 시간에 따라 변하지 않고 일정하게 유지된다는 것을 의미합니다. 분산이 일정하면 데이터의 변동성이 시간에 따라 일정하게 유지되어 예측이 용이합니다.<br>
<br>
4. 공분산은 단지 시차에만 의존하고 실제 어느 시점 t,s에는 의존하지 않는다. <br>
: 정상성의 세 번째 조건은 공분산이 시차에만 의존한다는 것입니다. 이는 시계열 데이터의 공분산이 특정 시점이 아닌 시차에만 의존하여 일정하게 유지된다는 것을 의미합니다. 이는 데이터의 상관관계가 시간에 따라 변하지 않음을 보장합니다.<br>
<br>
정상성의 조건은 평균, 분산, 공분산이 시간에 따라 일정하게 유지되는 것입니다. 선지 1, 3, 4는 이러한 정상성의 조건을 정확히 설명하고 있습니다. 그러나 선지 2는 비정상 시계열도 정상화 과정을 통해 분석이 가능하다는 점에서 옳지 않습니다. 비정상 시계열은 차분이나 변환을 통해 정상 시계열로 변환하여 분석할 수 있기 때문에, 비정상 시계열이 시계열 분석을 할 수 없다는 설명은 틀렸습니다.<br>
<br>
따라서, 정답은 '2. 시계열 분석에서 비정상 시계열 자료는 시계열 분석을 할 수 없다.' 입니다.<br>
			</div>
			<div class="t2">
									#정상성									# 평균 일정									# 분산 일정									# 공분산									# 비정상 시계열									# 차분									# 변환							</div>
		</div>
		
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">4과목</span>
			<span class="g1">시계열분석</span>
			<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">43.</span>
			<span class="tt1t1">
				시계열에 관한 설명 중 틀린 것은?							</span>
		</strong>
		<span class="tt1t1">
				    </span> 
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			대부분의 시계열은 비정상 자료이다. 그러므로 비정상 자료를 정상성 조건에 만족시켜 정상 시계열로 만든 후 시계열 분석을 한다. 					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			시계열이 정상 시계열인지 비정상 시계열인지 판단하기 위해 폭발적인 추세를 보이거나 시간에 따라 분산이 변화하는지 관찰해야 한다. 					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			비정상 시계열은 정상 시계열로 변경하고자 할때 변환과 차분의 방법을 사용한다.					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			일반적으로 평균이 일정하지 않은 비정상 시계열은 변환을 통해, 분산이 일정하지 않은 비정상 시계열은 차분을 통해 정상 시계열로 바꾼다.					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a43" class="b2 help" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a43" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">4</i>
			<span class="t2t1">
			일반적으로 평균이 일정하지 않은 비정상 시계열은 변환을 통해, 분산이 일정하지 않은 비정상 시계열은 차분을 통해 정상 시계열로 바꾼다.			</span>
					</div>
        <br>
				<strong class="tt1">해설</strong>
		<div class="t1">
		일반적으로 평균이 일정하지 않은 비정상 시계열은 차분을 통해, 분산이 일정하지 않은 비정상 시계열은 변환을 통해 정상 시계열로 바꾼다. 				</div>
		
				
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				정답은 4번입니다.<br>
<br>
시계열 분석은 데이터가 시간의 흐름에 따라 어떻게 변하는지를 분석하는 방법입니다. 정상 시계열은 평균과 분산이 시간에 따라 일정한 특성을 가지며, 비정상 시계열은 이러한 특성을 가지지 않습니다. 비정상 시계열을 정상 시계열로 변환하는 것은 시계열 분석의 중요한 과정입니다.<br>
<br>
1. 대부분의 시계열은 비정상 자료이다. 그러므로 비정상 자료를 정상성 조건에 만족시켜 정상 시계열로 만든 후 시계열 분석을 한다.<br>
: 대부분의 시계열 데이터는 비정상적입니다. 비정상 시계열은 평균이나 분산이 시간에 따라 변할 수 있으며, 이를 정상 시계열로 변환하여 분석하는 것이 일반적입니다.<br>
<br>
2. 시계열이 정상 시계열인지 비정상 시계열인지 판단하기 위해 폭발적인 추세를 보이거나 시간에 따라 분산이 변화하는지 관찰해야 한다.<br>
: 정상 시계열과 비정상 시계열을 구분하는 방법 중 하나는 시간에 따른 평균과 분산의 변화를 관찰하는 것입니다. 폭발적인 추세나 분산의 변화는 비정상 시계열의 특징입니다.<br>
<br>
3. 비정상 시계열은 정상 시계열로 변경하고자 할때 변환과 차분의 방법을 사용한다.<br>
: 비정상 시계열을 정상 시계열로 변환하기 위해서는 변환과 차분을 사용하는 것이 일반적입니다. 변환은 데이터의 분포를 변경하고, 차분은 데이터의 추세를 제거하는 데 사용됩니다.<br>
<br>
4. 일반적으로 평균이 일정하지 않은 비정상 시계열은 변환을 통해, 분산이 일정하지 않은 비정상 시계열은 차분을 통해 정상 시계열로 바꾼다.<br>
: 평균이 일정하지 않은 시계열은 차분을 통해 추세를 제거하고, 분산이 일정하지 않은 시계열은 변환을 통해 분산을 안정화시킵니다. 따라서 이 설명은 틀렸습니다.<br>
<br>
<br>
평균이 일정하지 않은 경우에는 차분을 통해 추세를 제거하고, 분산이 일정하지 않은 경우에는 변환을 통해 분산을 안정화시켜야 합니다. <br>
<br>
따라서, 정답은 '4. 일반적으로 평균이 일정하지 않은 비정상 시계열은 변환을 통해, 분산이 일정하지 않은 비정상 시계열은 차분을 통해 정상 시계열로 바꾼다.' 입니다.<br>
			</div>
			<div class="t2">
									#시계열									# 정상 시계열									# 비정상 시계열									# 변환									# 차분							</div>
		</div>
		
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">4과목</span>
			<span class="g1">고급회귀분석</span>
			<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">44.</span>
			<span class="tt1t1">
				아래의 잔차도를 보고 회귀분석의 가정 중 어떤 가정이 위배되었다고 판단할 수 있는가?							</span>
		</strong>
		<span class="tt1t1">
						<a href="exam1view1img1.php?img=c888497c-5132-65d7-502a-f21b0cc2a7d3.jpg" target="_blank" rel="noopener" title="새 창" class="p1">
				<img src="/data/img/question/c888497c-5132-65d7-502a-f21b0cc2a7d3.jpg" alt="문제에 포함된 이미지">
			</a>
				    </span> 
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			비상관성 					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			등분산성 					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			선형성 					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			독립성					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a44" class="b2 help" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a44" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">2</i>
			<span class="t2t1">
			등분산성 			</span>
					</div>
        <br>
				<strong class="tt1">해설</strong>
		<div class="t1">
		회귀분석의 가정은 선형성, 등분산성, 독립성, 비상관성, 정규성이 있다. 아래의 그림은 회귀모형이 등분산성을 위배했다고 판단할 수 있다.				</div>
		
				
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				1. 비상관성 (Independence)<br>
잔차가 시간에 따라 독립적으로 분포해야 한다는 가정입니다. 이 문제는 주어진 잔차도의 패턴과는 직접적인 관련이 없습니다.<br>
<br>
2. 등분산성 (Homoscedasticity)<br>
잔차의 분산이 일정해야 한다는 가정입니다. 주어진 잔차도에서는 특정한 패턴(포물선 형태)이 보이기 때문에 등분산성이 위배되었다고 볼 수 있습니다.<br>
<br>
3. 선형성 (Linearity)<br>
독립 변수와 종속 변수 사이의 관계가 선형적이어야 한다는 가정입니다. 회귀분석의 선형성을 확인하기 위해서는 잔차도가 아닌 X,Y 플롯을 확인하여야 되므로 잔차도와는 관련이 없습니다.<br>
<br>
4. 독립성 (Independence)<br>
이는 비상관성과 비슷한 개념으로, 잔차가 서로 독립적이어야 한다는 가정입니다. 주어진 잔차도의 패턴과는 직접적인 관련이 없습니다.<br>
			</div>
			<div class="t2">
									#회귀분석									# 잔차도									# 비상관성									# 등분산성									# 선형성									# 독립성							</div>
		</div>
		
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">4과목</span>
			<span class="g1">주성분 분석</span>
			<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">45.</span>
			<span class="tt1t1">
				다음 headsize 데이터는 25개 가구에서 첫 번째와 두 번째 성인 아들의 머리길이(head)와 머리폭(breadth)을 보여준다. 이에 대한 설명 중 가장 부적절한 것은?							</span>
		</strong>
		<span class="tt1t1">
						<a href="exam1view1img1.php?img=c37f4bd3-bf1e-716e-3de9-ebbadf9d0f75.png" target="_blank" rel="noopener" title="새 창" class="p1">
				<img src="/data/img/question/c37f4bd3-bf1e-716e-3de9-ebbadf9d0f75.png" alt="문제에 포함된 이미지">
			</a>
				    </span> 
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			주성분 분석의 결과를 보여준다.					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			처음 두 개의 주성분으로 전체 데이터 분산의 91%를 설명할 수 있다. 					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			두 번째 주성분은 네 개의 원변수와 양의 상관관계를 가진다.					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			네 개의 주성분을 사용하면 전체 데이터 분산을 모두 설명할 수 있다.					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a45" class="b2 help" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a45" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">3</i>
			<span class="t2t1">
			두 번째 주성분은 네 개의 원변수와 양의 상관관계를 가진다.			</span>
					</div>
        <br>
				<strong class="tt1">해설</strong>
		<div class="t1">
		두 번째 주성분은 head2 변수와 breadth2 변수에 대해 음의 상관관계를 가진다.				</div>
		
				
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				보기 1: 주성분 분석의 결과를 보여주고 있습니다. 표에 주성분 분석 결과가 나와 있습니다.<br>
<br>
보기 2: 처음 두 개의 주성분으로 전체 데이터 분산의 91%를 설명할 수 있습니다. 표에서 Cumulative Proportion 값이 0.91로 나타나 있습니다.<br>
<br>
보기 3: 두 번째 주성분은 네 개의 원변수와 양의 상관관계를 가지지 않습니다. 표에서 두 번째 주성분(Comp.2)의 loadings를 보면 head1 (0.693)와 breadth1 (0.219)은 양의 상관관계를 가지지만, head2 (-0.633)와 breadth2 (-0.267)는 음의 상관관계를 가집니다.<br>
<br>
보기 4: 네 개의 주성분을 사용하면 전체 데이터 분산을 모두 설명할 수 있습니다. 표에서 Cumulative Proportion 값이 1.000으로 나타나 있습니다.<br>
			</div>
			<div class="t2">
									# 주성분 분석									# 분산									# 누적 비율									# 상관관계									# 로딩 값									# r프로그램 결과해석							</div>
		</div>
		
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">4과목</span>
			<span class="g1">데이터 마이닝 개요</span>
			<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">46.</span>
			<span class="tt1t1">
				데이터마이닝의 활용 예가 아닌 것은 어느 것인가?							</span>
		</strong>
		<span class="tt1t1">
				    </span> 
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			병원에서 환자 데이터를 이용해 해당 환자에게 발생 가능성이 높은 병을 예측한다. 					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			웹사이트에 접속한 고객 정보를 활용해 고객에게 맞는 상품과 서비스를 추천한다. 					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			대용량 데이터를 통해 선거의 후보자 인지율 확인을 위한 전화조사에 활용할 대상 리스트를 만들어낸다.					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			은행에서 대출 심사를 할 때, 고객 데이터를 활용해 고객의 우량/불량을 예측한다.					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a46" class="b2 help" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a46" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">3</i>
			<span class="t2t1">
			대용량 데이터를 통해 선거의 후보자 인지율 확인을 위한 전화조사에 활용할 대상 리스트를 만들어낸다.			</span>
					</div>
        <br>
				<strong class="tt1">해설</strong>
		<div class="t1">
		③번은 데이터마이닝이 아닌 표본 추출방법에 대한 내용이다.				</div>
		
				
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				정답은 3번입니다.<br>
<br>
데이터마이닝은 대량의 데이터를 분석하여 유용한 정보를 추출하는 기술입니다. 다양한 분야에서 활용되며, 주로 예측, 추천, 분류 등의 목적으로 사용됩니다.<br>
<br>
1. 병원에서 환자 데이터를 이용해 해당 환자에게 발생 가능성이 높은 병을 예측한다.<br>
: 병원에서 환자 데이터를 분석하여 질병 발생 가능성을 예측하는 것은 데이터마이닝의 전형적인 활용 사례입니다. 이는 예측 분석의 한 형태로, 환자의 건강 상태를 미리 파악하여 적절한 조치를 취할 수 있게 합니다.<br>
<br>
2. 웹사이트에 접속한 고객 정보를 활용해 고객에게 맞는 상품과 서비스를 추천한다.<br>
: 웹사이트에서 고객 정보를 활용하여 맞춤형 상품과 서비스를 추천하는 것은 데이터마이닝의 대표적인 활용 예입니다. 이는 추천 시스템의 일환으로, 고객의 과거 행동 데이터를 분석하여 개인화된 경험을 제공합니다.<br>
<br>
3. 대용량 데이터를 통해 선거의 후보자 인지율 확인을 위한 전화조사에 활용할 대상 리스트를 만들어낸다.<br>
: 대용량 데이터를 통해 선거 후보자 인지율을 확인하기 위한 전화조사 대상 리스트를 만드는 것은 데이터마이닝의 활용 예로 보기 어렵습니다. 이는 주로 데이터 수집 및 정리의 과정에 해당하며, 데이터마이닝의 분석적 측면과는 거리가 있습니다.<br>
<br>
4. 은행에서 대출 심사를 할 때, 고객 데이터를 활용해 고객의 우량/불량을 예측한다.<br>
: 은행에서 대출 심사 시 고객 데이터를 활용하여 고객의 신용도를 예측하는 것은 데이터마이닝의 활용 사례입니다. 이는 고객의 과거 금융 데이터를 분석하여 대출 상환 가능성을 평가하는 데 사용됩니다.<br>
<br>
<br>
선거 후보자 인지율 확인을 위한 전화조사 대상 리스트를 만드는 것은 데이터마이닝의 분석적 활용보다는 데이터 수집 및 정리의 과정에 가깝습니다. 다른 선택지들은 모두 데이터마이닝을 통해 예측이나 추천을 수행하는 사례입니다.<br>
<br>
따라서, 정답은 '3. 대용량 데이터를 통해 선거의 후보자 인지율 확인을 위한 전화조사에 활용할 대상 리스트를 만들어낸다.' 입니다.<br>
			</div>
			<div class="t2">
									#데이터마이닝									# 예측 분석									# 추천 시스템									# 데이터 수집							</div>
		</div>
		
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">4과목</span>
			<span class="g1">데이터 마이닝 개요</span>
			<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">47.</span>
			<span class="tt1t1">
				데이터마이닝 모델링 방법 중 분류(classification) 방법으로 활용되지 않는 R 패키지는 무엇인가?							</span>
		</strong>
		<span class="tt1t1">
				    </span> 
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			rpart					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			kmeans					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			party					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			marginTree					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a47" class="b2 help" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a47" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">2</i>
			<span class="t2t1">
			kmeans			</span>
					</div>
        <br>
				<strong class="tt1">해설</strong>
		<div class="t1">
		R에서 지원하는 분류(Classification) 방법으로는 rpart, rpartOrdinal, randomForest, party, tree, marginTree, MapTree등 다양한 방법이 있다. 				</div>
		
				
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				정답은 2번입니다.<br>
<br>
이 문제는 데이터마이닝에서 분류(classification) 방법으로 사용되지 않는 R 패키지를 식별하는 것입니다. 분류는 주어진 데이터의 속성을 기반으로 미리 정의된 클래스 레이블을 예측하는 작업입니다. 다양한 R 패키지가 이러한 분류 작업을 지원합니다.<br>
<br>
1. rpart<br>
: 이 패키지는 의사결정나무를 생성하는 데 사용됩니다. 의사결정나무는 데이터를 분류하는 데 널리 사용되는 방법 중 하나로, 데이터를 여러 기준에 따라 분할하여 예측을 수행합니다.<br>
<br>
2. kmeans<br>
: 이 패키지는 주로 군집화(clustering) 작업에 사용됩니다. 군집화는 데이터를 유사한 그룹으로 묶는 작업으로, 분류와는 다르게 미리 정의된 클래스 레이블이 없습니다.<br>
<br>
3. party<br>
: 이 패키지는 의사결정나무와 관련된 다양한 방법을 제공하며, 분류 작업에 활용됩니다. 이를 통해 데이터를 분류하고 예측할 수 있습니다.<br>
<br>
4. marginTree<br>
: 이 패키지는 의사결정나무의 변형을 제공하여 분류 작업에 사용됩니다. 다양한 데이터 속성을 기반으로 데이터를 분류하는 데 유용합니다.<br>
<br>
<br>
분류 작업은 미리 정의된 클래스 레이블을 예측하는 것이며, 이를 위해 의사결정나무와 같은 방법이 사용됩니다. 첫 번째, 세 번째, 네 번째 패키지는 모두 의사결정나무와 관련된 분류 작업에 사용됩니다. 그러나 두 번째 패키지는 군집화 작업에 사용되며, 이는 분류와는 다른 작업입니다. 따라서 정답은 두 번째 패키지입니다.<br>
<br>
따라서, 정답은 '2. kmeans' 입니다.<br>
			</div>
			<div class="t2">
									#분류									# 의사결정나무									# 군집화									# R 패키지							</div>
		</div>
		
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">4과목</span>
			<span class="g1">인공신경망분석</span>
			<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">48.</span>
			<span class="tt1t1">
				모형의 성능을 평가할 때 사용되는 방법론 중 사후확률과 각 분류기준값에 의해 오분류 행렬을 만든 다음, 민감도(sensitivity)와 특이도(specificity)를 산출하여 도표에 도식화하여 평가하는 방식은 무엇인가?							</span>
		</strong>
		<span class="tt1t1">
				    </span> 
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			ROC(Receive Operating Characteristics) 					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			이익도표(Lift Chart) 					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			AUROC 					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			예측률(Prediction Rate)					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a48" class="b2 help" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a48" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">1</i>
			<span class="t2t1">
			ROC(Receive Operating Characteristics) 			</span>
					</div>
        <br>
				<strong class="tt1">해설</strong>
		<div class="t1">
		ROC 도표는 구축한 모형의 성능을 사후확률과 각 분류기준값에 의해 오분류 행렬을 만든 다음, x축은 1- 특이도로 y축은 민감도로 설정하여 그려지는 모형을 평가하는 지표이다.				</div>
		
				
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				정답은 1번입니다.<br>
<br>
모형의 성능을 평가할 때, 특히 분류(classification) 모형의 성능을 다양한 관점에서 측정하고 비교하기 위해 여러 가지 평가 방법론이 활용됩니다.<br>
<br>
1. ROC(Receive Operating Characteristics) <br>
: ROC(Receiver Operating Characteristics) 곡선은 모델의 성능을 평가하기 위해 민감도와 특이도를 사용하여 시각화하는 방법입니다. 이 곡선은 다양한 분류 기준값에 따라 모델의 성능을 평가할 수 있도록 도와줍니다. ROC 곡선은 민감도와 1-특이도를 축으로 하여 그래프를 그리며, 이 곡선을 통해 모델의 분류 능력을 직관적으로 평가할 수 있습니다.<br>
<br>
2. 이익도표(Lift Chart) <br>
: 이익도표(Lift Chart)는 마케팅 캠페인이나 고객 세분화에서 모델의 예측 성능을 평가하는 데 사용됩니다. 이 도표는 모델이 예측한 결과가 실제 결과에 비해 얼마나 더 나은지를 보여줍니다. 그러나 이익도표는 민감도와 특이도를 사용하여 오분류 행렬을 평가하는 방법이 아니므로, 문제의 요구사항과는 맞지 않습니다.<br>
<br>
3. AUROC <br>
: AUROC는 ROC 곡선 아래의 면적을 의미하며, 모델의 전반적인 성능을 수치화한 값입니다. AUROC 값이 1에 가까울수록 모델의 성능이 우수함을 나타냅니다. AUROC는 ROC 곡선의 특성을 수치적으로 요약한 것이므로, 문제에서 요구하는 ROC 곡선과 밀접한 관련이 있습니다.<br>
<br>
4. 예측률(Prediction Rate) <br>
: 예측률(Prediction Rate)은 모델이 예측한 결과의 정확도를 나타내는 지표입니다. 이는 민감도와 특이도를 사용하여 오분류 행렬을 평가하는 방법과는 다르며, 문제의 요구사항과는 관련이 없습니다.<br>
<br>
ROC는 다양한 임계값에서의 민감도와 특이도를 시각화하여 분류기의 성능을 평가하는 방법으로, 문제에서 설명한 방식과 일치합니다. 다른 선택지들은 각각 다른 평가 방법이나 지표를 설명하고 있습니다.<br>
<br>
따라서, 정답은 '1. ROC(Receive Operating Characteristics)' 입니다.<br>
			</div>
			<div class="t2">
									#ROC 곡선									# 민감도									# 특이도									# 오분류 행렬									# 모델 평가							</div>
		</div>
		
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">4과목</span>
			<span class="g1">연관분석</span>
			<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">49.</span>
			<span class="tt1t1">
				K-means 군집분석과 계층적 군집분석의 차이를 잘못 설명한 것은?							</span>
		</strong>
		<span class="tt1t1">
				    </span> 
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			K-means 군집분석은 계층적 군집분석과는 달리 한 개체가 처음 속한 군집에서 다른 군집으로 이동해 재배치될 수 있다. 					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			K-means 군집분석은 초기값에 대한 의존이 커서 초기값을 어떻게 하느냐에 따라 군집이 달라질 수 있다. 					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			K-means 군집분석은 동일한 거리 계산법을 적용하면 몇 번을 시행해도 동일한 결과가 나온다. 					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			계층적 군집분석은 동일한 거리계산법을 적용하면 몇 번을 시행해도 동일한 결과가 나온다.					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a49" class="b2 help" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a49" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">3</i>
			<span class="t2t1">
			K-means 군집분석은 동일한 거리 계산법을 적용하면 몇 번을 시행해도 동일한 결과가 나온다. 			</span>
					</div>
        <br>
				<strong class="tt1">해설</strong>
		<div class="t1">
		k-평균법은 계층적 군집방법과는 달리 한 개체가 속해 있던 군집에서 다른 군집으로 이동해 재배치가 가능하다. 초기값에 의존하는 방법으로 군집의 초기값 선택에 따라 최종 군집이 변할 수 있다.				</div>
		
				
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				정답은 3번입니다.<br>
<br>
K-means 군집분석과 계층적 군집분석은 대표적인 비지도 학습(Unsupervised Learning) 방법으로, 데이터 내에 존재하는 자연스러운 그룹(군집)을 찾는 데 사용됩니다. 두 방법은 작동 방식과 특징에서 여러 차이가 있습니다. <br>
<br>
1. K-means 군집분석은 계층적 군집분석과는 달리 한 개체가 처음 속한 군집에서 다른 군집으로 이동해 재배치될 수 있다. <br>
: K-means 군집분석은 비계층적 방법으로, 데이터 포인트가 군집 간에 이동할 수 있습니다. 이는 초기 중심값에 따라 데이터 포인트가 다른 군집으로 재배치될 수 있음을 의미합니다. 따라서, K-means는 유연하게 군집을 재구성할 수 있는 특징을 가지고 있습니다.<br>
<br>
2. K-means 군집분석은 초기값에 대한 의존이 커서 초기값을 어떻게 하느냐에 따라 군집이 달라질 수 있다. <br>
: K-means 군집분석은 초기 중심값에 크게 의존합니다. 초기값이 다르면 군집화 결과가 달라질 수 있으며, 이는 K-means의 주요 단점 중 하나입니다. 초기값 설정에 따라 최적의 군집을 찾기 위해 여러 번 실행해야 할 수도 있습니다.<br>
<br>
3. K-means 군집분석은 동일한 거리 계산법을 적용하면 몇 번을 시행해도 동일한 결과가 나온다. <br>
: K-means 군집분석은 초기 중심값에 따라 결과가 달라질 수 있기 때문에, 동일한 거리 계산법을 적용하더라도 매번 동일한 결과가 나오지 않습니다. 이는 K-means의 비결정론적 특성 때문입니다.<br>
<br>
4. 계층적 군집분석은 동일한 거리계산법을 적용하면 몇 번을 시행해도 동일한 결과가 나온다. <br>
: 계층적 군집분석은 데이터 포인트 간의 거리를 기반으로 군집을 형성하며, 동일한 거리 계산법을 사용하면 항상 동일한 결과를 보장합니다. 이는 계층적 군집분석의 결정론적 특성 때문입니다.<br>
<br>
K-means는 초기 중심값에 따라 결과가 달라질 수 있기 때문에 동일한 거리 계산법을 적용하더라도 매번 동일한 결과가 나오지 않습니다. 반면, 계층적 군집분석은 동일한 거리 계산법을 사용하면 항상 동일한 결과를 보장합니다. 따라서, 선택지 3은 잘못된 설명입니다.<br>
<br>
따라서, 정답은 '3. K-means 군집분석은 동일한 거래계산법을 적용하면 몇 번을 시행해도 동일한 결과가 나온다.' 입니다.<br>
			</div>
			<div class="t2">
									#K-means									# 계층적 군집분석									# 초기값									# 거리 계산									# 군집 이동									# 결정론적									# 비결정론적							</div>
		</div>
		
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">4과목</span>
			<span class="g1">데이터 마이닝 개요</span>
			<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">50.</span>
			<span class="tt1t1">
				데이터를 이용해 분석한 결과 “샌드위치를 사는 고객의 30%가 탄산수를 함께 산다”와 같은 결과를 얻기 위해 실행되는 데이터마이닝 분석 방법론은 무엇인가? 							</span>
		</strong>
		<span class="tt1t1">
				    </span> 
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			군집분석(clustering) 					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			분류분석(classification analysis) 					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			장바구니분석(market basket analysis) 					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			순차분석(sequence analysis)					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a50" class="b2 help" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a50" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">3</i>
			<span class="t2t1">
			장바구니분석(market basket analysis) 			</span>
					</div>
        <br>
				<strong class="tt1">해설</strong>
		<div class="t1">
		장바구니에 함께 구매한 상품 데이터를 이용해 분석한 결과 ‘아메리카노를 마시는 손님 중 10%가 브라우니를 먹는다’, ‘샌드위치를 먹는 고객의 30%가 탄산수를 함께 마신다’와 같은 결과를 얻어내는 방법론을 연관성 분석(장바구니 분석)이라고 한다.				</div>
		
				
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				정답은 3번입니다.<br>
<br>
데이터마이닝은 대량의 데이터를 분석하여 유의미한 패턴이나 관계를 발견하는 과정입니다. 이 과정은 다양한 분석 기법을 통해 이루어지며, 각 기법은 특정한 유형의 문제를 해결하는 데 적합합니다.<br>
<br>
1. 군집분석(clustering)<br>
: 군집분석은 데이터 집합을 유사한 특성을 가진 그룹으로 나누는 방법입니다. 이는 고객 세분화나 패턴 인식을 위해 사용됩니다.<br>
<br>
2. 분류분석(classification analysis)<br>
: 분류분석은 데이터 항목을 미리 정의된 클래스에 할당하는 방법입니다. 이는 주로 예측 모델을 구축하는 데 사용됩니다.<br>
<br>
3. 장바구니분석(market basket analysis)<br>
: 장바구니분석은 고객이 함께 구매하는 상품 간의 관계를 분석하는 방법입니다. 이는 연관 규칙을 찾아내어 교차 판매를 촉진하는 데 사용됩니다.<br>
<br>
4. 순차분석(sequence analysis)<br>
: 순차분석은 데이터 항목의 순서를 고려하여 패턴을 분석하는 방법입니다. 이는 주로 시간에 따른 변화나 이벤트의 순서를 분석하는 데 사용됩니다.<br>
<br>
<br>
장바구니분석은 고객이 함께 구매하는 상품 간의 관계를 분석하는 데 사용되며, 문제에서 제시된 '샌드위치를 사는 고객의 30%가 탄산수를 함께 산다'는 결과를 도출하는 데 적합합니다. 다른 선택지들은 각각 다른 목적과 방법론을 가지고 있어 이 문제의 상황에 적합하지 않습니다.<br>
<br>
따라서, 정답은 '3. 장바구니분석(market basket analysis)' 입니다.<br>
			</div>
			<div class="t2">
									#데이터마이닝									# 장바구니분석									# 연관 규칙									# 교차 판매							</div>
		</div>
		
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">4과목</span>
			<span class="g1">데이터변경 및 요약</span>
			<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">51.</span>
			<span class="tt1t1">
				다음 중 이상값 검색을 활용한 응용시스템으로 가장 적절한 것은?							</span>
		</strong>
		<span class="tt1t1">
				    </span> 
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			장바구니 분석 시스템					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			부정사용 방지 시스템 					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			데이터 마트					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			교차판매 시스템					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a51" class="b2 help" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a51" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">2</i>
			<span class="t2t1">
			부정사용 방지 시스템 			</span>
					</div>
        <br>
				<strong class="tt1">해설</strong>
		<div class="t1">
		이상값을 검색하여 한 집단에서 매우 크거나, 매우 작으면 의심되는 대상이므로 부정사용방지 시스템에 활용이 가능하다.				</div>
		
				
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				정답은 2번입니다.<br>
<br>
이상값 검색은 데이터 분석에서 비정상적이거나 예외적인 데이터를 식별하는 기법입니다. 이는 주로 데이터의 무결성을 확인하거나 비정상적인 패턴을 탐지하는 데 사용됩니다.<br>
<br>
1. 장바구니 분석 시스템<br>
:  장바구니 분석 시스템은 고객의 구매 패턴을 분석하여 관련 상품을 추천하는 데 중점을 둡니다. 이상값 검색보다는 연관 규칙 분석이 주로 사용됩니다.<br>
<br>
2. 부정사용 방지 시스템<br>
: 부정사용 방지 시스템은 비정상적인 사용 패턴을 탐지하여 사기나 부정 사용을 방지하는 데 초점을 맞춥니다. 이상값 검색이 핵심 기술로 활용됩니다.<br>
<br>
3. 데이터 마트<br>
: 데이터 마트는 대량의 데이터를 저장하고 분석하기 위한 구조를 제공합니다. 데이터의 저장과 접근이 주된 목적이며, 이상값 검색은 주로 사용되지 않습니다.<br>
<br>
4. 교차판매 시스템<br>
: 교차판매 시스템은 고객의 구매 이력을 바탕으로 추가적인 상품을 추천하는 데 사용됩니다. 주로 연관 규칙이나 협업 필터링이 사용되며, 이상값 검색과는 관련이 적습니다.<br>
<br>
<br>
부정사용 방지 시스템은 비정상적인 사용 패턴을 탐지하여 사기나 부정 사용을 방지하는 데 중점을 두고 있으며, 이상값 검색이 핵심 기술로 활용됩니다. 다른 선택지들은 이상값 검색보다는 다른 분석 기법을 주로 사용합니다.<br>
<br>
따라서, 정답은 '2. 부정사용 방지 시스템' 입니다.<br>
			</div>
			<div class="t2">
									#이상값 검색									# 부정사용 방지									# 데이터 분석									# 비정상 패턴							</div>
		</div>
		
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">4과목</span>
			<span class="g1">고급회귀분석</span>
			<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">52.</span>
			<span class="tt1t1">
				아래는 스위스의 47개 프랑스어 사용지역의 출산율(Fertility)과 관련된 변수들을 사용하여 얻은 결과이다. 회귀모형에 관한 다음 설명 중 가장 부적절한 것은?							</span>
		</strong>
		<span class="tt1t1">
						<a href="exam1view1img1.php?img=b3406973-7a2f-2cbc-56e7-6500f8bf1284.png" target="_blank" rel="noopener" title="새 창" class="p1">
				<img src="/data/img/question/b3406973-7a2f-2cbc-56e7-6500f8bf1284.png" alt="문제에 포함된 이미지">
			</a>
				    </span> 
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			유의수준 0.05하에서 위의 회귀모형은 유의적으로 출산율을 설명한다. 					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			위의 설명변수들은 출산율 변동의 원인임을 보여준다. 					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			위의 회귀모형은 출산율 변동의 70.67%를 설명한다. 					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			수정결정계수는 0.671이다.					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a52" class="b2 help" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a52" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">2</i>
			<span class="t2t1">
			위의 설명변수들은 출산율 변동의 원인임을 보여준다. 			</span>
					</div>
        <br>
				<strong class="tt1">해설</strong>
		<div class="t1">
		회귀분석은 변수들 간의 통계적 관계를 보여주지만, 이는 상관관계일 뿐 인과관계를 의미하지 않는다. 즉, 설명변수들이 출산율 변동의 '원인'이라고 단정할 수 없으며, 단지 통계적으로 유의미한 연관성이 있음을 나타낼 뿐이다.				</div>
		
				
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				정답은 2번입니다.<br>
<br>
다변량 회귀분석은 여러 개의 설명변수를 활용하여 하나의 종속변수를 예측하는 통계 기법으로, 회귀모형의 유의성, 설명력, 그리고 각 설명변수가 결과에 미치는 기여도를 종합적으로 평가하는 것이 중요합니다.<br>
<br>
1. 유의수준 0.05하에서 위의 회귀모형은 유의적으로 출산율을 설명한다. <br>
: 회귀모형의 유의성을 판단하기 위해 F-통계량과 p-value를 사용합니다. 주어진 F-통계량은 19.76이고, p-value는 5.594e-10으로 유의수준 0.05보다 작습니다. 이는 귀무가설을 기각하고 회귀모형이 통계적으로 유의하다는 것을 의미합니다.<br>
<br>
2. 위의 설명변수들은 출산율 변동의 원인임을 보여준다. <br>
: 회귀분석에서 설명변수들은 종속변수의 변동과 관련이 있지만, 인과관계를 직접적으로 나타내지는 않습니다. 설명변수들이 출산율 변동의 원인이라고 단정할 수는 없습니다. 이는 회귀분석의 한계 중 하나입니다.<br>
<br>
3. 위의 회귀모형은 출산율 변동의 70.67%를 설명한다. <br>
: Multiple R-squared는 0.7067로, 이는 회귀모형이 출산율 변동의 약 70.67%를 설명한다는 것을 의미합니다. 이는 모형의 설명력이 높음을 나타냅니다.<br>
<br>
4. 수정결정계수는 0.671이다. <br>
: Adjusted R-squared는 0.671로, 이는 설명변수의 수를 고려하여 조정된 결정계수입니다. 이는 모형이 출산율 변동의 약 67.1%를 설명한다는 것을 의미합니다.<br>
<br>
회귀분석은 변수들 간의 상관관계를 보여주지만, 인과관계를 증명하지는 않습니다. 나머지 선택지들은 회귀모형의 유의성 및 설명력을 올바르게 해석하고 있습니다.<br>
<br>
따라서, 정답은 '2. 위의 설명변수들은 출산율 변동의 원인임을 보여준다.' 입니다.<br>
			</div>
			<div class="t2">
									#다변량 회귀분석									# 결정계수									# 수정된 결정계수									# 유의성									# 인과관계							</div>
		</div>
		
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">4과목</span>
			<span class="g1">연관분석</span>
			<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">53.</span>
			<span class="tt1t1">
				아래 데이터 셋 A, B 간의 유사성을 유클리드 거리로 계산하면?							</span>
		</strong>
		<span class="tt1t1">
						<a href="exam1view1img1.php?img=3212118b-c7f9-6875-4206-29b04ebf2dfc.png" target="_blank" rel="noopener" title="새 창" class="p1">
				<img src="/data/img/question/3212118b-c7f9-6875-4206-29b04ebf2dfc.png" alt="문제에 포함된 이미지">
			</a>
				    </span> 
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			0					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			<mjx-container class="MathJax CtxtMenu_Attached_0" jax="CHTML" tabindex="0" ctxtmenu_counter="0" style="font-size: 107.5%; position: relative;"><mjx-math class="MJX-TEX" aria-hidden="true"><mjx-msqrt><mjx-sqrt><mjx-surd><mjx-mo class="mjx-n"><mjx-c class="mjx-c221A"></mjx-c></mjx-mo></mjx-surd><mjx-box style="padding-top: 0.163em;"><mjx-mn class="mjx-n"><mjx-c class="mjx-c35"></mjx-c></mjx-mn></mjx-box></mjx-sqrt></mjx-msqrt></mjx-math><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><msqrt><mn>5</mn></msqrt></math></mjx-assistive-mml></mjx-container>					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			<mjx-container class="MathJax CtxtMenu_Attached_0" jax="CHTML" tabindex="0" ctxtmenu_counter="1" style="font-size: 107.5%; position: relative;"><mjx-math class="MJX-TEX" aria-hidden="true"><mjx-msqrt><mjx-sqrt><mjx-surd><mjx-mo class="mjx-n"><mjx-c class="mjx-c221A"></mjx-c></mjx-mo></mjx-surd><mjx-box style="padding-top: 0.163em;"><mjx-mn class="mjx-n"><mjx-c class="mjx-c32"></mjx-c><mjx-c class="mjx-c35"></mjx-c></mjx-mn></mjx-box></mjx-sqrt></mjx-msqrt></mjx-math><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><msqrt><mn>25</mn></msqrt></math></mjx-assistive-mml></mjx-container>					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			<mjx-container class="MathJax CtxtMenu_Attached_0" jax="CHTML" tabindex="0" ctxtmenu_counter="2" style="font-size: 107.5%; position: relative;"><mjx-math class="MJX-TEX" aria-hidden="true"><mjx-msqrt><mjx-sqrt><mjx-surd><mjx-mo class="mjx-n"><mjx-c class="mjx-c221A"></mjx-c></mjx-mo></mjx-surd><mjx-box style="padding-top: 0.163em;"><mjx-mn class="mjx-n"><mjx-c class="mjx-c35"></mjx-c><mjx-c class="mjx-c30"></mjx-c></mjx-mn></mjx-box></mjx-sqrt></mjx-msqrt></mjx-math><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><msqrt><mn>50</mn></msqrt></math></mjx-assistive-mml></mjx-container>					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a53" class="b2 help" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a53" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">4</i>
			<span class="t2t1">
			<mjx-container class="MathJax CtxtMenu_Attached_0" jax="CHTML" tabindex="0" ctxtmenu_counter="3" style="font-size: 113.1%; position: relative;"><mjx-math class="MJX-TEX" aria-hidden="true"><mjx-msqrt><mjx-sqrt><mjx-surd><mjx-mo class="mjx-n"><mjx-c class="mjx-c221A"></mjx-c></mjx-mo></mjx-surd><mjx-box style="padding-top: 0.163em;"><mjx-mn class="mjx-n"><mjx-c class="mjx-c35"></mjx-c><mjx-c class="mjx-c30"></mjx-c></mjx-mn></mjx-box></mjx-sqrt></mjx-msqrt></mjx-math><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><msqrt><mn>50</mn></msqrt></math></mjx-assistive-mml></mjx-container>			</span>
					</div>
        <br>
				<strong class="tt1">해설</strong>
		<div class="t1">
		유클리디안 거리를 구하는 공식은 <mjx-container class="MathJax CtxtMenu_Attached_0" jax="CHTML" tabindex="0" ctxtmenu_counter="4" style="font-size: 113.1%; position: relative;"><mjx-math class="MJX-TEX" aria-hidden="true"><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D451 TEX-I"></mjx-c></mjx-mi><mjx-mo class="mjx-n"><mjx-c class="mjx-c28"></mjx-c></mjx-mo><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D465 TEX-I"></mjx-c></mjx-mi><mjx-mo class="mjx-n"><mjx-c class="mjx-c2C"></mjx-c></mjx-mo><mjx-mi class="mjx-i" space="2"><mjx-c class="mjx-c1D466 TEX-I"></mjx-c></mjx-mi><mjx-mo class="mjx-n"><mjx-c class="mjx-c29"></mjx-c></mjx-mo><mjx-mo class="mjx-n" space="4"><mjx-c class="mjx-c3D"></mjx-c></mjx-mo><mjx-msqrt space="4"><mjx-sqrt><mjx-surd><mjx-mo class="mjx-sop"><mjx-c class="mjx-c221A TEX-S1"></mjx-c></mjx-mo></mjx-surd><mjx-box style="padding-top: 0.084em;"><mjx-mo class="mjx-n"><mjx-c class="mjx-c28"></mjx-c></mjx-mo><mjx-msub><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D465 TEX-I"></mjx-c></mjx-mi><mjx-script style="vertical-align: -0.15em;"><mjx-mn class="mjx-n" size="s"><mjx-c class="mjx-c31"></mjx-c></mjx-mn></mjx-script></mjx-msub><mjx-mo class="mjx-n" space="3"><mjx-c class="mjx-c2212"></mjx-c></mjx-mo><mjx-msub space="3"><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D466 TEX-I"></mjx-c></mjx-mi><mjx-script style="vertical-align: -0.15em;"><mjx-mn class="mjx-n" size="s"><mjx-c class="mjx-c31"></mjx-c></mjx-mn></mjx-script></mjx-msub><mjx-msup><mjx-mo class="mjx-n"><mjx-c class="mjx-c29"></mjx-c></mjx-mo><mjx-script style="vertical-align: 0.289em;"><mjx-mn class="mjx-n" size="s"><mjx-c class="mjx-c32"></mjx-c></mjx-mn></mjx-script></mjx-msup><mjx-mo class="mjx-n"><mjx-c class="mjx-c2B"></mjx-c></mjx-mo><mjx-mo class="mjx-n"><mjx-c class="mjx-c2E"></mjx-c></mjx-mo><mjx-mo class="mjx-n" space="2"><mjx-c class="mjx-c2E"></mjx-c></mjx-mo><mjx-mo class="mjx-n" space="2"><mjx-c class="mjx-c2E"></mjx-c></mjx-mo><mjx-mo class="mjx-n" space="2"><mjx-c class="mjx-c2B"></mjx-c></mjx-mo><mjx-mo class="mjx-n"><mjx-c class="mjx-c28"></mjx-c></mjx-mo><mjx-msub><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D465 TEX-I"></mjx-c></mjx-mi><mjx-script style="vertical-align: -0.15em;"><mjx-mi class="mjx-i" size="s"><mjx-c class="mjx-c1D45D TEX-I"></mjx-c></mjx-mi></mjx-script></mjx-msub><mjx-mo class="mjx-n" space="3"><mjx-c class="mjx-c2212"></mjx-c></mjx-mo><mjx-msub space="3"><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D466 TEX-I"></mjx-c></mjx-mi><mjx-script style="vertical-align: -0.15em;"><mjx-mi class="mjx-i" size="s"><mjx-c class="mjx-c1D45D TEX-I"></mjx-c></mjx-mi></mjx-script></mjx-msub><mjx-msup><mjx-mo class="mjx-n"><mjx-c class="mjx-c29"></mjx-c></mjx-mo><mjx-script style="vertical-align: 0.289em;"><mjx-mn class="mjx-n" size="s"><mjx-c class="mjx-c32"></mjx-c></mjx-mn></mjx-script></mjx-msup></mjx-box></mjx-sqrt></mjx-msqrt><mjx-mo class="mjx-n" space="4"><mjx-c class="mjx-c3D"></mjx-c></mjx-mo><mjx-msqrt space="4"><mjx-sqrt><mjx-surd><mjx-mo class="mjx-lop"><mjx-c class="mjx-c221A TEX-S2"></mjx-c></mjx-mo></mjx-surd><mjx-box style="padding-top: 0.208em;"><mjx-mo class="mjx-n"><mjx-c class="mjx-c28"></mjx-c></mjx-mo><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D465 TEX-I"></mjx-c></mjx-mi><mjx-mo class="mjx-n" space="3"><mjx-c class="mjx-c2212"></mjx-c></mjx-mo><mjx-mi class="mjx-i" space="3"><mjx-c class="mjx-c1D466 TEX-I"></mjx-c></mjx-mi><mjx-mo class="mjx-n"><mjx-c class="mjx-c29"></mjx-c></mjx-mo><mjx-texatom texclass="ORD"><mjx-mover><mjx-over style="padding-bottom: 0.105em; padding-left: 0.195em; margin-bottom: -0.505em;"><mjx-mo class="mjx-n" style="width: 0px; margin-left: -0.25em;"><mjx-c class="mjx-cB4"></mjx-c></mjx-mo></mjx-over><mjx-base><mjx-mo class="mjx-n"><mjx-c class="mjx-c28"></mjx-c></mjx-mo></mjx-base></mjx-mover></mjx-texatom><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D465 TEX-I"></mjx-c></mjx-mi><mjx-mo class="mjx-n" space="3"><mjx-c class="mjx-c2212"></mjx-c></mjx-mo><mjx-mi class="mjx-i" space="3"><mjx-c class="mjx-c1D466 TEX-I"></mjx-c></mjx-mi><mjx-mo class="mjx-n"><mjx-c class="mjx-c29"></mjx-c></mjx-mo></mjx-box></mjx-sqrt></mjx-msqrt></mjx-math><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>d</mi><mo stretchy="false">(</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo stretchy="false">)</mo><mo>=</mo><msqrt><mo stretchy="false">(</mo><msub><mi>x</mi><mn>1</mn></msub><mo>−</mo><msub><mi>y</mi><mn>1</mn></msub><msup><mo stretchy="false">)</mo><mn>2</mn></msup><mo>+</mo><mo>.</mo><mo>.</mo><mo>.</mo><mo>+</mo><mo stretchy="false">(</mo><msub><mi>x</mi><mi>p</mi></msub><mo>−</mo><msub><mi>y</mi><mi>p</mi></msub><msup><mo stretchy="false">)</mo><mn>2</mn></msup></msqrt><mo>=</mo><msqrt><mo stretchy="false">(</mo><mi>x</mi><mo>−</mo><mi>y</mi><mo stretchy="false">)</mo><mrow data-mjx-texclass="ORD"><mover><mo stretchy="false">(</mo><mo data-mjx-pseudoscript="true">´</mo></mover></mrow><mi>x</mi><mo>−</mo><mi>y</mi><mo stretchy="false">)</mo></msqrt></math></mjx-assistive-mml></mjx-container>이다. 아래의 값을 대입하면 <mjx-container class="MathJax CtxtMenu_Attached_0" jax="CHTML" tabindex="0" ctxtmenu_counter="5" style="font-size: 113.1%; position: relative;"><mjx-math class="MJX-TEX" aria-hidden="true"><mjx-msqrt><mjx-sqrt><mjx-surd><mjx-mo class="mjx-sop"><mjx-c class="mjx-c221A TEX-S1"></mjx-c></mjx-mo></mjx-surd><mjx-box style="padding-top: 0.103em;"><mjx-mo class="mjx-n"><mjx-c class="mjx-c28"></mjx-c></mjx-mo><mjx-mn class="mjx-n"><mjx-c class="mjx-c31"></mjx-c><mjx-c class="mjx-c38"></mjx-c><mjx-c class="mjx-c30"></mjx-c></mjx-mn><mjx-mo class="mjx-n" space="3"><mjx-c class="mjx-c2212"></mjx-c></mjx-mo><mjx-mn class="mjx-n" space="3"><mjx-c class="mjx-c31"></mjx-c><mjx-c class="mjx-c37"></mjx-c><mjx-c class="mjx-c35"></mjx-c></mjx-mn><mjx-msup><mjx-mo class="mjx-n"><mjx-c class="mjx-c29"></mjx-c></mjx-mo><mjx-script style="vertical-align: 0.289em;"><mjx-mn class="mjx-n" size="s"><mjx-c class="mjx-c32"></mjx-c></mjx-mn></mjx-script></mjx-msup><mjx-mo class="mjx-n" space="3"><mjx-c class="mjx-c2B"></mjx-c></mjx-mo><mjx-mo class="mjx-n" space="3"><mjx-c class="mjx-c28"></mjx-c></mjx-mo><mjx-mn class="mjx-n"><mjx-c class="mjx-c36"></mjx-c><mjx-c class="mjx-c35"></mjx-c></mjx-mn><mjx-mo class="mjx-n" space="3"><mjx-c class="mjx-c2212"></mjx-c></mjx-mo><mjx-mn class="mjx-n" space="3"><mjx-c class="mjx-c37"></mjx-c><mjx-c class="mjx-c30"></mjx-c></mjx-mn><mjx-msup><mjx-mo class="mjx-n"><mjx-c class="mjx-c29"></mjx-c></mjx-mo><mjx-script style="vertical-align: 0.289em;"><mjx-mn class="mjx-n" size="s"><mjx-c class="mjx-c32"></mjx-c></mjx-mn></mjx-script></mjx-msup></mjx-box></mjx-sqrt></mjx-msqrt><mjx-mo class="mjx-n" space="4"><mjx-c class="mjx-c3D"></mjx-c></mjx-mo><mjx-msqrt space="4"><mjx-sqrt><mjx-surd><mjx-mo class="mjx-n"><mjx-c class="mjx-c221A"></mjx-c></mjx-mo></mjx-surd><mjx-box style="padding-top: 0.163em;"><mjx-mn class="mjx-n"><mjx-c class="mjx-c35"></mjx-c><mjx-c class="mjx-c30"></mjx-c></mjx-mn></mjx-box></mjx-sqrt></mjx-msqrt></mjx-math><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><msqrt><mo stretchy="false">(</mo><mn>180</mn><mo>−</mo><mn>175</mn><msup><mo stretchy="false">)</mo><mn>2</mn></msup><mo>+</mo><mo stretchy="false">(</mo><mn>65</mn><mo>−</mo><mn>70</mn><msup><mo stretchy="false">)</mo><mn>2</mn></msup></msqrt><mo>=</mo><msqrt><mn>50</mn></msqrt></math></mjx-assistive-mml></mjx-container>이다.				</div>
		
				
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				유클리드 거리(Euclidean distance)는 두 점 사이의 직선 거리를 의미합니다. <br>
주어진 데이터 셋 A와 B의 유클리드 거리를 계산하기 위해 다음 공식을 사용합니다:<br>
<br>
<mjx-container class="MathJax CtxtMenu_Attached_0" jax="CHTML" display="true" tabindex="0" ctxtmenu_counter="6" style="font-size: 113.1%; position: relative;"><mjx-math display="true" class="MJX-TEX" aria-hidden="true" style="margin-left: 0px; margin-right: 0px;"><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D451 TEX-I"></mjx-c></mjx-mi><mjx-mo class="mjx-n" space="4"><mjx-c class="mjx-c3D"></mjx-c></mjx-mo><mjx-msqrt space="4"><mjx-sqrt><mjx-surd><mjx-mo class="mjx-lop"><mjx-c class="mjx-c221A TEX-S2"></mjx-c></mjx-mo></mjx-surd><mjx-box style="padding-top: 0.45em;"><mjx-mo class="mjx-n"><mjx-c class="mjx-c28"></mjx-c></mjx-mo><mjx-msub><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D465 TEX-I"></mjx-c></mjx-mi><mjx-script style="vertical-align: -0.15em;"><mjx-mn class="mjx-n" size="s"><mjx-c class="mjx-c32"></mjx-c></mjx-mn></mjx-script></mjx-msub><mjx-mo class="mjx-n" space="3"><mjx-c class="mjx-c2212"></mjx-c></mjx-mo><mjx-msub space="3"><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D465 TEX-I"></mjx-c></mjx-mi><mjx-script style="vertical-align: -0.15em;"><mjx-mn class="mjx-n" size="s"><mjx-c class="mjx-c31"></mjx-c></mjx-mn></mjx-script></mjx-msub><mjx-msup><mjx-mo class="mjx-n"><mjx-c class="mjx-c29"></mjx-c></mjx-mo><mjx-script style="vertical-align: 0.289em;"><mjx-mn class="mjx-n" size="s"><mjx-c class="mjx-c32"></mjx-c></mjx-mn></mjx-script></mjx-msup><mjx-mo class="mjx-n" space="3"><mjx-c class="mjx-c2B"></mjx-c></mjx-mo><mjx-mo class="mjx-n" space="3"><mjx-c class="mjx-c28"></mjx-c></mjx-mo><mjx-msub><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D466 TEX-I"></mjx-c></mjx-mi><mjx-script style="vertical-align: -0.15em;"><mjx-mn class="mjx-n" size="s"><mjx-c class="mjx-c32"></mjx-c></mjx-mn></mjx-script></mjx-msub><mjx-mo class="mjx-n" space="3"><mjx-c class="mjx-c2212"></mjx-c></mjx-mo><mjx-msub space="3"><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D466 TEX-I"></mjx-c></mjx-mi><mjx-script style="vertical-align: -0.15em;"><mjx-mn class="mjx-n" size="s"><mjx-c class="mjx-c31"></mjx-c></mjx-mn></mjx-script></mjx-msub><mjx-msup><mjx-mo class="mjx-n"><mjx-c class="mjx-c29"></mjx-c></mjx-mo><mjx-script style="vertical-align: 0.289em;"><mjx-mn class="mjx-n" size="s"><mjx-c class="mjx-c32"></mjx-c></mjx-mn></mjx-script></mjx-msup></mjx-box></mjx-sqrt></mjx-msqrt></mjx-math><mjx-assistive-mml unselectable="on" display="block"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mi>d</mi><mo>=</mo><msqrt><mo stretchy="false">(</mo><msub><mi>x</mi><mn>2</mn></msub><mo>−</mo><msub><mi>x</mi><mn>1</mn></msub><msup><mo stretchy="false">)</mo><mn>2</mn></msup><mo>+</mo><mo stretchy="false">(</mo><msub><mi>y</mi><mn>2</mn></msub><mo>−</mo><msub><mi>y</mi><mn>1</mn></msub><msup><mo stretchy="false">)</mo><mn>2</mn></msup></msqrt></math></mjx-assistive-mml></mjx-container><br>
<br>
여기서 <mjx-container class="MathJax CtxtMenu_Attached_0" jax="CHTML" tabindex="0" ctxtmenu_counter="7" style="font-size: 113.1%; position: relative;"><mjx-math class="MJX-TEX" aria-hidden="true"><mjx-msub><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D465 TEX-I"></mjx-c></mjx-mi><mjx-script style="vertical-align: -0.15em;"><mjx-mn class="mjx-n" size="s"><mjx-c class="mjx-c31"></mjx-c></mjx-mn></mjx-script></mjx-msub></mjx-math><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>x</mi><mn>1</mn></msub></math></mjx-assistive-mml></mjx-container>과 <mjx-container class="MathJax CtxtMenu_Attached_0" jax="CHTML" tabindex="0" ctxtmenu_counter="8" style="font-size: 113.1%; position: relative;"><mjx-math class="MJX-TEX" aria-hidden="true"><mjx-msub><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D465 TEX-I"></mjx-c></mjx-mi><mjx-script style="vertical-align: -0.15em;"><mjx-mn class="mjx-n" size="s"><mjx-c class="mjx-c32"></mjx-c></mjx-mn></mjx-script></mjx-msub></mjx-math><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>x</mi><mn>2</mn></msub></math></mjx-assistive-mml></mjx-container>는 키, <mjx-container class="MathJax CtxtMenu_Attached_0" jax="CHTML" tabindex="0" ctxtmenu_counter="9" style="font-size: 113.1%; position: relative;"><mjx-math class="MJX-TEX" aria-hidden="true"><mjx-msub><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D466 TEX-I"></mjx-c></mjx-mi><mjx-script style="vertical-align: -0.15em;"><mjx-mn class="mjx-n" size="s"><mjx-c class="mjx-c31"></mjx-c></mjx-mn></mjx-script></mjx-msub></mjx-math><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>y</mi><mn>1</mn></msub></math></mjx-assistive-mml></mjx-container>과 <mjx-container class="MathJax CtxtMenu_Attached_0" jax="CHTML" tabindex="0" ctxtmenu_counter="10" style="font-size: 113.1%; position: relative;"><mjx-math class="MJX-TEX" aria-hidden="true"><mjx-msub><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D466 TEX-I"></mjx-c></mjx-mi><mjx-script style="vertical-align: -0.15em;"><mjx-mn class="mjx-n" size="s"><mjx-c class="mjx-c32"></mjx-c></mjx-mn></mjx-script></mjx-msub></mjx-math><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>y</mi><mn>2</mn></msub></math></mjx-assistive-mml></mjx-container>는 몸무게입니다.<br>
<br>
A와 B의 키와 몸무게를 각각 <mjx-container class="MathJax CtxtMenu_Attached_0" jax="CHTML" tabindex="0" ctxtmenu_counter="11" style="font-size: 113.1%; position: relative;"><mjx-math class="MJX-TEX" aria-hidden="true"><mjx-mo class="mjx-n"><mjx-c class="mjx-c28"></mjx-c></mjx-mo><mjx-mn class="mjx-n"><mjx-c class="mjx-c31"></mjx-c><mjx-c class="mjx-c38"></mjx-c><mjx-c class="mjx-c30"></mjx-c></mjx-mn><mjx-mo class="mjx-n"><mjx-c class="mjx-c2C"></mjx-c></mjx-mo><mjx-mn class="mjx-n" space="2"><mjx-c class="mjx-c36"></mjx-c><mjx-c class="mjx-c35"></mjx-c></mjx-mn><mjx-mo class="mjx-n"><mjx-c class="mjx-c29"></mjx-c></mjx-mo></mjx-math><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><mo stretchy="false">(</mo><mn>180</mn><mo>,</mo><mn>65</mn><mo stretchy="false">)</mo></math></mjx-assistive-mml></mjx-container>와 <mjx-container class="MathJax CtxtMenu_Attached_0" jax="CHTML" tabindex="0" ctxtmenu_counter="12" style="font-size: 113.1%; position: relative;"><mjx-math class="MJX-TEX" aria-hidden="true"><mjx-mo class="mjx-n"><mjx-c class="mjx-c28"></mjx-c></mjx-mo><mjx-mn class="mjx-n"><mjx-c class="mjx-c31"></mjx-c><mjx-c class="mjx-c37"></mjx-c><mjx-c class="mjx-c35"></mjx-c></mjx-mn><mjx-mo class="mjx-n"><mjx-c class="mjx-c2C"></mjx-c></mjx-mo><mjx-mn class="mjx-n" space="2"><mjx-c class="mjx-c37"></mjx-c><mjx-c class="mjx-c30"></mjx-c></mjx-mn><mjx-mo class="mjx-n"><mjx-c class="mjx-c29"></mjx-c></mjx-mo></mjx-math><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><mo stretchy="false">(</mo><mn>175</mn><mo>,</mo><mn>70</mn><mo stretchy="false">)</mo></math></mjx-assistive-mml></mjx-container>로 나타낼 수 있습니다. <br>
이를 공식을 사용하여 계산하면:<br>
<br>
<mjx-container class="MathJax CtxtMenu_Attached_0" jax="CHTML" display="true" tabindex="0" ctxtmenu_counter="13" style="font-size: 113.1%; position: relative;"><mjx-math display="true" class="MJX-TEX" aria-hidden="true" style="margin-left: 0px; margin-right: 0px;"><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D451 TEX-I"></mjx-c></mjx-mi><mjx-mo class="mjx-n" space="4"><mjx-c class="mjx-c3D"></mjx-c></mjx-mo><mjx-msqrt space="4"><mjx-sqrt><mjx-surd><mjx-mo class="mjx-lop"><mjx-c class="mjx-c221A TEX-S2"></mjx-c></mjx-mo></mjx-surd><mjx-box style="padding-top: 0.45em;"><mjx-mo class="mjx-n"><mjx-c class="mjx-c28"></mjx-c></mjx-mo><mjx-mn class="mjx-n"><mjx-c class="mjx-c31"></mjx-c><mjx-c class="mjx-c37"></mjx-c><mjx-c class="mjx-c35"></mjx-c></mjx-mn><mjx-mo class="mjx-n" space="3"><mjx-c class="mjx-c2212"></mjx-c></mjx-mo><mjx-mn class="mjx-n" space="3"><mjx-c class="mjx-c31"></mjx-c><mjx-c class="mjx-c38"></mjx-c><mjx-c class="mjx-c30"></mjx-c></mjx-mn><mjx-msup><mjx-mo class="mjx-n"><mjx-c class="mjx-c29"></mjx-c></mjx-mo><mjx-script style="vertical-align: 0.289em;"><mjx-mn class="mjx-n" size="s"><mjx-c class="mjx-c32"></mjx-c></mjx-mn></mjx-script></mjx-msup><mjx-mo class="mjx-n" space="3"><mjx-c class="mjx-c2B"></mjx-c></mjx-mo><mjx-mo class="mjx-n" space="3"><mjx-c class="mjx-c28"></mjx-c></mjx-mo><mjx-mn class="mjx-n"><mjx-c class="mjx-c37"></mjx-c><mjx-c class="mjx-c30"></mjx-c></mjx-mn><mjx-mo class="mjx-n" space="3"><mjx-c class="mjx-c2212"></mjx-c></mjx-mo><mjx-mn class="mjx-n" space="3"><mjx-c class="mjx-c36"></mjx-c><mjx-c class="mjx-c35"></mjx-c></mjx-mn><mjx-msup><mjx-mo class="mjx-n"><mjx-c class="mjx-c29"></mjx-c></mjx-mo><mjx-script style="vertical-align: 0.289em;"><mjx-mn class="mjx-n" size="s"><mjx-c class="mjx-c32"></mjx-c></mjx-mn></mjx-script></mjx-msup></mjx-box></mjx-sqrt></mjx-msqrt></mjx-math><mjx-assistive-mml unselectable="on" display="block"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mi>d</mi><mo>=</mo><msqrt><mo stretchy="false">(</mo><mn>175</mn><mo>−</mo><mn>180</mn><msup><mo stretchy="false">)</mo><mn>2</mn></msup><mo>+</mo><mo stretchy="false">(</mo><mn>70</mn><mo>−</mo><mn>65</mn><msup><mo stretchy="false">)</mo><mn>2</mn></msup></msqrt></math></mjx-assistive-mml></mjx-container><br>
<mjx-container class="MathJax CtxtMenu_Attached_0" jax="CHTML" display="true" tabindex="0" ctxtmenu_counter="14" style="font-size: 113.1%; position: relative;"><mjx-math display="true" class="MJX-TEX" aria-hidden="true" style="margin-left: 0px; margin-right: 0px;"><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D451 TEX-I"></mjx-c></mjx-mi><mjx-mo class="mjx-n" space="4"><mjx-c class="mjx-c3D"></mjx-c></mjx-mo><mjx-msqrt space="4"><mjx-sqrt><mjx-surd><mjx-mo class="mjx-lop"><mjx-c class="mjx-c221A TEX-S2"></mjx-c></mjx-mo></mjx-surd><mjx-box style="padding-top: 0.45em;"><mjx-mo class="mjx-n"><mjx-c class="mjx-c28"></mjx-c></mjx-mo><mjx-mo class="mjx-n"><mjx-c class="mjx-c2212"></mjx-c></mjx-mo><mjx-mn class="mjx-n"><mjx-c class="mjx-c35"></mjx-c></mjx-mn><mjx-msup><mjx-mo class="mjx-n"><mjx-c class="mjx-c29"></mjx-c></mjx-mo><mjx-script style="vertical-align: 0.289em;"><mjx-mn class="mjx-n" size="s"><mjx-c class="mjx-c32"></mjx-c></mjx-mn></mjx-script></mjx-msup><mjx-mo class="mjx-n" space="3"><mjx-c class="mjx-c2B"></mjx-c></mjx-mo><mjx-msup space="3"><mjx-mn class="mjx-n"><mjx-c class="mjx-c35"></mjx-c></mjx-mn><mjx-script style="vertical-align: 0.289em;"><mjx-mn class="mjx-n" size="s"><mjx-c class="mjx-c32"></mjx-c></mjx-mn></mjx-script></mjx-msup></mjx-box></mjx-sqrt></mjx-msqrt></mjx-math><mjx-assistive-mml unselectable="on" display="block"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mi>d</mi><mo>=</mo><msqrt><mo stretchy="false">(</mo><mo>−</mo><mn>5</mn><msup><mo stretchy="false">)</mo><mn>2</mn></msup><mo>+</mo><msup><mn>5</mn><mn>2</mn></msup></msqrt></math></mjx-assistive-mml></mjx-container><br>
<mjx-container class="MathJax CtxtMenu_Attached_0" jax="CHTML" display="true" tabindex="0" ctxtmenu_counter="15" style="font-size: 113.1%; position: relative;"><mjx-math display="true" class="MJX-TEX" aria-hidden="true" style="margin-left: 0px; margin-right: 0px;"><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D451 TEX-I"></mjx-c></mjx-mi><mjx-mo class="mjx-n" space="4"><mjx-c class="mjx-c3D"></mjx-c></mjx-mo><mjx-msqrt space="4"><mjx-sqrt><mjx-surd><mjx-mo class="mjx-n"><mjx-c class="mjx-c221A"></mjx-c></mjx-mo></mjx-surd><mjx-box style="padding-top: 0.181em;"><mjx-mn class="mjx-n"><mjx-c class="mjx-c32"></mjx-c><mjx-c class="mjx-c35"></mjx-c></mjx-mn><mjx-mo class="mjx-n" space="3"><mjx-c class="mjx-c2B"></mjx-c></mjx-mo><mjx-mn class="mjx-n" space="3"><mjx-c class="mjx-c32"></mjx-c><mjx-c class="mjx-c35"></mjx-c></mjx-mn></mjx-box></mjx-sqrt></mjx-msqrt></mjx-math><mjx-assistive-mml unselectable="on" display="block"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mi>d</mi><mo>=</mo><msqrt><mn>25</mn><mo>+</mo><mn>25</mn></msqrt></math></mjx-assistive-mml></mjx-container><br>
<mjx-container class="MathJax CtxtMenu_Attached_0" jax="CHTML" display="true" tabindex="0" ctxtmenu_counter="16" style="font-size: 113.1%; position: relative;"><mjx-math display="true" class="MJX-TEX" aria-hidden="true" style="margin-left: 0px; margin-right: 0px;"><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D451 TEX-I"></mjx-c></mjx-mi><mjx-mo class="mjx-n" space="4"><mjx-c class="mjx-c3D"></mjx-c></mjx-mo><mjx-msqrt space="4"><mjx-sqrt><mjx-surd><mjx-mo class="mjx-n"><mjx-c class="mjx-c221A"></mjx-c></mjx-mo></mjx-surd><mjx-box style="padding-top: 0.211em;"><mjx-mn class="mjx-n"><mjx-c class="mjx-c35"></mjx-c><mjx-c class="mjx-c30"></mjx-c></mjx-mn></mjx-box></mjx-sqrt></mjx-msqrt></mjx-math><mjx-assistive-mml unselectable="on" display="block"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mi>d</mi><mo>=</mo><msqrt><mn>50</mn></msqrt></math></mjx-assistive-mml></mjx-container><br>
<br>
따라서, 유클리드 거리는 <mjx-container class="MathJax CtxtMenu_Attached_0" jax="CHTML" tabindex="0" ctxtmenu_counter="17" style="font-size: 113.1%; position: relative;"><mjx-math class="MJX-TEX" aria-hidden="true"><mjx-msqrt><mjx-sqrt><mjx-surd><mjx-mo class="mjx-n"><mjx-c class="mjx-c221A"></mjx-c></mjx-mo></mjx-surd><mjx-box style="padding-top: 0.163em;"><mjx-mn class="mjx-n"><mjx-c class="mjx-c35"></mjx-c><mjx-c class="mjx-c30"></mjx-c></mjx-mn></mjx-box></mjx-sqrt></mjx-msqrt></mjx-math><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><msqrt><mn>50</mn></msqrt></math></mjx-assistive-mml></mjx-container>입니다.<br>
			</div>
			<div class="t2">
									# 유클리드 거리									# 거리 계산							</div>
		</div>
		
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">4과목</span>
			<span class="g1">인공신경망분석</span>
			<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">54.</span>
			<span class="tt1t1">
				분류문제를 예측하기 위한 모형을 개발하여 테스트 데이터를 통해 그 결과를 분석하고자 한다. 아래 표를 활용하여 민감도를 구하려고 할 때 민감도를 산출하는 방식은 어떤 것인가?							</span>
		</strong>
		<span class="tt1t1">
						<a href="exam1view1img1.php?img=1160760a-c41d-fa8c-7bcd-86484e9cc1d4.png" target="_blank" rel="noopener" title="새 창" class="p1">
				<img src="/data/img/question/1160760a-c41d-fa8c-7bcd-86484e9cc1d4.png" alt="문제에 포함된 이미지">
			</a>
				    </span> 
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			TP/(TP+FN)					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			FN/(TP+FN)					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			FP/(FP+TN)					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			TN/(FP+TN)					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a54" class="b2 help" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a54" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">1</i>
			<span class="t2t1">
			TP/(TP+FN)			</span>
					</div>
        <br>
				<strong class="tt1">해설</strong>
		<div class="t1">
		분석결과를 확인하는 방법 중 민감도를 구하는 방법<br>
민감도 : 양성이라고 판단되는 값(TP)/실제 양성의 값(TP+FN)<br>
정확도 : 양성, 음성이라고 판단되는 값(TP+TN)/실제 양성과 음성의 값(TP+FN+FP+TN) <br>
특이도 : 음성이라고 판단되는 값(TN)/실제 음성의 값(FP+TN)				</div>
		
				
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				민감도(Sensitivity), 또는 진짜 양성 비율(True Positive Rate)은 실제로 양성인 케이스 중에서 얼마나 많은 양성 케이스를 양성으로 예측했는지를 측정하는 지표입니다. 이는 TP/(TP+FN)으로 계산됩니다.<br>
<br>
1. TP/(TP+FN): 이는 민감도를 산출하는 정확한 방식입니다. TP는 True Positive로 실제 양성을 양성으로 예측한 경우, FN은 False Negative로 실제 양성을 음성으로 잘못 예측한 경우를 의미합니다.<br>
<br>
2. FN/(TP+FN): 이는 민감도가 아닌, False Negative Rate를 산출하는 방식입니다. 이는 실제 양성을 음성으로 잘못 예측한 비율을 나타냅니다.<br>
<br>
3. FP/(FP+TN): 이는 False Positive Rate를 산출하는 방식입니다. 이는 실제 음성을 양성으로 잘못 예측한 비율을 나타냅니다.<br>
<br>
4. TN/(FP+TN): 이는 특이도(Specificity)를 산출하는 방식입니다. 이는 실제 음성을 음성으로 정확하게 예측한 비율을 나타냅니다.<br>
			</div>
			<div class="t2">
									# 민감도(Sensitivity)									# True Positive(TP)									# False Negative(FN)									# 분류문제									# 모형 개발									# 테스트 데이터									# 특이도									# Specificity							</div>
		</div>
		
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">4과목</span>
			<span class="g1">텍스트 마이닝</span>
			<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">55.</span>
			<span class="tt1t1">
				다음 중 감성분석에 대한 설명으로 가장 부적절한 것은?							</span>
		</strong>
		<span class="tt1t1">
				    </span> 
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			텍스트에 포함된 내용이 주관적인지 객관적인지를 먼저 판단해야 한다.					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			내용이 긍정적인지 부정적인지 판별하고 나의 상품이나 브랜드의 여론이 긍정적인지 부정적인지를 찾아내는데 활용된다.					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			개별 문장의 분석에 오류가 나타나면 많은 문서를 가공하더라도 추이 파악에 어려움이 생기는 단점이 있는 분석방법이다.					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			영향력이 높은 대상자에게는 높은 가중치를 부여함으로써 더 정확한 감성지표를 계산할 수 있다.					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a55" class="b2 help" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a55" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">1</i>
			<span class="t2t1">
			텍스트에 포함된 내용이 주관적인지 객관적인지를 먼저 판단해야 한다.			</span>
					</div>
        <br>
				<strong class="tt1">해설</strong>
		<div class="t1">
		감성분석은 문장에서 사용된 단어의 긍정과 부정여부에 따라 얼마나 긍정적인 단어가 많은지 여부로 긍정 문장인지를 평가한다.				</div>
		
				
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				정답은 1번입니다.<br>
<br>
감성분석은 텍스트 데이터에서 감정이나 의견을 추출하여 분석하는 기법으로, 주로 긍정적, 부정적, 중립적 감정을 파악하는 데 사용됩니다. 이는 기업의 마케팅 전략 수립이나 고객 피드백 분석에 유용하게 활용됩니다.<br>
<br>
1. 텍스트에 포함된 내용이 주관적인지 객관적인지를 먼저 판단해야 한다.<br>
: 감성분석은 텍스트의 주관성이나 객관성을 판단하는 것이 아니라, 주로 감정의 긍정적, 부정적, 중립적 성향을 파악하는 데 중점을 둡니다. 따라서 주관성과 객관성을 먼저 판단해야 한다는 설명은 감성분석의 본질과 다소 거리가 있습니다.<br>
<br>
2. 내용이 긍정적인지 부정적인지 판별하고 나의 상품이나 브랜드의 여론이 긍정적인지 부정적인지를 찾아내는데 활용된다.<br>
: 감성분석은 텍스트의 감정적 성향을 분석하여 특정 상품이나 브랜드에 대한 여론을 파악하는 데 활용됩니다. 이를 통해 기업은 소비자들의 반응을 이해하고, 마케팅 전략을 조정할 수 있습니다.<br>
<br>
3. 개별 문장의 분석에 오류가 나타나면 많은 문서를 가공하더라도 추이 파악에 어려움이 생기는 단점이 있는 분석방법이다.<br>
: 감성분석은 개별 문장의 분석이 정확하지 않으면 전체적인 추세를 파악하는 데 어려움이 있을 수 있습니다. 이는 감성분석의 한계 중 하나로, 데이터의 품질과 분석의 정확성이 중요합니다.<br>
<br>
4. 영향력이 높은 대상자에게는 높은 가중치를 부여함으로써 더 정확한 감성지표를 계산할 수 있다.<br>
: 감성분석에서 영향력이 높은 대상자에게 가중치를 부여하는 것은 분석의 정확성을 높이는 방법 중 하나입니다. 이는 특정 의견이 전체 분석에 미치는 영향을 조정하여 보다 신뢰성 있는 결과를 도출할 수 있게 합니다.<br>
<br>
<br>
감성분석은 텍스트의 주관성이나 객관성을 판단하는 것이 아니라, 주로 감정의 긍정적, 부정적, 중립적 성향을 파악하는 데 중점을 둡니다. 따라서 주관성과 객관성을 먼저 판단해야 한다는 설명은 감성분석의 본질과 다소 거리가 있습니다. 다른 선택지들은 감성분석의 실제 활용과 한계에 대한 설명으로 적절합니다.<br>
<br>
따라서, 정답은 '1. 텍스트에 포함된 내용이 주관적인지 객관적인지를 먼저 판단해야 한다.' 입니다.<br>
			</div>
			<div class="t2">
									#감성분석									# 텍스트 데이터									# 긍정적									# 부정적							</div>
		</div>
		
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">4과목</span>
			<span class="g1">기초 통계분석</span>
			<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">56.</span>
			<span class="tt1t1">
				가설검정에서는 귀무가설을 기각할지 여부를 판단하기 위해 통계적 기준을 설정하게 된다. 이때, 잘못된 결론을 내릴 가능성을 줄이기 위해 제1종 오류와 제2종 오류 개념이 사용된다. 다음 중 이에 대한 설명으로 가장 적절한 것은 무엇인가?							</span>
		</strong>
		<span class="tt1t1">
				    </span> 
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			제 1종 오류는 실제로 대립가설이 거짓이지만, 검정결과 대립가설을 채택하는 오류이다. 					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			제 2종 오류는 대립가설이 맞는데도 귀무가설이 맞다고 결론 내리는 오류이다. 					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			제 1종 오류는 실제로 귀무가설이 맞는데 틀리다고 결론 내리는 오류이다.					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			유의수준을 너무 작게하면 귀무가설을 선택할 확률이 커져 대립가설이 옳은데도 불구하고 부정해 버리는 오류를 범할 수 있다.					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a56" class="b2 help" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a56" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">3</i>
			<span class="t2t1">
			제 1종 오류는 실제로 귀무가설이 맞는데 틀리다고 결론 내리는 오류이다.			</span>
					</div>
        <br>
				<strong class="tt1">해설</strong>
		<div class="t1">
		제 1종 오류(TypeⅠerror)는 귀무가설이 옳은데도 귀무가설을 기각하게 되는 오류이다.				</div>
		
				
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				정답은 3번입니다.<br>
<br>
가설검정은 모집단에 대한 어떤 주장을 통계적으로 검증하는 과정으로, 이 과정에서 귀무가설과 대립가설을 설정하고, 수집된 표본 데이터를 바탕으로 귀무가설을 기각할지 말지를 결정하게 됩니다.<br>
<br>
1. 제 1종 오류는 실제로 대립가설이 거짓이지만, 검정결과 대립가설을 채택하는 오류이다. <br>
: 제1종 오류는 귀무가설이 참일 때 이를 기각하는 오류입니다. 이는 유의수준(α)과 관련이 있으며, α가 작을수록 제1종 오류의 확률이 줄어듭니다. <br>
<br>
2. 제 2종 오류는 대립가설이 맞는데도 귀무가설이 맞다고 결론 내리는 오류이다. <br>
: 제2종 오류는 귀무가설이 거짓일 때 이를 기각하지 않는 오류입니다. 이는 검정력과 관련이 있으며, 검정력이 높을수록 제2종 오류의 확률이 줄어듭니다. <br>
<br>
3. 제 1종 오류는 실제로 귀무가설이 맞는데 틀리다고 결론 내리는 오류이다. <br>
: 제1종 오류는 귀무가설이 참일 때 이를 기각하는 오류입니다. 이는 유의수준(α)과 직접적으로 관련이 있으며, α가 클수록 제1종 오류의 확률이 증가합니다. <br>
<br>
4. 유의수준을 너무 작게하면 귀무가설을 선택할 확률이 커져 대립가설이 옳은데도 불구하고 부정해 버리는 오류를 범할 수 있다. <br>
: 유의수준을 너무 작게 설정하면 제1종 오류의 확률이 줄어들지만, 그에 따라 제2종 오류의 확률이 증가할 수 있습니다. 이는 대립가설이 참일 때 이를 기각할 확률이 높아지는 것을 의미합니다. 유의수준과 오류 간의 상충 관계를 이해하는 것이 중요합니다.<br>
<br>
<br>
제1종 오류는 귀무가설이 참일 때 이를 기각하는 오류를 의미합니다. 선택지 1번은 제1종 오류를 잘못 설명하고 있으며, 선택지 2번은 제2종 오류에 대한 내용으로 제1종 오류와는 관련이 없습니다. 선택지 4번은 유의수준과 오류 간의 관계를 다루고 있어 제1종 오류의 정의 설명과는 거리가 있습니다.<br>
<br>
따라서, 정답은 '3. 제 1종 오류는 실제로 귀무가설이 맞는데 틀리다고 결론 내리는 오류이다.' 입니다.<br>
<br>
			</div>
			<div class="t2">
									# 제 1종 오류									# 제 2종 오류									# 귀무가설									# 대립가설									# 유의수준							</div>
		</div>
		
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">4과목</span>
			<span class="g1">R 기초</span>
			<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">57.</span>
			<span class="tt1t1">
				다음 중 통계 패키지 R에 대한 설명으로 가장 부적절한 것은?							</span>
		</strong>
		<span class="tt1t1">
				    </span> 
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			R은 오픈소스 프로그램이다.					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			다양한 최신 통계분석과 데이터마이닝 기능을 제공한다. 					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			Linux 환경에서는 사용이 불가능하다.					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			사용자들이 여러 예시들을 공유한다.					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a57" class="b2 help" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a57" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">3</i>
			<span class="t2t1">
			Linux 환경에서는 사용이 불가능하다.			</span>
					</div>
        <br>
				<strong class="tt1">해설</strong>
		<div class="t1">
		R 프로그램은 Linux 환경에서도 사용이 가능하다.				</div>
		
				
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				정답은 3번입니다.<br>
<br>
R은 통계 계산 및 그래픽을 위한 프로그래밍 언어이자 소프트웨어 환경입니다. 데이터 분석, 통계 모델링, 머신러닝, 시각화 등 다양한 분야에서 널리 활용되고 있습니다.<br>
<br>
1. R은 오픈소스 프로그램이다.<br>
: R은 자유롭게 사용할 수 있는 오픈소스 소프트웨어입니다. 이는 사용자가 소스 코드를 보고 수정할 수 있으며, 무료로 배포된다는 것을 의미합니다.<br>
<br>
2. 다양한 최신 통계분석과 데이터마이닝 기능을 제공한다.<br>
: R은 최신 통계 분석 기법과 데이터 마이닝 기능을 지원합니다. 이는 다양한 패키지를 통해 구현되며, 사용자가 필요에 따라 추가할 수 있습니다.<br>
<br>
3. Linux 환경에서는 사용이 불가능하다.<br>
: R은 Windows, MacOS, Linux 등 다양한 운영체제에서 실행 가능합니다. 따라서 특정 운영체제에서만 사용이 불가능하다는 주장은 사실이 아닙니다.<br>
<br>
4. 사용자들이 여러 예시들을 공유한다.<br>
: R 커뮤니티는 매우 활발하며, 사용자들이 다양한 예제와 코드를 공유합니다. 이는 R의 학습과 활용에 큰 도움이 됩니다.<br>
<br>
<br>
R은 다양한 운영체제에서 실행 가능하므로, Linux 환경에서 사용이 불가능하다는 주장은 잘못되었습니다. 다른 선택지들은 R의 특성과 기능을 올바르게 설명하고 있습니다.<br>
<br>
따라서, 정답은 '3. Linux 환경에서는 사용이 불가능하다.' 입니다.<br>
			</div>
			<div class="t2">
									#R									# 오픈소스									# 통계 분석									# 데이터 마이닝									# 운영체제							</div>
		</div>
		
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">4과목</span>
			<span class="g1">사회연결망 분석</span>
			<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">58.</span>
			<span class="tt1t1">
				다음 사회연결망 분석 중 한 노드가 연결망 내의 다른 노드들 사이의 최다 경로 위에 위치할수록 그 노드의 중심성이 높은 것으로 측정하는 방법으로 가장 적절한 것은?							</span>
		</strong>
		<span class="tt1t1">
				    </span> 
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			연결정도 중심성 					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			근접 중심성 					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			매개 중심성 					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			위세 중심성					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a58" class="b2 help" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a58" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">3</i>
			<span class="t2t1">
			매개 중심성 			</span>
					</div>
        <br>
				<strong class="tt1">해설</strong>
		<div class="t1">
		매개 중심성은 한 노드가 연결망 내의 다른 노드들 사이의 최다 경로 위에 위치할수록 그 노드의 중심성이 높은 것으로 측정하는 방법이다.				</div>
		
				
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				정답은 3번입니다.<br>
<br>
사회연결망 분석에서 중심성은 네트워크 내에서 특정 노드의 중요성을 측정하는 방법입니다. 중심성의 종류에는 여러 가지가 있으며, 각기 다른 기준으로 노드의 중요성을 평가합니다.<br>
<br>
1. 연결정도 중심성<br>
: 이 방법은 한 노드가 얼마나 많은 다른 노드와 직접 연결되어 있는지를 측정합니다. 네트워크 내에서 직접 연결된 노드의 수가 많을수록 중심성이 높다고 평가됩니다.<br>
<br>
2. 근접 중심성<br>
: 이 방법은 한 노드가 다른 모든 노드에 얼마나 가까운지를 측정합니다. 즉, 네트워크 내에서 다른 노드들까지의 평균 경로 길이가 짧을수록 중심성이 높다고 평가됩니다.<br>
<br>
3. 매개 중심성<br>
: 이 방법은 한 노드가 다른 노드들 사이의 경로에서 얼마나 자주 등장하는지를 측정합니다. 즉, 네트워크 내에서 경로의 중간에 위치하여 다른 노드들을 연결하는 역할을 많이 할수록 중심성이 높다고 평가됩니다.<br>
<br>
4. 위세 중심성<br>
: 이 방법은 한 노드가 연결된 다른 노드들의 중요성에 따라 중심성을 평가합니다. 즉, 중요한 노드와 연결되어 있을수록 중심성이 높다고 평가됩니다.<br>
<br>
<br>
매개 중심성은 한 노드가 다른 노드들 사이의 경로에서 얼마나 자주 등장하는지를 측정하는 방법입니다. 이는 네트워크 내에서 경로의 중간에 위치하여 다른 노드들을 연결하는 역할을 많이 할수록 중심성이 높다고 평가됩니다. 다른 선택지들은 각각 다른 기준으로 중심성을 평가하므로, 문제에서 요구하는 조건에 부합하지 않습니다.<br>
<br>
따라서, 정답은 '3. 매개 중심성' 입니다.<br>
			</div>
			<div class="t2">
									#중심성									# 매개 중심성									# 사회연결망									# 경로							</div>
		</div>
		
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">4과목</span>
			<span class="g1">앙상블 기법</span>
			<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">59.</span>
			<span class="tt1t1">
				원데이터 집합으로부터 크기가 같은 표본을 여러번 단순임의 복원추출하여 각 표본에 대한 분류기를 생성한 후 그 결과를 앙상블하는 방법으로 다음 중 가장 적절한 것은?							</span>
		</strong>
		<span class="tt1t1">
				    </span> 
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			배깅(bagging)					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			의사결정나무(decision tree)					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			인공신경망(artificial neural network) 					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			유전자 알고리즘(genetic algorithm)					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a59" class="b2 help" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a59" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">1</i>
			<span class="t2t1">
			배깅(bagging)			</span>
					</div>
        <br>
				<strong class="tt1">해설</strong>
		<div class="t1">
		배깅은 주어진 자료에서 여러 개의 붓스트랩(bootstrap)자료를 생성하고 각 붓스트랩 자료에 예측모형을 만든 후 결합하여 최종 예측모형을 만드는 방법이다.				</div>
		
				
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				정답은 1번입니다.<br>
<br>
앙상블 기법은 여러 개의 예측 모형을 결합하여 하나의 최종 예측 모형을 만드는 방법으로, 이는 개별 모형의 약점을 보완하고 예측 성능을 향상시키기 위해 사용됩니다. 앙상블 기법에는 배깅, 부스팅, 랜덤포레스트 등이 있습니다.<br>
<br>
1. 배깅(bagging)<br>
: 배깅은 여러 개의 표본을 복원추출하여 각각의 표본에 대해 모델을 학습시키고, 그 결과를 결합하여 최종 예측을 수행합니다. 이는 모델의 분산을 줄이고, 예측의 안정성을 높이는 데 효과적입니다.<br>
<br>
2. 의사결정나무(decision tree)<br>
: 의사결정나무는 데이터의 특성을 기반으로 의사결정 규칙을 생성하여 분류를 수행합니다. 단일 모델로 사용되며, 앙상블 기법과는 다릅니다.<br>
<br>
3. 인공신경망(artificial neural network)<br>
: 인공신경망은 인간의 신경망을 모방하여 데이터를 학습하는 기계 학습 모델입니다. 주로 비선형 문제를 해결하는 데 사용되며, 앙상블 기법과는 직접적인 관련이 없습니다.<br>
<br>
4. 유전자 알고리즘(genetic algorithm)<br>
: 유전자 알고리즘은 자연 선택의 원리를 모방하여 최적의 해를 찾는 알고리즘입니다. 주로 최적화 문제에 사용되며, 앙상블 기법과는 다른 접근 방식입니다.<br>
<br>
<br>
배깅은 여러 표본을 복원추출하여 각각의 모델을 학습시키고, 그 결과를 결합하여 예측의 정확성을 높이는 앙상블 기법입니다. 다른 선택지들은 각각의 특성과 목적이 있으며, 앙상블 기법과는 다른 접근 방식입니다.<br>
<br>
따라서, 정답은 '1. 배깅(bagging)' 입니다.<br>
			</div>
			<div class="t2">
									#앙상블									# 복원추출									# 분류기									# 배깅							</div>
		</div>
		
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">4과목</span>
			<span class="g1">R 기초</span>
			<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">60.</span>
			<span class="tt1t1">
				아래는 chickwts를 데이터테이블로 변화시키는 과정이다. 다음 중 feed 변수의 각 레벨에 따라 weight를 분할하는 명령어로 적절한 것은 무엇인가?							</span>
		</strong>
		<span class="tt1t1">
						<a href="exam1view1img1.php?img=6c5c7c2e-b6e1-e6d5-4562-e04099269837.png" target="_blank" rel="noopener" title="새 창" class="p1">
				<img src="/data/img/question/6c5c7c2e-b6e1-e6d5-4562-e04099269837.png" alt="문제에 포함된 이미지">
			</a>
				    </span> 
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			unsplit(feed, weight)					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			split(chickwts$feed, chickwts$weight) 					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			split(chickwts$weight, chickwts$feed) 					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			unsplit(weight, feed)					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a60" class="b2 help" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a60" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">3</i>
			<span class="t2t1">
			split(chickwts$weight, chickwts$feed) 			</span>
					</div>
        <br>
				<strong class="tt1">해설</strong>
		<div class="t1">
		R에서 split() 함수는 첫 번째 인자로 분할하고자 하는 벡터(여기서는 weight)를 받고, 두 번째 인자로 분할 기준이 되는 요인(factor) 벡터(여기서는 feed)를 받아 그 요인의 레벨에 따라 첫 번째 벡터를 분할한다. 따라서 chickwts 데이터프레임에서 feed 변수의 각 레벨에 따라 weight를 분할하는 명령어는 split(chickwts$weight, chickwts$feed)가 가장 적절하다.<br>
<br>
③의 결과는 아래와 같다.<br>
&gt; split(chickwts$weight, chickwts$feed) <br>
$`casein`<br>
 [1] 368 390 379 260 404 318 352 359 216 222 283 332 <br>
$horsebean<br>
 [1] 179 160 136 227 217 168 108 124 143 140 <br>
$linseed<br>
 [1] 309 229 181 141 260 203 148 169 213 257 244 271 <br>
$meatmeal<br>
 [1] 325 257 303 315 380 153 263 242 206 344 258 <br>
$soybean<br>
 [1] 243 230 248 327 329 250 193 271 316 267 199 171 158 248 <br>
$sunflower<br>
 [1] 423 340 392 339 341 226 320 295 334 322 297 318				</div>
		
				
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				정답은 3번입니다.<br>
<br>
R의 데이터 분석에서 'split' 함수는 데이터를 특정 기준에 따라 나누는 데 사용됩니다. 'chickwts' 데이터셋은 병아리의 무게와 먹이 종류를 포함하고 있으며, 이 데이터를 먹이 종류별로 무게를 나누고자 할 때 'split' 함수를 사용합니다. <br>
<br>
1. unsplit(feed, weight)<br>
: unsplit() 함수는 split() 함수로 나누어진 데이터를 다시 원래의 형태로 합치는 데 사용됩니다. 데이터를 분할하는 목적으로는 적절하지 않습니다.<br>
<br>
2. split(chickwts$feed, chickwts$weight) <br>
: split() 함수의 첫 번째 인자는 분할할 데이터, 두 번째 인자는 분할 기준이 되는 데이터입니다. 분할 대상과 기준이 서로 바뀌어 있으므로 적절하지 않습니다.<br>
<br>
3. split(chickwts$weight, chickwts$feed) <br>
: 이 명령어는 chickwts$weight (닭의 체중 데이터)를 분할하고자 하는 x 인자로 사용하고, chickwts$feed (사료 종류)를 분할 기준이 되는 인자로 사용합니다. 이는 feed 변수의 각 레벨에 따라 weight 데이터를 그룹별로 나누는 작업을 수행하며, 문제의 요구사항과 일치합니다.<br>
<br>
4. unsplit(weight, feed) <br>
: unsplit() 함수를 사용하고 있으므로, 데이터를 분할하는 목적에는 적합하지 않습니다. 또한, unsplit()는 일반적으로 split의 결과물인 리스트를 첫 번째 인자로 받습니다.<br>
<br>
정답은 'split(chickwts$weight, chickwts$feed)'입니다. 이는 'chickwts' 데이터셋에서 'weight'를 'feed'에 따라 나누는 올바른 방법입니다. 나머지 선지들은 'unsplit' 함수를 사용하거나 'split' 함수의 인자 순서가 잘못되어 적절하지 않습니다.<br>
<br>
따라서, 정답은 '3. split(chickwts$weight, chickwts$feed)' 입니다.<br>
			</div>
			<div class="t2">
									#데이터 테블로									# split 함수									# 데이터 분할									# R 출력 결과									# unsplit									# 							</div>
		</div>
		
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">4과목</span>
			<span class="g1">회귀분석</span>
			<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">61.</span>
			<span class="tt1t1">
				다음 중 공분산에 관한 설명으로 가장 부적절한 것은?							</span>
		</strong>
		<span class="tt1t1">
				    </span> 
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			X, Y의 방향의 조합(선형성)이다.					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			(Cov(X,Y)=E[(X-μ_{x})(Y-μ_{y})])					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			X와 Y가 서로 독립이면 Cov(X,Y)=0이다. 					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			-1≤Cov(X,Y)≤1이다.					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a61" class="b2 help" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a61" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">4</i>
			<span class="t2t1">
			-1≤Cov(X,Y)≤1이다.			</span>
					</div>
        <br>
				<strong class="tt1">해설</strong>
		<div class="t1">
		공분산 값의 범위는 –1과 1사이가 아니다. 				</div>
		
				
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				정답은 4번입니다.<br>
<br>
공분산(Covariance)은 두 확률변수 X와 Y가 함께 변하는 정도를 측정하는 통계량으로, 두 변수 간의 선형 관계의 방향성(같은 방향으로 변하는지, 반대 방향으로 변하는지)을 나타냅니다.<br>
<br>
1. X, Y의 방향의 조합(선형성)이다.<br>
: 공분산은 두 변수의 방향성을 나타내며, 선형 관계를 측정합니다. 따라서 방향의 조합과 관련이 있습니다.<br>
<br>
2. (Cov(X,Y)=E[(X-μ_{x})(Y-μ_{y})])<br>
: 공분산의 수학적 정의는 두 변수의 편차 곱의 기대값으로 표현됩니다. 이는 공분산의 기본적인 정의입니다.<br>
<br>
3. X와 Y가 서로 독립이면 Cov(X,Y)=0이다.<br>
: 두 확률변수 X와 Y가 서로 독립이라면, 두 변수 사이에 선형적인 관계가 없으므로 공분산은 0이 됩니다. 이는 독립성의 특성 중 하나입니다.<br>
<br>
4. -1≤Cov(X,Y)≤1이다.<br>
: 공분산의 값은 변수들의 측정 단위나 스케일에 영향을 받기 때문에 특정 범위로 제한되지 않습니다. 예를 들어, X와 Y의 값이 매우 크다면 공분산의 값도 매우 커질 수 있습니다. -1과 1 사이의 범위를 가지는 것은 상관계수의 특성입니다.<br>
<br>
공분산은 두 변수의 단위에 따라 값이 달라지며, -1과 1 사이의 값을 가지는 것은 상관계수의 특성입니다. 따라서 공분산이 -1과 1 사이의 값을 가진다는 설명은 부적절합니다. 다른 선택지들은 공분산의 정의와 특성에 부합합니다.<br>
<br>
따라서, 정답은 '4. -1≤Cov(X,Y)≤1이다.' 입니다.<br>
			</div>
			<div class="t2">
									# 공분산									# 선형성									# 독립성									# Cov(X									#Y)							</div>
		</div>
		
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">4과목</span>
			<span class="g1">텍스트 마이닝</span>
			<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">62.</span>
			<span class="tt1t1">
				다음 중 영문에 대한 텍스트 마이닝 시 텍스트 데이터에 대한 전처리 작업으로 자연어 처리를 위하여 공통 어간을 가지는 단어를 묶는 처리 방법으로 적절한 것은?							</span>
		</strong>
		<span class="tt1t1">
				    </span> 
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			제외어 처리					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			TDM 구축					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			스태밍					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			구두점 제거					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a62" class="b2 help" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a62" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">3</i>
			<span class="t2t1">
			스태밍			</span>
					</div>
        <br>
				<strong class="tt1">해설</strong>
		<div class="t1">
		텍스트 마이닝에서 자연어 처리를 위해 공통 어간을 가지는 단어들을 묶는 처리 방법은 스태밍(Stemming)이다. 이는 단어의 형태학적 변형을 제거하고 단어의 원형 또는 어간을 찾아내어 분석의 효율성을 높이는 과정이다.				</div>
		
				
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				정답은 3번입니다.<br>
<br>
텍스트 마이닝은 비정형 텍스트 데이터에서 유의미한 정보를 추출하고 패턴을 발견하는 과정으로, 이를 위해서는 텍스트 데이터를 분석하기 전에 다양한 전처리 작업이 필요하며, 자연어 처리 기술이 활용됩니다.<br>
<br>
1. 제외어 처리 <br>
: 제외어 처리는 텍스트 데이터에서 분석에 불필요한 단어들을 제거하는 과정으로, 주로 빈도가 낮거나 의미가 없는 단어들을 제거하여 데이터의 노이즈를 줄이는 데 사용됩니다. 이는 어간 추출과는 다른 개념으로, 단어의 형태를 단순화하는 것이 아니라 불필요한 단어를 제거하는 데 중점을 둡니다.<br>
<br>
2. TDM 구축 <br>
: TDM 구축은 Term Document Matrix를 만드는 과정으로, 문서와 단어 간의 관계를 행렬 형태로 표현하는 방법입니다. 이는 텍스트 데이터를 수치화하여 분석할 수 있도록 도와주지만, 어간 추출과는 직접적인 관련이 없습니다. TDM은 주로 문서의 유사도 분석이나 검색 결과의 중요도 결정에 사용됩니다.<br>
<br>
3. 스태밍 <br>
: 스태밍은 정해진 규칙에 따라 단어의 접미사를 제거하여 단어의 기본 형태를 찾는 작업으로, 이는 단어의 다양한 형태를 하나의 대표 형태로 통합하여 분석의 일관성을 높이고, 데이터의 차원을 줄이는 데 도움이 됩니다.<br>
<br>
4. 구두점 제거 <br>
: 구두점 제거는 텍스트 데이터에서 구두점을 제거하여 분석에 필요한 순수한 텍스트만 남기는 과정입니다. 이는 텍스트의 노이즈를 줄이고, 분석의 정확성을 높이기 위한 전처리 작업 중 하나입니다. 구두점 제거는 어간 추출과는 다른 개념으로, 단어의 형태를 단순화하는 것이 아니라 텍스트의 불필요한 요소를 제거하는 데 중점을 둡니다.<br>
<br>
<br>
스태밍은 단어의 어간을 추출하여 공통된 형태로 묶는 방법으로, 문제에서 묻는 '공통 어간을 가지는 단어를 묶는 처리 방법'에 해당합니다. 다른 선택지들은 각각 다른 전처리 작업을 설명하고 있습니다.<br>
<br>
따라서, 정답은 '3. 스태밍' 입니다.<br>
			</div>
			<div class="t2">
									# 텍스트 마이닝									# 전처리									# 자연어 처리									# 스태밍									# 어간 추출									# Stemming									# 제외어 처리									# TDM 구축									# 구두점 제거							</div>
		</div>
		
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">4과목</span>
			<span class="g1">텍스트 마이닝</span>
			<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">63.</span>
			<span class="tt1t1">
				다음 중 아래 거래 전표에서 연관 규칙 “A→B”의 신뢰도를 구한 것으로 적절한 것은?							</span>
		</strong>
		<span class="tt1t1">
						<a href="exam1view1img1.php?img=60a31909-2d76-23e9-97b4-8999c6d0f820.png" target="_blank" rel="noopener" title="새 창" class="p1">
				<img src="/data/img/question/60a31909-2d76-23e9-97b4-8999c6d0f820.png" alt="문제에 포함된 이미지">
			</a>
				    </span> 
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			25%					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			30%					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			40%					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			50%					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a63" class="b2 help" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a63" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">4</i>
			<span class="t2t1">
			50%			</span>
					</div>
        <br>
				<strong class="tt1">해설</strong>
		<div class="t1">
		신뢰도=({지지도 over P(A)}={{300 over 1100} over {600 over 1100}}=0.5)				</div>
		
				
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				연관 규칙 "A→B"의 신뢰도를 계산하기 위해서는 A와 B가 동시에 발생한 거래 건수를 A가 발생한 전체 거래 건수로 나누어야 합니다.<br>
<br>
- A가 포함된 거래 건수: {A} (100건), {A, C} (200건), {A, B, D} (200건), {A, B, C, D} (100건) = 100 + 200 + 200 + 100 = 600건<br>
<br>
- A와 B가 동시에 포함된 거래 건수: {A, B, D} (200건), {A, B, C, D} (100건) = 200 + 100 = 300건<br>
<br>
따라서, 신뢰도는 (A와 B가 동시에 포함된 거래 건수) / (A가 포함된 전체 거래 건수) = 300 / 600 = 0.5 = 50%<br>
<br>
			</div>
			<div class="t2">
									# 연관 규칙									# 신뢰도									# 거래 건수							</div>
		</div>
		
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">4과목</span>
			<span class="g1">시계열분석</span>
			<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">64.</span>
			<span class="tt1t1">
				다음 중 분해 시계열을 이루는 구성요소로 적절하지 않은 것은 무엇인가?							</span>
		</strong>
		<span class="tt1t1">
				    </span> 
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			정상요인					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			추세요인					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			계절요인					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			불규칙요인					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a64" class="b2 help" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a64" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">1</i>
			<span class="t2t1">
			정상요인			</span>
					</div>
        <br>
				<strong class="tt1">해설</strong>
		<div class="t1">
		시계열 데이터는 일반적으로 추세, 계절성, 순환, 불규칙 요인으로 분해된다. 정상성은 시계열의 특성이 시간에 따라 변하지 않는 상태를 의미하며, 이는 시계열 분석의 전제 조건이나 목표가 될 수 있지만, 시계열 자체를 구성하는 분해 요소는 아니다.				</div>
		
				
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				정답은 1번입니다.<br>
<br>
시계열 분석에서 시계열 데이터는 일반적으로 몇 가지 구성요소로 분해하여 이해하고 예측하는 데 활용되며, 이러한 분해는 시계열의 각 요인이 데이터에 어떤 영향을 미치는지 파악하는 데 도움을 줍니다.<br>
<br>
1. 정상요인<br>
: 정상요인은 시계열 분해의 구성 요소가 아닙니다. 정상성(Stationarity)은 평균, 분산, 자기공분산이 시간에 따라 변하지 않는 시계열의 속성으로, 시계열 모델의 기본 전제입니다. 비정상 시계열은 차분 등으로 정상화해야 하며, 정상성은 분해 가능한 요인이 아닙니다.<br>
<br>
2. 추세요인<br>
: 추세요인(Trend Component)은 시계열 데이터가 장기적으로 증가하거나 감소하는 경향을 나타내는 부분으로, 이는 계절적 변동이나 단기적인 불규칙성 등을 제외한 전반적인 흐름을 의미합니다.<br>
<br>
3. 계절요인<br>
: 계절요인(Seasonal Component)은 1년, 한 달, 일주일 등 특정 주기를 가지고 반복적으로 나타나는 변동을 의미하며, 예를 들어, 여름철 에어컨 판매량 증가, 주말의 특정 서비스 이용량 증가 등이 계절요인에 해당합니다.<br>
<br>
4. 불규칙요인<br>
: 불규칙요인(Irregular Component) 또는 잔차요인(Residual Component)은 추세요인과 계절요인을 제거하고 남은, 설명되지 않는 변동 부분으로, 이는 예측할 수 없는 무작위적인 변동이나 돌발적인 사건(예: 지진, 파업)으로 인한 영향을 나타냅니다.<br>
<br>
<br>
정상요인은 시계열 분석에서 사용되는 일반적인 용어가 아니며, 시계열의 변동을 설명하는 데 적절하지 않습니다. 반면, 추세요인, 계절요인, 불규칙요인은 시계열의 변동을 설명하는 데 사용되는 주요 구성 요소입니다.<br>
<br>
따라서, 정답은 '1. 정상요인' 입니다.<br>
			</div>
			<div class="t2">
									# 시계열 분석									# 추세 요인									# 계절 요인									# 불규칙 요인									# 순환 요인									# 정상 요인							</div>
		</div>
		
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">4과목</span>
			<span class="g1">통계분석 방법론</span>
			<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">65.</span>
			<span class="tt1t1">
				Carseats 데이터프레임은 400개 상점에서 판매중인 유아용 카시트에 대한 자료이다. 아래의 설명으로 적절하지 않은 것은 무엇인가?							</span>
		</strong>
		<span class="tt1t1">
						<a href="exam1view1img1.php?img=f662cca4-fa7d-965c-aea2-a765e63333dc.png" target="_blank" rel="noopener" title="새 창" class="p1">
				<img src="/data/img/question/f662cca4-fa7d-965c-aea2-a765e63333dc.png" alt="문제에 포함된 이미지">
			</a>
				    </span> 
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			Sales의 평균은 7.496이다.					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			약 25%의 카시트에 대한 Sales값이 5.39보다 작다. 					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			Price의 최대값은 191.0이다.					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			약 25%의 카시트에 대한 Price 값이 131.0보다 작다.					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a65" class="b2 help" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a65" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">4</i>
			<span class="t2t1">
			약 25%의 카시트에 대한 Price 값이 131.0보다 작다.			</span>
					</div>
        <br>
				<strong class="tt1">해설</strong>
		<div class="t1">
		주어진 통계 요약표에서 각 변수의 최소값, 1사분위수(1st Qu.), 중앙값(Median), 평균(Mean), 3사분위수(3rd Qu.), 최대값(Max.)을 통해 데이터의 분포를 파악할 수 있다. 1사분위수는 데이터의 하위 25% 지점을, 3사분위수는 하위 75% 지점을 나타낸다. 선택지 4번은 Price의 3사분위수 값을 잘못 해석하여 약 25%의 값이 131.0보다 작다고 설명하고 있으므로 부적절하다.				</div>
		
				
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				정답은 4번입니다.<br>
<br>
주어진 summary(Carseats) 결과는 Carseats 데이터프레임의 각 변수에 대한 요약 통계량을 보여주며, 이 요약 통계량에는 최소값(Min.), 1사분위수(1st Qu.), 중앙값(Median), 평균(Mean), 3사분위수(3rd Qu.), 최대값(Max.) 등이 포함됩니다.<br>
<br>
1. Sales의 평균은 7.496이다.<br>
: 주어진 sales 변수의 통계 요약에서 'Mean : 7.496'으로 명시되어 있습니다. 이는 Carseats 데이터에 있는 400개 상점의 카시트 판매량(sales)의 평균이 7.496임을 의미합니다.<br>
<br>
2. 약 25%의 카시트에 대한 Sales 값이 5.39보다 작다.<br>
: Sales 변수의 통계 요약에서 '1st Qu. : 5.390'으로 명시되어 있습니다. 1사분위수(1st Quartile)는 전체 데이터 중 하위 25%에 해당하는 값입니다. 즉, 전체 Sales 값의 약 25%가 5.390보다 작거나 같다는 것을 의미합니다.<br>
<br>
3. Price의 최대값은 191.0이다.<br>
: Price 변수의 통계 요약에서 'Max. : 191.0'으로 명시되어 있습니다. 이는 Carseats 데이터에서 카시트 가격(Price)의 최고값이 191.0임을 의미합니다.<br>
<br>
4. 약 25%의 카시트에 대한 Price 값이 131.0보다 작다.<br>
: Price 변수의 통계 요약에서 '3rd Qu. : 131.0'으로 명시되어 있습니다. 3사분위수(3rd Quartile)는 전체 데이터 중 하위 75%에 해당하는 값입니다. 즉, 전체 Price 값의 약 75%가 131.0보다 작거나 같다는 의미입니다. 따라서 "약 25%의 카시트에 대한 Price 값이 131.0보다 작다"는 설명은 잘못된 해석입니다.<br>
<br>
<br>
Price의 1사분위수는 100.0이므로, 약 25%의 카시트에 대한 Price 값이 131.0보다 작다는 설명은 잘못되었습니다. 나머지 선택지는 주어진 데이터와 일치합니다.<br>
<br>
따라서, 정답은 '4. 약 25%의 카시트에 대한 Price 값이 131.0보다 작다.' 입니다.<br>
			</div>
			<div class="t2">
									#평균									# 최대값									# 기초통계량									# r프로그램 결과 해석							</div>
		</div>
		
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">4과목</span>
			<span class="g1">텍스트 마이닝</span>
			<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">66.</span>
			<span class="tt1t1">
				다음 중 TM 패키지 기본 Transformation 함수가 아닌 것은?							</span>
		</strong>
		<span class="tt1t1">
				    </span> 
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			removeNumbers					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			stripWhitespace					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			removePunctuation 					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			stemCompletion					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a66" class="b2 help" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a66" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">4</i>
			<span class="t2t1">
			stemCompletion			</span>
					</div>
        <br>
				<strong class="tt1">해설</strong>
		<div class="t1">
		tm 패키지는 R에서 텍스트 마이닝을 수행할 때 텍스트 데이터를 전처리하고 가공하는 데 사용되는 핵심 도구이다 . tm_map() 함수를 사용하여 말뭉치(Corpus)에 다양한 변환 함수를 적용할 수 있는데, removeNumbers, stripWhitespace, removePunctuation 등은 텍스트를 정제하는 기본적인 변환 함수들이다 . 반면 stemCompletion은 어간 추출(stemming)된 단어를 원형 단어로 복원하거나 완성하는 함수로, 직접적인 텍스트 변환(정제) 기능과는 목적이 다르다.				</div>
		
				
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				정답은 4번입니다.<br>
<br>
TM 패키지는 R에서 텍스트 마이닝을 수행할 때 사용하는 대표적인 패키지이며, 전처리를 위해 다양한 Transformation 함수를 제공합니다. 이들 함수는 tm_map()과 함께 사용되어 말뭉치(Corpus)의 내용을 정제합니다.<br>
<br>
1. removeNumbers<br>
: removeNumbers는 텍스트 데이터에서 모든 숫자를 제거하는 변환 함수입니다. 예를 들어, "abc123"은 "abc"로 변환됩니다. 이는 텍스트 분석에 불필요한 숫자 정보를 제거하여 데이터의 노이즈를 줄이는 데 사용되는 기본적인 전처리 과정입니다.<br>
<br>
2. stripWhitespace<br>
:  stripWhitespace는 텍스트 데이터 내에 존재하는 불필요한 공백(예: 여러 개의 연속된 공백, 탭, 줄 바꿈 등)을 제거하고 하나의 공백으로 통일하는 변환 함수입니다. 텍스트를 깔끔하게 정돈하여 단어 토큰화 등의 후속 작업에 용이하게 만듭니다.<br>
<br>
3. removePunctuation<br>
: removePunctuation은 텍스트 데이터에서 모든 구두점(예: 마침표, 쉼표, 느낌표, 물음표 등)을 제거하는 변환 함수입니다. "안녕하세요!"는 "안녕하세요"로, "데이터, 분석."은 "데이터 분석"으로 변환합니다. 구두점은 단어의 의미에 직접적인 영향을 주지 않으면서 분석을 방해할 수 있기 때문에, 이는 기본적인 텍스트 정제 과정에 해당합니다.<br>
<br>
4. stemCompletion<br>
: stemCompletion은 어간 추출(stemming)을 통해 축약된 단어(어간)를 원래의 완전한 단어로 복원하거나 완성하는 함수입니다. 예를 들어 "comput" 같은 어간을 "computer"나 "computing" 같은 단어로 복원할 때 사용됩니다. 하지만 이 함수는 전처리용 Transformation 함수로는 분류되지 않으며, TM 패키지의 주요 변환 함수 목록에 포함되지 않습니다.<br>
<br>
<br>
TM 패키지의 기본 변환 함수는 주로 텍스트 데이터를 정리하고 불필요한 요소를 제거하는 데 중점을 둡니다. 숫자 제거, 공백 정리, 구두점 제거는 모두 이러한 기본 기능에 포함됩니다. 그러나 어간 복원은 기본적으로 제공되지 않으며, 이는 어간 추출 후 원래 형태로 복원하는 특수한 작업이기 때문입니다.<br>
<br>
따라서, 정답은 '4. stemCompletion' 입니다.<br>
<br>
			</div>
			<div class="t2">
									# 텍스트 마이닝									# 전처리									# TM 패키지									# Transformation 함수									# removeNumbers									# stripWhitespace									# removePunctuation									# stemCompletion							</div>
		</div>
		
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">4과목</span>
			<span class="g1">연관분석</span>
			<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">67.</span>
			<span class="tt1t1">
				다음 중 연관성분석에 활용되는 측정지표 중 전체 거래 중에서 품목 A와 품목 B가 동시에 포함된 거래의 비중을 나타내는 지표는 무엇인가?							</span>
		</strong>
		<span class="tt1t1">
				    </span> 
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			신뢰도					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			향상도					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			지지도					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			빈도					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a67" class="b2 help" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a67" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">3</i>
			<span class="t2t1">
			지지도			</span>
					</div>
        <br>
				<strong class="tt1">해설</strong>
		<div class="t1">
		연관성분석의 측정지표 중 지지도는 전체 거래 중에서 품목 A와 품목 B가 동시에 포함된 거래의 비중을 나타내는 지표이다.				</div>
		
				
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				정답은 3번입니다.<br>
<br>
연관성분석은 데이터베이스에서 상품의 구매 패턴을 분석하여 상품 간의 연관성을 발견하는 기법입니다. 이 분석은 주로 장바구니 분석으로 불리며, 고객이 어떤 상품을 함께 구매하는지를 파악하여 마케팅 전략을 수립하는 데 활용됩니다. 연관성분석의 주요 지표로는 지지도, 신뢰도, 향상도가 있으며, 각각의 지표는 거래 데이터에서 특정 상품 조합의 중요성을 평가하는 데 사용됩니다.<br>
<br>
1. 신뢰도 <br>
: 신뢰도는 특정 상품 A가 구매된 경우, 상품 B도 함께 구매될 확률을 나타내는 지표입니다. 이는 조건부 확률의 개념과 유사하며, A가 구매된 거래 중 B가 포함된 거래의 비율로 계산됩니다. 예를 들어, 우유를 구매한 고객 중 70%가 빵도 구매했다면, 우유와 빵의 신뢰도는 0.7입니다. 신뢰도는 두 상품 간의 강한 연관성을 나타내지만, 전체 거래에서의 비중을 나타내지는 않습니다.<br>
<br>
2. 향상도 <br>
: 향상도는 두 상품 간의 연관성이 우연에 의한 것인지, 실제로 의미 있는 것인지를 평가하는 지표입니다. 이는 신뢰도를 전체 거래에서 B가 구매될 확률로 나눈 값으로 계산됩니다. 향상도가 1보다 크면 두 상품 간의 연관성이 우연이 아님을 의미합니다. 예를 들어, 우유와 빵의 향상도가 1.5라면, 우유를 구매할 때 빵을 구매할 확률이 1.5배 더 높다는 것을 의미합니다.<br>
<br>
3. 지지도 <br>
: 지지도는 전체 거래 중에서 특정 상품 조합이 포함된 거래의 비율을 나타내는 지표입니다. 이는 A와 B가 동시에 구매된 거래 수를 전체 거래 수로 나눈 값으로 계산됩니다. 예를 들어, 전체 100건의 거래 중 20건에서 우유와 빵이 함께 구매되었다면, 지지도는 0.2입니다. 지지도는 두 상품이 함께 구매되는 빈도를 나타내며, 마케팅 전략 수립에 중요한 역할을 합니다.<br>
<br>
4. 빈도 <br>
: 빈도는 특정 상품이나 상품 조합이 얼마나 자주 발생하는지를 나타내는 단순한 횟수입니다. 이는 비율이 아닌 절대적인 수치로, 예를 들어 우유가 50번 구매되었다면 빈도는 50입니다. 빈도는 거래의 비중을 나타내지 않으며, 연관성분석의 주요 지표로 사용되지 않습니다.<br>
<br>
지지도는 전체 거래 중에서 특정 항목 집합이 동시에 발생하는 비율을 나타내므로, 문제에서 요구하는 두 항목이 동시에 포함된 거래의 비중을 측정하는 지표에 해당합니다. 다른 선택지들은 각각 다른 개념을 설명하고 있어 문제의 요구와 일치하지 않습니다.<br>
<br>
따라서, 정답은 '3. 지지도' 입니다.<br>
			</div>
			<div class="t2">
									#연관성분석									# 지지도									# 신뢰도									# 향상도									# 장바구니 분석							</div>
		</div>
		
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">4과목</span>
			<span class="g1">통계분석의 이해</span>
			<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">68.</span>
			<span class="tt1t1">
				다음 중 관찰대상이 가지고 있는 속성의 크기를 측정하여 순서대로 대상의 순위를 나타내는 척도로 적절한 것은?							</span>
		</strong>
		<span class="tt1t1">
				    </span> 
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			명목척도					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			순서척도					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			구간척도					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			비율척도					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a68" class="b2 help" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a68" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">2</i>
			<span class="t2t1">
			순서척도			</span>
					</div>
        <br>
				<strong class="tt1">해설</strong>
		<div class="t1">
		순서척도는 측정 대상의 서열관계를 관측하는 척도이다. 예로는 만족도, 선호도, 학년, 신용등급 등이 있다.				</div>
		
				
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				정답은 2번입니다.<br>
<br>
데이터를 측정하는 방법에는 여러 가지가 있으며, 측정의 특성에 따라 척도(Scale)의 종류가 달라집니다. 척도는 크게 명목, 순서, 구간, 비율 척도로 나눌 수 있으며, 각 척도는 측정값에 대한 다른 수준의 정보를 제공합니다.<br>
<br>
1. 명목척도<br>
: 명목척도는 측정 대상의 속성을 단순히 분류하거나 식별하기 위해 숫자를 부여하는 척도입니다. 측정값들 사이에 순서나 크기의 의미가 없으며, 단지 범주를 구분하는 데 사용됩니다. 예를 들어, 성별(남성=1, 여성=2), 혈액형(A형=1, B형=2, AB형=3, O형=4), 종교 등이 명목척도에 해당합니다. 숫자는 단순한 코드일 뿐, 2가 1보다 크다거나 4가 1의 4배라는 의미는 없습니다.<br>
<br>
2. 순서척도<br>
: 순서척도는 측정 대상의 속성을 분류할 뿐만 아니라, 그 속성의 크기에 따라 순서를 부여할 수 있는 척도입니다. 즉, 측정값들 사이에 대소 관계나 순위가 존재하지만, 값들 간의 간격이 일정하다고 볼 수는 없습니다. 예를 들어, 학점(A, B, C, D, F), 만족도(매우 만족, 만족, 보통, 불만족, 매우 불만족), 석차(1등, 2등, 3등) 등이 순서척도에 해당합니다. 1등이 2등보다 우수하다는 것은 알 수 있지만, 1등과 2등의 차이가 2등과 3등의 차이와 동일하다고는 할 수 없습니다. <br>
<br>
3. 구간척도<br>
: 구간척도는 순서척도의 특성을 가지면서, 측정값들 간의 간격이 일정한 척도입니다. 즉, 측정값들 사이의 차이를 비교할 수 있습니다. 그러나 절대적인 0점(True Zero Point)이 존재하지 않아 비율 계산은 불가능합니다. 예를 들어, 온도(섭씨, 화씨), IQ 지수, 연도 등이 구간척도에 해당합니다. 섭씨 20도와 10도의 차이가 10도이고, 10도와 0도의 차이도 10도이지만, 섭씨 0도가 '온도가 전혀 없음'을 의미하지는 않습니다.<br>
<br>
4. 비율척도<br>
: 비율척도는 구간척도의 특성을 모두 가지면서, 절대적인 0점(True Zero Point)이 존재하는 척도입니다. 따라서 측정값들 간의 차이뿐만 아니라 비율까지도 의미 있게 비교할 수 있습니다. 예를 들어, 길이, 무게, 나이, 소득, 판매량 등이 비율척도에 해당합니다. 키 180cm는 90cm의 두 배라고 말할 수 있으며, 0kg은 '무게가 전혀 없음'을 의미합니다.<br>
<br>
<br>
순서척도는 대상을 순서대로 배열할 수 있는 척도로, 문제에서 요구하는 '순위를 나타내는 척도'에 적합합니다. 명목척도는 순서를 나타낼 수 없고, 구간척도와 비율척도는 순서뿐만 아니라 차이와 비율을 측정할 수 있어 문제의 요구와 다릅니다.<br>
<br>
따라서, 정답은 '2. 순서척도' 입니다.<br>
			</div>
			<div class="t2">
									# 순서척도									# 명목척도									# 구간척도									# 비율척도									# 척도									# 속성의 크기							</div>
		</div>
		
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">4과목</span>
			<span class="g1">사회연결망 분석</span>
			<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">69.</span>
			<span class="tt1t1">
				다음 중 사회 연결망 분석시 위세 중심성에 대한 설명으로 가장 적절한 것은? 							</span>
		</strong>
		<span class="tt1t1">
				    </span> 
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			한 노드에 직접적으로 연결된 노드들의 합으로 측정한다.					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			연결된 노드의 중요성에 가중치를 둬 중심성을 측정하는 방법이다.					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			네트워크 내에서 한 노드가 담당하는 매개자 혹은 중계자 역할의 정도를 측정하기 위한 평가지표이다.					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			한 노드에 직접적으로 연결된 노드 뿐만 아니라 간접적으로 연결된 노드들 간의 거리를 계산하여 측정한다.					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a69" class="b2 help" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a69" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">2</i>
			<span class="t2t1">
			연결된 노드의 중요성에 가중치를 둬 중심성을 측정하는 방법이다.			</span>
					</div>
        <br>
				<strong class="tt1">해설</strong>
		<div class="t1">
		위세 중심성은 자신의 연결정도를 중심성으로부터 발생하는 영향력과 자신과 연결된 타인의 영향력을 합하여 결정한다. 보나시치 권력지수는 위세 중심성의 일반적인 형태이며, 연결된 노드의 중요성에 가중치를 둬 노드의 중심성을 측정하는 방법이다.				</div>
		
				
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				정답은 2번입니다.<br>
<br>
위세 중심성은 네트워크 분석에서 특정 노드의 중요성을 평가하는 지표로, 연결된 노드의 중요성에 따라 가중치를 부여하여 중심성을 측정합니다. 이는 단순히 연결된 노드의 수를 세는 것이 아니라, 연결된 노드들이 얼마나 중요한지를 고려하여 중심성을 평가하는 방법입니다.<br>
<br>
1. 한 노드에 직접적으로 연결된 노드들의 합으로 측정한다.<br>
: 이 설명은 연결 중심성에 대한 설명으로, 한 노드에 직접적으로 연결된 노드들의 수를 세어 중심성을 측정하는 방법입니다.<br>
<br>
2. 연결된 노드의 중요성에 가중치를 둬 중심성을 측정하는 방법이다.<br>
: 이 설명은 위세 중심성에 대한 정확한 설명으로, 연결된 노드의 중요성에 가중치를 두어 중심성을 측정하는 방법입니다.<br>
<br>
3. 네트워크 내에서 한 노드가 담당하는 매개자 혹은 중계자 역할의 정도를 측정하기 위한 평가지표이다.<br>
: 이 설명은 매개 중심성에 대한 설명으로, 네트워크 내에서 한 노드가 다른 노드들 간의 중계자 역할을 얼마나 잘 수행하는지를 측정하는 지표입니다.<br>
<br>
4. 한 노드에 직접적으로 연결된 노드 뿐만 아니라 간접적으로 연결된 노드들 간의 거리를 계산하여 측정한다.<br>
: 이 설명은 근접 중심성에 대한 설명으로, 한 노드가 네트워크 내 다른 노드들과 얼마나 가까운지를 측정하는 방법입니다.<br>
<br>
<br>
위세 중심성은 연결된 노드의 중요성에 가중치를 두어 중심성을 측정하는 방법이므로, 정답은 2번입니다. 1번은 연결 중심성, 3번은 매개 중심성, 4번은 근접 중심성에 대한 설명입니다.<br>
<br>
따라서, 정답은 '2. 연결된 노드의 중요성에 가중치를 둬 중심성을 측정하는 방법이다.' 입니다.<br>
			</div>
			<div class="t2">
									#위세 중심성									# 연결 중심성									# 매개 중심성									# 근접 중심성							</div>
		</div>
		
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">4과목</span>
			<span class="g1">R 기초</span>
			<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">70.</span>
			<span class="tt1t1">
				다음 중 mtcars 데이터에서 gear와 carb 관측치를 제거하고 난 후의 데이터셋을 구성하는 R 코드로 가장 부적절한 것은?							</span>
		</strong>
		<span class="tt1t1">
						<a href="exam1view1img1.php?img=0037e4bf-b755-4193-a130-914a47d644ab.png" target="_blank" rel="noopener" title="새 창" class="p1">
				<img src="/data/img/question/0037e4bf-b755-4193-a130-914a47d644ab.png" alt="문제에 포함된 이미지">
			</a>
				    </span> 
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			mtcars[,1:9] 					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			mtcars[,-c(10,11)] 					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			mtcars[,10:11] 					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			mtcars[,c(1:9)]					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a70" class="b2 help" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a70" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">3</i>
			<span class="t2t1">
			mtcars[,10:11] 			</span>
					</div>
        <br>
				<strong class="tt1">해설</strong>
		<div class="t1">
		③번의 내용은 10, 11열만 선택한다는 것으로 틀린 답이다.				</div>
		
				
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				정답은 3번입니다.<br>
<br>
이 문제는 R 프로그래밍에서 데이터프레임의 특정 열을 제거하는 방법에 대한 이해를 평가합니다. mtcars 데이터셋에서 gear와 carb 열을 제거하려면 해당 열의 인덱스를 사용하여 제외해야 합니다.<br>
<br>
1. mtcars[,1:9]<br>
: 이 방법은 데이터프레임의 첫 번째부터 아홉 번째 열까지 선택하여 gear와 carb 열을 제거하는 올바른 방법입니다.<br>
<br>
2. mtcars[,-c(10,11)]<br>
: 이 방법은 열의 인덱스를 음수로 지정하여 해당 열을 제외하는 방식으로, gear와 carb 열을 정확히 제거합니다.<br>
<br>
3. mtcars[,10:11]<br>
: 이 방법은 gear와 carb 열만 선택하여 남기는 방식으로, 문제의 요구와 반대되는 결과를 초래합니다.<br>
<br>
4. mtcars[,c(1:9)]<br>
: 이 방법은 첫 번째부터 아홉 번째 열까지 선택하여 gear와 carb 열을 제거하는 올바른 방법입니다.<br>
<br>
<br>
세 번째 선택지는 gear와 carb 열만 남기고 나머지를 제거하는 코드로, 문제의 요구와 반대되는 결과를 초래합니다. 다른 선택지들은 gear와 carb 열을 제거하는 올바른 방법을 사용하고 있습니다.<br>
<br>
따라서, 정답은 '3. mtcars[,10:11]' 입니다.<br>
			</div>
			<div class="t2">
									#R 프로그래밍									# 데이터프레임									# 열 제거									# mtcars							</div>
		</div>
		
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">5과목</span>
			<span class="g1">시각화 인사이트 프로세스의 의미</span>
			<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">71.</span>
			<span class="tt1t1">
				시각화 인사이트 프로세스에 해당하지 않는 단계는?							</span>
		</strong>
		<span class="tt1t1">
				    </span> 
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			탐색					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			조사					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			분석					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			활용					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a71" class="b2 help" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a71" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">2</i>
			<span class="t2t1">
			조사			</span>
					</div>
        <br>
				<strong class="tt1">해설</strong>
		<div class="t1">
		시각화 인사이트 프로세스는 탐색(1단계), 분석(2단계), 활용(3단계)이다.				</div>
		
				
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				정답은 2번입니다.<br>
<br>
시각화 인사이트 프로세스는 데이터를 효과적으로 이해하고 전달하기 위한 일련의 단계로 구성됩니다. 이 과정은 데이터를 탐색하고, 분석하며, 결과를 활용하는 것을 포함합니다. 각 단계는 데이터의 의미를 파악하고, 이를 통해 인사이트를 도출하는 데 중요한 역할을 합니다.<br>
<br>
1. 탐색<br>
: 데이터 탐색은 시각화 인사이트 프로세스의 초기 단계로, 데이터를 이해하고 패턴이나 이상치를 식별하는 데 중점을 둡니다. 이 단계에서는 데이터의 구조와 특성을 파악하여 이후 분석을 위한 기초를 마련합니다.<br>
<br>
2. 조사<br>
: 조사는 일반적으로 시각화 인사이트 프로세스의 단계로 포함되지 않습니다. 조사는 데이터를 수집하거나 정보를 찾는 과정으로, 시각화 인사이트 프로세스의 다른 단계와는 구분됩니다.<br>
<br>
3. 분석<br>
: 분석은 데이터를 깊이 있게 이해하고, 통계적 방법이나 알고리즘을 사용하여 의미 있는 정보를 추출하는 과정입니다. 이 단계는 데이터에서 인사이트를 도출하는 데 핵심적인 역할을 합니다.<br>
<br>
4. 활용<br>
: 활용은 분석 결과를 실제 의사결정이나 문제 해결에 적용하는 단계입니다. 이 단계에서는 도출된 인사이트를 바탕으로 전략을 수립하거나 실행 계획을 세웁니다.<br>
<br>
<br>
조사는 시각화 인사이트 프로세스의 단계로 포함되지 않으며, 데이터 수집이나 정보 탐색과 관련된 활동입니다. 반면, 탐색, 분석, 활용은 시각화 인사이트 프로세스의 필수적인 단계로, 각각 데이터 이해, 정보 추출, 결과 적용에 중점을 둡니다.<br>
<br>
따라서, 정답은 '2. 조사' 입니다.<br>
			</div>
			<div class="t2">
									#탐색									# 조사									# 분석									# 활용							</div>
		</div>
		
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">5과목</span>
			<span class="g1">탐색(1단계)</span>
			<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">72.</span>
			<span class="tt1t1">
				아래 그림과 같은 데이터 시각화를 사용하는 단계에 대한 설명으로 가장 부적절한 것은?							</span>
		</strong>
		<span class="tt1t1">
						<a href="exam1view1img1.php?img=7d86a9f7-869c-51b7-c1d1-34269a746ce6.gif" target="_blank" rel="noopener" title="새 창" class="p1">
				<img src="/data/img/question/7d86a9f7-869c-51b7-c1d1-34269a746ce6.gif" alt="문제에 포함된 이미지">
			</a>
				    </span> 
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			계층 관계를 갖는 데이터나, 어떤 기준으로 묶인 데이터의 대부분은 형태를 변환해 연결 고리를 찾아낼 수 있다.					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			여러 개의 데이터 명세를 보유한 경우, 연결 고리를 확인함으로써 명세들을 포괄해 탐색할 수 있는 차원과 측정값의 조합을 정리해야 한다.					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			척도 문제가 발생하는 경우에는 실제 값을 변형해, 같은 공간에 표시해도 각각의 패턴이 명확하게 보이게끔 조정해야 한다.					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			지표를 시각화 도구에 적용할 때에도 역시 지표의 단위가 시각화 도구의 표현 공간상에 다른 데이터들과 함께 적절하게 표현될 수 있는지 체크해야 한다.					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a72" class="b2 help" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a72" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">4</i>
			<span class="t2t1">
			지표를 시각화 도구에 적용할 때에도 역시 지표의 단위가 시각화 도구의 표현 공간상에 다른 데이터들과 함께 적절하게 표현될 수 있는지 체크해야 한다.			</span>
					</div>
        <br>
				<strong class="tt1">해설</strong>
		<div class="t1">
		워들은 탐색 단계에서 비정형 데이터(텍스트 데이터) 측정값에서 관계를 탐색하기 위해 사용하는 시각화이다. ④번은 분석단계에 대한 설명이다.				</div>
		
				
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				문제는 워들에 대한 그림입니다. 워들은 탐색 단계에서 비정형 데이터(텍스트 데이터) 측정값에서 관계를 탐색하기 위해 사용되는 단계입니다.<br>
<br>
보기 1번,3번은 탐색 단계에 대해 옳게 설명하고 있으며, 보기 4번은 분석 단계에 대한 설명입니다.<br>
			</div>
			<div class="t2">
									# 데이터 시각화									# 워들									# 탐색									# 분석							</div>
		</div>
		
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">5과목</span>
			<span class="g1">분석 도구를 이용한 시각화 구현 : R</span>
			<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">73.</span>
			<span class="tt1t1">
				아래 그림은 분석 도구를 이용해 시각화를 구현한 것이다. 그 과정에서 사용된 명령어로 가장 적절한 것은? (단, /는 enter의 의미로 작성되었다.)							</span>
		</strong>
		<span class="tt1t1">
						<a href="exam1view1img1.php?img=2025ADP_MO01_73.jpg" target="_blank" rel="noopener" title="새 창" class="p1">
				<img src="/data/img/question/2025ADP_MO01_73.jpg" alt="문제에 포함된 이미지">
			</a>
				    </span> 
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			ggplot(ChickWeight, aes(x=Time, y=weight, colour=Diet, group=Chick)) + geom_line( ) 					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			ggplot(subset(ChickWeight, Time==21), aes(x=weight, colour=Diet)) + geom_density( ) 					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			b &lt;- ggplot(economics, aes(x=date, y=unemploy)) / b + geom_line( )					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			w &lt;- ggplot(diamonds, aes(clarity, fill=cut)) / w + geom_bar( )					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a73" class="b2 help" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a73" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">1</i>
			<span class="t2t1">
			ggplot(ChickWeight, aes(x=Time, y=weight, colour=Diet, group=Chick)) + geom_line( ) 			</span>
					</div>
        <br>
				<strong class="tt1">해설</strong>
		<div class="t1">
		ggplot(ChickWeight, aes(x=Time, y=weight, colour=Diet, group=Chick)) + geom_line( )이 정답이다.				</div>
		
				
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				1. 적절한 설명입니다. 이 명령어는 ChickWeight 데이터셋을 사용하여 시간(Time)과 무게(weight)를 x축과 y축으로, 색상(colour)으로 Diet를, 그룹(group)으로 Chick을 지정하여 각 병아리의 체중 변화를 시간에 따라 선 그래프로 그립니다. 주어진 그림과 일치합니다.<br>
<br>
2. 부적절한 설명입니다. 이 명령어는 특정 시간(Time==21)에서 병아리의 체중 분포를 밀도 그래프로 나타내는 것입니다. 주어진 그림은 시간에 따른 체중 변화를 선 그래프로 나타내고 있기 때문에 이 설명은 적절하지 않습니다.<br>
<br>
3. 부적절한 설명입니다. 이 명령어는 economics 데이터셋을 사용하여 날짜(date)와 실업자 수(unemploy)를 선 그래프로 나타내는 것입니다. 주어진 그림과 관련이 없습니다.<br>
<br>
4. 부적절한 설명입니다. 이 명령어는 diamonds 데이터셋을 사용하여 클리어티(clarity)와 컷(cut)을 막대 그래프로 나타내는 것입니다. 주어진 그림과 관련이 없습니다.<br>
			</div>
			<div class="t2">
									# ggplot									# R 코드 해석							</div>
		</div>
		
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">5과목</span>
			<span class="g1">시각화 프로세스</span>
			<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">74.</span>
			<span class="tt1t1">
				빅데이터 시각화 프로세스에 대한 설명으로 가장 부적절한 것은?							</span>
		</strong>
		<span class="tt1t1">
				    </span> 
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			구조화에서는 빅데이터에서 제공하는 데이터를 활용하여 사전 작업을 하면서 시각화의 목표가 될만한 것들을 발견하고 설정하기도 한다.					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			시각화에서는 시각화 툴에서 제공하 는 다양 한 그래프를 어떤 이유로, 왜 쓰는지, 어떻게 표현해야 하는지에 대해 설명하고자 한다.					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			표현 및 정제 단계에서는 그래픽 능력이 요구되며, 이 단계가 바로 직접적인 시각 표현 단계라 볼 수 있다.					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			시각표현에서는 시각화 툴로 선택한 그래프를 시각적으로 더 다 듬거나 시각 표현을 극대화하는 방안을 실험하면서 완성하게 된다.					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a74" class="b2 help" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a74" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">3</i>
			<span class="t2t1">
			표현 및 정제 단계에서는 그래픽 능력이 요구되며, 이 단계가 바로 직접적인 시각 표현 단계라 볼 수 있다.			</span>
					</div>
        <br>
				<strong class="tt1">해설</strong>
		<div class="t1">
		벤프라이의 7단계 방법론 중 5단계 표현, 6단계 정제에 대한 설명이다.				</div>
		
				
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				정답은 3번입니다.<br>
<br>
빅데이터 시각화는 데이터를 효과적으로 전달하기 위해 정보 구조화, 정보 시각화, 정보 시각 표현의 3단계로 진행됩니다. 정보 구조화 단계에서는 데이터를 수집하고 분류하여 시각화의 목표를 설정합니다. 정보 시각화 단계에서는 다양한 시각화 툴을 활용하여 데이터를 그래프 등으로 표현하는 방법을 익힙니다. 마지막으로 정보 시각 표현 단계에서는 그래픽적 요소를 추가하여 시각적 완성도를 높입니다. 각 단계는 데이터의 특성과 전달하고자 하는 메시지에 따라 적절히 적용되어야 합니다.<br>
<br>
1. 구조화에서는 빅데이터에서 제공하는 데이터를 활용하여 사전 작업을 하면서 시각화의 목표가 될만한 것들을 발견하고 설정하기도 한다. <br>
: 정보 구조화 단계에서는 데이터를 수집하고 분류하여 시각화의 목표를 설정합니다. 이 단계는 시각화의 방향성을 결정하는 중요한 단계로, 데이터를 어떻게 활용할지에 대한 계획을 세우는 것이 핵심입니다. 예를 들어, 고객 데이터를 분석하여 구매 패턴을 시각화하고자 할 때, 먼저 데이터를 수집하고 분류하여 어떤 패턴을 시각화할지 결정합니다.<br>
<br>
2. 시각화에서는 시각화 툴에서 제공하 는 다양 한 그래프를 어떤 이유로, 왜 쓰는지, 어떻게 표현해야 하는지에 대해 설명하고자 한다. <br>
: 정보 시각화 단계에서는 다양한 시각화 툴을 활용하여 데이터를 그래프 등으로 표현합니다. 이 단계에서는 각 그래프의 특성과 쓰임새를 이해하는 것이 중요합니다. 예를 들어, 시간의 흐름에 따른 변화를 보여주기 위해서는 선 그래프를, 카테고리별 비교를 위해서는 막대 그래프를 사용하는 것이 적절합니다.<br>
<br>
3. 표현 및 정제 단계에서는 그래픽 능력이 요구되며, 이 단계가 바로 직접적인 시각 표현 단계라 볼 수 있다. <br>
: 표현 및 정제 단계는 시각적 표현을 다듬고 완성하는 단계로, 그래픽적 능력이 요구됩니다. 그러나 이 단계는 직접적인 시각 표현 단계가 아니라, 시각화 결과물을 더욱 매끄럽고 효과적으로 전달하기 위한 보완 작업에 가깝습니다. 따라서 직접적인 시각 표현 단계로 보기에는 부적절합니다.<br>
<br>
4. 시각표현에서는 시각화 툴로 선택한 그래프를 시각적으로 더 다 듬거나 시각 표현을 극대화하는 방안을 실험하면서 완성하게 된다. <br>
: 시각 표현 단계에서는 선택한 그래프를 시각적으로 다듬고, 시각 표현을 극대화하는 방안을 실험합니다. 이 단계에서는 색상, 타이포그래피, 레이아웃 등 다양한 그래픽 요소를 활용하여 시각적 완성도를 높입니다. 예를 들어, 중요한 데이터 포인트를 강조하기 위해 색상을 다르게 사용하거나, 그래프의 레이아웃을 조정하여 가독성을 높일 수 있습니다.<br>
<br>
선지 3은 표현 및 정제 단계가 직접적인 시각 표현 단계라고 설명하고 있지만, 실제로는 시각화 결과물을 보완하고 다듬는 단계입니다. 따라서 직접적인 시각 표현 단계로 보기에는 부적절합니다. 다른 선지들은 각각의 단계에 맞는 설명을 하고 있어 적절합니다.<br>
따라서, 정답은 '3. 표현 및 정제 단계에서는 그래픽 능력이 요구되며, 이 단계가 바로 직접적인 시각 표현 단계라 볼 수 있다.' 입니다.<br>
			</div>
			<div class="t2">
									#정보 구조화									# 정보 시각화									# 정보 시각 표현									# 그래픽 요소									# 시각화 목표							</div>
		</div>
		
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">5과목</span>
			<span class="g1">시각화 프로세스</span>
			<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">75.</span>
			<span class="tt1t1">
				벤 프라이의 7단계 방법론 중에서 정보 디자인 교과서의 ‘데이터 수집/마이닝’과 연관이 없는 단계는?							</span>
		</strong>
		<span class="tt1t1">
				    </span> 
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			분석					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			선별					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			상호작용					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			마이닝					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a75" class="b2 help" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a75" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">3</i>
			<span class="t2t1">
			상호작용			</span>
					</div>
        <br>
				<strong class="tt1">해설</strong>
		<div class="t1">
		데이터 수집/ 마이닝'과 연관이 있는 것은 정보 획득, 분석, 선별, 마이닝이며, 상호작용의 경우에는 그래프 가공, 시각적 표현과 연관이 있다.				</div>
		
				
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				정답은 3번입니다.<br>
<br>
벤 프라이의 7단계 방법론은 데이터 시각화의 전 과정을 체계적으로 설명하는 방법론입니다. 이 방법론은 데이터를 수집하고, 이를 분석하여 시각적으로 표현하는 과정을 단계별로 나누어 설명합니다. 각 단계는 정보 획득(Acquire), 분해(Parse), 선별(Filter), 마이닝(Mine), 표현(Represent), 정제(Refine), 상호작용(Interact)으로 구성되어 있습니다. 이 중 '데이터 수집/마이닝'과 직접적으로 연관된 단계는 주로 데이터를 수집하고 분석하는 초기 단계들입니다.<br>
<br>
1. 분석 <br>
: 분석은 데이터를 깊이 있게 이해하고, 그로부터 의미 있는 정보를 도출하는 과정입니다. 이는 데이터 마이닝과 밀접한 관련이 있으며, 데이터를 수집한 후 이를 해석하고 패턴을 찾는 데 중점을 둡니다. 따라서 '데이터 수집/마이닝'과 관련이 있습니다.<br>
<br>
2. 선별 <br>
: 선별은 수집된 데이터 중에서 의미 있는 정보를 추출하고 불필요한 데이터를 제거하는 과정입니다. 이는 데이터 수집 후 데이터를 정제하는 과정으로, 데이터 마이닝의 일부로 볼 수 있습니다. 따라서 '데이터 수집/마이닝'과 관련이 있습니다.<br>
<br>
3. 상호작용 <br>
: 상호작용은 사용자가 데이터 시각화 결과와 상호작용할 수 있도록 하는 단계입니다. 이는 데이터의 표현 이후에 이루어지는 과정으로, 데이터 수집이나 마이닝과는 직접적인 관련이 없습니다. 따라서 '데이터 수집/마이닝'과 관련이 없습니다.<br>
<br>
4. 마이닝 <br>
: 마이닝은 데이터를 분석하여 유의미한 패턴이나 정보를 추출하는 과정입니다. 이는 데이터 수집 후 데이터를 심층적으로 분석하는 과정으로, '데이터 수집/마이닝'과 직접적으로 관련이 있습니다.<br>
<br>
상호작용 단계는 데이터 시각화의 결과를 사용자가 직접 조작하거나 탐색할 수 있도록 하는 과정입니다. 이는 데이터의 수집이나 마이닝과는 다른, 시각화의 최종 단계에 해당합니다. 따라서 '데이터 수집/마이닝'과 관련이 없는 단계로, 정답은 '상호작용'입니다. 나머지 선지들은 모두 데이터 수집과 마이닝 과정에 포함되거나 관련이 있습니다.<br>
따라서, 정답은 '3. 상호작용' 입니다.<br>
			</div>
			<div class="t2">
									#벤 프라이									# 7단계 방법론									# 데이터 수집									# 마이닝									# 상호작용									# 시각화							</div>
		</div>
		
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">5과목</span>
			<span class="g1">분석 도구를 이용한 시각화 구현 : R</span>
			<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">76.</span>
			<span class="tt1t1">
				다음 보기 프로그램의 그래프의 cut종류는 어디에 표시되는가?					
					<span class="tt1t1">
						k &lt;- ggplot(diamonds, aes(carat, ..density..)) + geom_histogram(binwidth = 0.2) <br>
k + facet_grid(. , cut)					</span>
							</span>
		</strong>
		<span class="tt1t1">
				    </span> 
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			아래					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			위					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			좌					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			우					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a76" class="b2 help" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a76" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">2</i>
			<span class="t2t1">
			위			</span>
					</div>
        <br>
				<strong class="tt1">해설</strong>
		<div class="t1">
		(. , cut)를 사용할 경우 caret 종류는 위에 표시된다.				</div>
		
				
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				정답은 2번입니다.<br>
<br>
ggplot2 패키지의 facet_grid() 함수는 데이터를 여러 개의 패널로 나누어 시각화할 수 있도록 도와줍니다. 이 함수는 두 개의 변수에 따라 데이터를 분할하여 각각의 패널에 그래프를 그립니다. facet_grid()의 인수로는 행과 열을 지정할 수 있으며, '.'를 사용하여 특정 방향으로의 분할을 생략할 수 있습니다. 예를 들어, facet_grid(. ~ cut)는 cut 변수를 기준으로 열 방향으로 패널을 나누는 것을 의미합니다. 이는 데이터의 특정 범주를 시각적으로 비교하는 데 유용합니다.<br>
<br>
1. 아래 <br>
: facet_grid() 함수에서 '.'는 행 또는 열을 생략할 때 사용됩니다. 이 경우, '.'가 행에 위치하므로 행 방향으로는 패널이 나뉘지 않습니다. 따라서, cut 변수는 행 방향이 아닌 다른 방향에 표시됩니다.<br>
<br>
2. 위 <br>
: facet_grid(. ~ cut)에서 cut 변수는 열 방향으로 패널을 나누는 역할을 합니다. 따라서, 각 패널은 cut 변수의 각 범주에 해당하며, 그래프의 위쪽에 cut 범주가 표시됩니다. 이는 데이터의 범주별 비교를 쉽게 할 수 있도록 도와줍니다.<br>
<br>
3. 좌 <br>
: facet_grid() 함수에서 행 방향으로 패널을 나누려면 'cut ~ .'와 같이 사용해야 합니다. 그러나 문제에서는 '. ~ cut'로 되어 있어, cut 변수는 열 방향으로 나뉘며, 좌측에 표시되지 않습니다.<br>
<br>
4. 우 <br>
: facet_grid() 함수에서 열 방향으로 패널을 나누는 경우, cut 변수는 그래프의 우측이 아닌 위쪽에 표시됩니다. 따라서, cut 범주는 우측에 나타나지 않습니다.<br>
<br>
facet_grid(. ~ cut)에서 cut 변수는 열 방향으로 패널을 나누는 역할을 하며, 각 패널의 위쪽에 cut 범주가 표시됩니다. 이는 데이터의 범주별 비교를 쉽게 할 수 있도록 도와줍니다. 다른 선택지들은 facet_grid() 함수의 사용법에 맞지 않으며, cut 변수가 해당 위치에 표시되지 않습니다.<br>
따라서, 정답은 '2. 위' 입니다.<br>
			</div>
			<div class="t2">
									#ggplot2									# facet_grid									# 패널 분할									# 데이터 시각화									# 범주 비교							</div>
		</div>
		
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">5과목</span>
			<span class="g1">빅데이터와 시각화 디자인</span>
			<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">77.</span>
			<span class="tt1t1">
				시각화 및 빅데이터 시각화에 대한 설명으로 가장 부적절한 것은?							</span>
		</strong>
		<span class="tt1t1">
				    </span> 
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			정보성을 낮출수록 좀 더 효율적이고 참신한 시각화의 아름다움을 얻을 수 있다.					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			빅데이터의 시각화에서 중요한 것은 해당 데이터를 다루는 능력말고도 궁극적으로는 정보 디자인의 의도와 방향이 목적과 어긋나지 않도록 하는 것이다.					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			시각화 전문가로서 첫 번째 단계는 개인의 능력을 통해 최신의 기술과 도구를 사용해 정보를 제시하고 분석하는 것이다.					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			두 번째 단계는 데이터 시각화 기술이 아니라 비주얼 인식의 심리적인 부분을 아는 것으로, 특정 시각화 기술이 줄 수 있는 한계에 대해서도 충분히 이해해야 한다.					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a77" class="b2 help" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a77" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">1</i>
			<span class="t2t1">
			정보성을 낮출수록 좀 더 효율적이고 참신한 시각화의 아름다움을 얻을 수 있다.			</span>
					</div>
        <br>
				<strong class="tt1">해설</strong>
		<div class="t1">
		시각화의 아름다움에서 정보성이 결여된다면 효율성과 참신성이 떨어지는 문제가 발생할 수 있다.				</div>
		
				
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				정답은 1번입니다.<br>
<br>
시각화와 빅데이터 시각화는 데이터를 효과적으로 전달하기 위한 중요한 도구입니다. 시각화는 단순히 데이터를 보기 좋게 만드는 것이 아니라, 정보를 명확하고 이해하기 쉽게 전달하는 것이 목적입니다. 특히 빅데이터 시각화에서는 방대한 양의 데이터를 효율적으로 처리하고, 이를 통해 유의미한 인사이트를 도출하는 것이 중요합니다.<br>
<br>
1. 정보성을 낮출수록 좀 더 효율적이고 참신한 시각화의 아름다움을 얻을 수 있다.<br>
: 시각화의 목적은 정보를 명확하게 전달하는 것입니다. 정보성을 낮추면 시각화의 본래 목적을 잃게 되어, 효율적이지 않으며 참신함도 오히려 떨어질 수 있습니다. 따라서 정보성을 낮추는 것은 바람직하지 않습니다.<br>
<br>
2. 빅데이터의 시각화에서 중요한 것은 해당 데이터를 다루는 능력말고도 궁극적으로는 정보 디자인의 의도와 방향이 목적과 어긋나지 않도록 하는 것이다.<br>
: 빅데이터 시각화에서는 데이터 처리 능력뿐만 아니라, 정보 디자인의 의도와 방향이 중요합니다. 이는 시각화가 전달하고자 하는 메시지가 명확하고 일관되게 전달되도록 하는 데 필수적입니다.<br>
<br>
3. 시각화 전문가로서 첫 번째 단계는 개인의 능력을 통해 최신의 기술과 도구를 사용해 정보를 제시하고 분석하는 것이다.<br>
: 시각화 전문가로서 최신 기술과 도구를 활용하여 정보를 제시하고 분석하는 것은 기본적인 능력입니다. 이는 시각화의 정확성과 효율성을 높이는 데 기여합니다.<br>
<br>
4. 두 번째 단계는 데이터 시각화 기술이 아니라 비주얼 인식의 심리적인 부분을 아는 것으로, 특정 시각화 기술이 줄 수 있는 한계에 대해서도 충분히 이해해야 한다.<br>
: 데이터 시각화에서는 기술적인 부분뿐만 아니라, 시각적 인식의 심리적 요소도 중요합니다. 이는 특정 시각화 기술의 한계를 이해하고, 이를 보완할 수 있는 방법을 찾는 데 도움이 됩니다.<br>
<br>
<br>
시각화의 본질은 정보를 명확하게 전달하는 것입니다. 정보성을 낮추는 것은 시각화의 목적에 부합하지 않으며, 오히려 비효율적일 수 있습니다. 다른 선택지들은 시각화의 목적과 방법에 대해 적절하게 설명하고 있습니다.<br>
<br>
따라서, 정답은 '1. 정보성을 낮출수록 좀 더 효율적이고 참신한 시각화의 아름다움을 얻을 수 있다.' 입니다.<br>
			</div>
			<div class="t2">
									#시각화									# 빅데이터									# 정보 디자인									# 시각적 인식							</div>
		</div>
		
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">5과목</span>
			<span class="g1">라이브러리 기반의 시각화 구현 : D3.js</span>
			<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">78.</span>
			<span class="tt1t1">
				라이브러리를 기반으로 다양한 목적의 시각화 그래프를 구현하고자 한다. 각각의 시각화를 구현할 때 작성될 수 있는 명령어로 가장 적절한 것은?							</span>
		</strong>
		<span class="tt1t1">
				    </span> 
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			d3.layout.bar( ) 					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			d3.layout.plot( ) 					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			d3.layout.map( ) 					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			d3.layout.pie( )					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a78" class="b2 help" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a78" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">4</i>
			<span class="t2t1">
			d3.layout.pie( )			</span>
					</div>
        <br>
				<strong class="tt1">해설</strong>
		<div class="t1">
		④번은 파이차트를 구현할 때 사용할 수 있는 명령어이다.				</div>
		
				
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				정답은 4번입니다.<br>
<br>
시각화는 데이터를 그래픽 형태로 표현하여 정보를 쉽게 이해할 수 있도록 돕는 과정입니다. 다양한 시각화 기법이 있으며, 각 기법은 특정한 데이터 유형과 목적에 적합합니다. 예를 들어, 파이 차트는 데이터의 비율을 시각적으로 표현하는 데 유용하며, 바 차트는 데이터의 비교를 쉽게 할 수 있도록 돕습니다. 시각화 도구와 라이브러리는 이러한 그래프를 쉽게 구현할 수 있는 API를 제공합니다. D3.js는 웹 기반의 시각화를 구현하는 데 널리 사용되는 라이브러리로, 다양한 레이아웃과 그래프를 지원합니다.<br>
<br>
1. d3.layout.bar( ) <br>
: 바 차트는 데이터의 크기를 막대의 길이로 표현하여 비교하기 쉽게 합니다. D3.js에서 바 차트를 구현할 때는 데이터를 축에 맞춰 막대를 그리는 과정이 필요합니다. 그러나 문제에서 요구하는 것은 다양한 목적의 시각화이므로, 특정한 차트 유형에 국한되지 않는 것이 중요합니다.<br>
<br>
2. d3.layout.plot( ) <br>
: 플롯은 일반적으로 점이나 선으로 데이터를 표현하는 그래프입니다. D3.js에서 플롯을 구현할 때는 데이터 포인트를 축에 맞춰 배치하는 과정이 필요합니다. 하지만 문제에서 요구하는 것은 특정한 차트 유형이 아닌 다양한 시각화입니다.<br>
<br>
3. d3.layout.map( ) <br>
: 맵은 지리적 데이터를 시각화하는 데 사용됩니다. D3.js에서 맵을 구현할 때는 지리적 좌표를 사용하여 데이터를 배치합니다. 그러나 문제에서 요구하는 것은 특정한 차트 유형이 아닌 다양한 시각화입니다.<br>
<br>
4. d3.layout.pie( ) <br>
: 파이 차트는 데이터의 비율을 시각적으로 표현하는 데 유용합니다. D3.js에서 파이 차트를 구현할 때는 데이터를 각도로 변환하여 원형으로 배치합니다. 문제에서 요구하는 다양한 목적의 시각화에 적합한 선택입니다.<br>
<br>
문제에서 요구하는 것은 다양한 목적의 시각화 구현입니다. 파이 차트는 데이터의 비율을 시각적으로 표현하는 데 유용하며, D3.js에서 이를 구현할 수 있는 명령어는 'd3.layout.pie()'입니다. 다른 선택지들은 특정한 차트 유형에 국한되거나 문제의 요구와 맞지 않습니다.<br>
따라서, 정답은 '4. d3.layout.pie( )' 입니다.<br>
			</div>
			<div class="t2">
									#시각화									# D3.js									# 파이 차트									# 데이터 비율									# 그래프 구현							</div>
		</div>
		
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">5과목</span>
			<span class="g1">시각화 방법</span>
			<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">79.</span>
			<span class="tt1t1">
				데이비드 터프티가 제시한 디자인 7원칙에 대한 설명으로 부적절한 것은?							</span>
		</strong>
		<span class="tt1t1">
				    </span> 
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			정보를 디자인할 때는 원인과 결과를 명쾌하게 제시하는 것이 좋다.					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			사용자의 쉬운 이해를 돕기 위해 공간이 아닌 시간에 따라 나열하는 것이 좋다. 					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			트렌드를 나타내기 위해 정량적 자료를 그래프나 도표로 표현하는 것이 좋다. 					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			연관된 변수와 트렌드를 비교할 수 있는 도구를 제공하는 것이 좋다.					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a79" class="b2 help" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a79" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">2</i>
			<span class="t2t1">
			사용자의 쉬운 이해를 돕기 위해 공간이 아닌 시간에 따라 나열하는 것이 좋다. 			</span>
					</div>
        <br>
				<strong class="tt1">해설</strong>
		<div class="t1">
		시간보다는 공간에 따라 나열할 때 사용자의 이해가 쉬워진다.				</div>
		
				
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				정답은 2번입니다.<br>
<br>
데이비드 터프티의 디자인 원칙은 정보의 명확한 전달을 목표로 하며, 시각적 표현을 통해 데이터를 효과적으로 전달하는 방법을 제시합니다.<br>
<br>
1. 정보를 디자인할 때는 원인과 결과를 명쾌하게 제시하는 것이 좋다.<br>
: 정보 디자인에서 원인과 결과를 명확히 제시하는 것은 데이터의 이해를 돕고, 사용자가 정보를 쉽게 해석할 수 있도록 합니다. 이는 데이터의 흐름을 명확히 하여 사용자가 정보를 빠르게 파악할 수 있게 합니다.<br>
<br>
2. 사용자의 쉬운 이해를 돕기 위해 공간이 아닌 시간에 따라 나열하는 것이 좋다.<br>
: 정보를 시간에 따라 나열하는 것은 모든 경우에 적합하지 않습니다. 공간적 배열이 더 효과적인 경우도 있으며, 정보의 특성에 따라 적절한 배열 방식을 선택해야 합니다. 시간적 배열은 시간의 흐름이 중요한 경우에만 적합합니다.<br>
<br>
3. 트렌드를 나타내기 위해 정량적 자료를 그래프나 도표로 표현하는 것이 좋다.<br>
: 정량적 자료를 그래프나 도표로 표현하는 것은 데이터의 패턴과 트렌드를 시각적으로 쉽게 이해할 수 있게 합니다. 이는 복잡한 데이터를 간결하게 전달하는 데 효과적입니다.<br>
<br>
4. 연관된 변수와 트렌드를 비교할 수 있는 도구를 제공하는 것이 좋다.<br>
: 연관된 변수와 트렌드를 비교할 수 있는 도구를 제공하는 것은 데이터 간의 관계를 명확히 하고, 사용자가 데이터를 분석하는 데 도움을 줍니다. 이는 데이터의 상호작용을 이해하는 데 필수적입니다.<br>
<br>
<br>
시간에 따라 나열하는 것이 항상 좋은 것은 아닙니다. 정보의 특성에 따라 공간적 배열이 더 적합할 수 있습니다. 다른 선택지들은 모두 터프티의 디자인 원칙에 부합하며, 정보의 명확한 전달을 위한 적절한 방법을 제시하고 있습니다.<br>
<br>
따라서, 정답은 '2. 사용자의 쉬운 이해를 돕기 위해 공간이 아닌 시간에 따라 나열하는 것이 좋다.' 입니다.<br>
			</div>
			<div class="t2">
									#데이비드 터프티									# 디자인 원칙									# 정보 디자인									# 시각적 표현							</div>
		</div>
		
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">5과목</span>
			<span class="g1">시각화 방법</span>
			<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">80.</span>
			<span class="tt1t1">
				시각화를 위한 그래픽 디자인 기본 원리에 대한 설명으로 적절하지 않은 것은?							</span>
		</strong>
		<span class="tt1t1">
				    </span> 
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			타이포그래피에서 가장 어려운 일이 서체를 선택하는 것이다.					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			색상에서 두 가지 색을 쓰는 경우 보색을 이용하고 명도와 채도를 같게 하면 된다.					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			그리드에서 3등분 법칙에 따라 요소를 배치하면 디자인에 비례 간격을 끌어들여 미학적으로 만족스러운 균형이 잡힌다.					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			아이소타이프는 정보, 자료, 개념, 의미 등을 나타내기 위해 문자와 숫자를 디자인적으로 변형한 뒤 시각적으로 나타내는 방식이다.					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a80" class="b2 help" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a80" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">2</i>
			<span class="t2t1">
			색상에서 두 가지 색을 쓰는 경우 보색을 이용하고 명도와 채도를 같게 하면 된다.			</span>
					</div>
        <br>
				<strong class="tt1">해설</strong>
		<div class="t1">
		아이소타이프는 정보, 자료, 개념, 의미 등을 나타내기 위해 문자와 숫자 대신 상징적 도형이나 정해진 기호를 조합해 시각적이고 직접적으로 나타내는 방식이다.				</div>
		
				
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				정답은 2번입니다.<br>
<br>
그래픽 디자인의 기본 원리는 시각적 요소를 효과적으로 배치하여 정보를 전달하는 것입니다. 타이포그래피, 색상, 그리드, 아이소타이프 등 다양한 요소가 포함되며, 각각의 요소는 특정한 원칙과 방법에 따라 사용됩니다. 타이포그래피는 서체 선택과 배치가 중요하며, 색상은 명도와 채도를 고려하여 조화롭게 사용해야 합니다. 그리드는 요소를 균형 있게 배치하는 데 도움을 주며, 아이소타이프는 정보를 시각적으로 표현하는 방법입니다.<br>
<br>
1. 타이포그래피에서 가장 어려운 일이 서체를 선택하는 것이다. <br>
: 타이포그래피에서 서체 선택은 매우 중요한 작업입니다. 서체는 글의 형태를 결정하며, 정보의 전달력과 가독성에 큰 영향을 미칩니다. 서체는 세리프와 산세리프로 나뉘며, 각각의 용도에 맞게 선택해야 합니다. 예를 들어, 세리프 서체는 본문에 적합하고, 산세리프 서체는 제목에 적합합니다. 서체 선택은 디자인의 전체적인 분위기를 결정짓기 때문에 신중해야 합니다.<br>
<br>
2. 색상에서 두 가지 색을 쓰는 경우 보색을 이용하고 명도와 채도를 같게 하면 된다. <br>
: 색상 사용 시 두 가지 색을 사용할 때 보색을 이용하고 명도와 채도를 같게 하는 것이 일반적인 원칙입니다. 그러나 보색을 사용할 때는 명도와 채도를 조절하여 시각적 균형을 맞추는 것이 중요합니다. 보색은 서로 반대되는 색으로, 잘못 사용하면 시각적 충돌을 일으킬 수 있습니다. 따라서 보색을 사용할 때는 조화로운 배색을 위해 명도와 채도를 조절해야 합니다.<br>
<br>
3. 그리드에서 3등분 법칙에 따라 요소를 배치하면 디자인에 비례 간격을 끌어들여 미학적으로 만족스러운 균형이 잡힌다. <br>
: 그리드는 디자인 요소를 균형 있게 배치하는 데 사용됩니다. 3등분 법칙은 디자인을 비례적으로 나누어 시각적 균형을 이루는 방법입니다. 이 법칙을 사용하면 디자인에 자연스러운 흐름과 조화를 부여할 수 있습니다. 예를 들어, 사진을 3등분하여 중요한 요소를 교차점에 배치하면 시각적으로 더 매력적입니다.<br>
<br>
4. 아이소타이프는 정보, 자료, 개념, 의미 등을 나타내기 위해 문자와 숫자를 디자인적으로 변형한 뒤 시각적으로 나타내는 방식이다. <br>
: 아이소타이프는 정보를 시각적으로 표현하는 방법으로, 문자와 숫자를 디자인적으로 변형하여 사용합니다. 이는 복잡한 정보를 쉽게 이해할 수 있도록 돕는 시각적 언어입니다. 예를 들어, 인구 통계를 아이소타이프로 표현하면 숫자보다 더 직관적으로 이해할 수 있습니다. 이는 정보 전달의 효율성을 높이는 데 유용합니다.<br>
<br>
선지 2는 색상 사용에 대한 설명이 부적절합니다. 보색을 사용할 때 명도와 채도를 같게 하는 것이 아니라, 조화로운 배색을 위해 조절해야 합니다. 다른 선지들은 각각의 개념에 맞는 설명을 제공하고 있습니다. 타이포그래피의 서체 선택, 그리드의 3등분 법칙, 아이소타이프의 시각적 표현 방식은 모두 적절한 설명입니다.<br>
따라서, 정답은 '2. 색상에서 두 가지 색을 쓰는 경우 보색을 이용하고 명도와 채도를 같게 하면 된다.' 입니다.<br>
			</div>
			<div class="t2">
									#타이포그래피									# 서체 선택									# 색상									# 보색									# 그리드									# 3등분 법칙									# 아이소타이프							</div>
		</div>
		
	</div>
</div>
<!-- /cp1question1 -->
<script>/*<![CDATA[*/
	//$('.w1').remove();
	$('.w2').remove();
  // 1) 인라인 style 제거 (초기 꼬임 방지)
  $('.tg2[style]').removeAttr('style');
  // 2) 클릭: href로 연결된 id를 정확히 토글
  $('.b2.help').on('click', function(e){
    e.preventDefault();
    var target = $(this).attr('href'); // "#m-help1a1"
    var $panel = $(target);
    // 첫 클릭부터 확실히 반응하도록 show/hide로 분기
    if ($panel.is(':visible')) {
      $panel.hide(); // 또는 $panel.addClass('is-hidden');
    } else {
      $panel.show(); // 또는 $panel.removeClass('is-hidden');
    }
    // 애니메이션 원하면: $panel.slideToggle(150);
  });
/*]]>*/
</script>
</div>


<!-- AUTO:mobile-scroll-fix-js start -->
<script>
(function () {
  // ---------- utils ----------
  function getPanelFromBtn(btn) {
    const sel = btn.getAttribute('href');
    if (!sel || !sel.startsWith('#')) return null;
    return document.querySelector(sel);
  }
  function isOpen(panel) {
    return panel && getComputedStyle(panel).display !== 'none';
  }
  function setOpen(btn, panel, open) {
    if (!btn || !panel) return;
    if (open) {
      panel.style.display = 'block';
      btn.classList.add('on');
      btn.setAttribute('aria-expanded', 'true');
      setTimeout(() => {
        panel.scrollIntoView({ behavior: 'smooth', block: 'start' });
      }, 50);
    } else {
      panel.style.display = 'none';
      btn.classList.remove('on');
      btn.setAttribute('aria-expanded', 'false');
    }
  }
  // ---------- storage ----------
  function pageKeyPrefix() {
    return 'exam:' + (location.pathname || 'page') + ':';
  }
  function getQuestionId(qBox) {
    const btn = qBox.querySelector('a.b2.help[href^="#"]');
    if (!btn) return null;
    const href = btn.getAttribute('href');
    if (!href || !href.startsWith('#')) return null;
    return href.slice(1);
  }
  function storageKey(qId) {
    return pageKeyPrefix() + qId;
  }
  // 정답 번호: 해설 패널 내 i.t2n (예: 2)
  function getCorrectIndex(panel) {
    const n = panel ? panel.querySelector('i.t2n') : null;
    if (!n) return null;
    const v = parseInt((n.textContent || '').trim(), 10);
    return Number.isFinite(v) ? v : null; // 1-based
  }
  function clearState(qBox) {
    qBox.querySelectorAll('.lst1 .li1').forEach(li => {
      li.classList.remove('is-selected', 'is-correct', 'is-wrong');
    });
  }
  function applyResult(qBox, idx) {
    const options = Array.from(qBox.querySelectorAll('.lst1 .li1'));
    const selected = options[idx - 1];
    if (!selected) return;
    selected.classList.add('is-selected');
    const btn = qBox.querySelector('a.b2.help[href^="#"]');
    const panel = btn ? getPanelFromBtn(btn) : null;
    const correct = getCorrectIndex(panel);
    if (!correct) return;
    if (idx === correct) {
      selected.classList.add('is-correct');
    } else {
      selected.classList.add('is-wrong');
      const right = options[correct - 1];
      if (right) right.classList.add('is-correct');
    }
  }
  function saveChoice(qBox, idx) {
    const qId = getQuestionId(qBox);
    if (!qId) return;
    try {
      localStorage.setItem(storageKey(qId), String(idx));
    } catch (e) {}
  }
  function restoreChoices() {
    document.querySelectorAll('.cp1question1').forEach(qBox => {
      const qId = getQuestionId(qBox);
      if (!qId) return;
      let v = null;
      try {
        v = localStorage.getItem(storageKey(qId));
      } catch (e) {}
      const idx = v ? parseInt(v, 10) : null;
      if (!idx || !Number.isFinite(idx)) return;
      clearState(qBox);
      applyResult(qBox, idx);
    });
  }
  // ---------- 1) 보기 버튼 토글 (충돌 방지) ----------
  document.addEventListener('click', function (e) {
    const btn = e.target.closest('a.b2.help');
    if (!btn) return;
    const panel = getPanelFromBtn(btn);
    if (!panel) return;
    // 기존 스크립트(여러 개 존재)와 충돌 방지
    e.preventDefault();
    e.stopImmediatePropagation();
    setOpen(btn, panel, !isOpen(panel));
  }, true);
  // ---------- 2) 선지 클릭: 선택 표시 + 정답표시 + 저장 + 해설 오픈 ----------
  document.addEventListener('click', function (e) {
    const li = e.target.closest('.cp1question1 .lst1 .li1');
    if (!li) return;
    const qBox = li.closest('.cp1question1');
    if (!qBox) return;
    const options = Array.from(qBox.querySelectorAll('.lst1 .li1'));
    const idx = options.indexOf(li) + 1;
    if (!idx) return;
    clearState(qBox);
    applyResult(qBox, idx);
    saveChoice(qBox, idx);
    // 해설 자동 오픈
    const btn = qBox.querySelector('a.b2.help[href^="#"]');
    const panel = btn ? getPanelFromBtn(btn) : null;
    if (btn && panel) setOpen(btn, panel, true);
  }, true);
  // ---------- init ----------
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', restoreChoices);
  } else {
    restoreChoices();
  }
})();
</script>
<!-- AUTO:mobile-scroll-fix-js end -->

<!-- AUTO:score-counter start -->
<script>
(function () {
  function qsa(sel, root) { return Array.from((root || document).querySelectorAll(sel)); }
  function qs(sel, root) { return (root || document).querySelector(sel); }

  function setText(el, n) {
    if (!el) return;
    el.textContent = String(n) + '개';
  }

  function updateTotal(total) {
    const block = qs('.cp1dlist2');
    if (!block) return;
    qsa('.cp1dlist2 .di1', block).forEach(li => {
      const label = (qs('.dt1', li)?.textContent || '').trim();
      if (label === '총 문제') {
        const dd = qs('.dd1', li);
        if (dd) dd.textContent = String(total) + '개';
      }
    });
  }

  function getPanelFromQ(qBox) {
    const btn = qBox.querySelector('a.b2.help[href^="#"]');
    if (!btn) return null;
    const href = btn.getAttribute('href');
    if (!href || !href.startsWith('#')) return null;
    return document.querySelector(href);
  }

  function getCorrectIndex(panel) {
    const n = panel ? panel.querySelector('i.t2n') : null;
    if (!n) return null;
    const v = parseInt((n.textContent || '').trim(), 10);
    return Number.isFinite(v) ? v : null; // 1-based
  }

  function recompute() {
    const total = qsa('.cp1question1').length;
    let correct = 0;
    let wrong = 0;

    qsa('.cp1question1').forEach(qBox => {
      const state = qBox.getAttribute('data-answer-state');
      if (state === 'correct') correct += 1;
      else if (state === 'wrong') wrong += 1;
    });

    const unanswered = Math.max(0, total - (correct + wrong));

    updateTotal(total);
    setText(qs('.cp1dlist2 .em1'), correct);
    setText(qs('.cp1dlist2 .em2'), wrong);
    setText(qs('.cp1dlist2 .em3'), unanswered);
  }

  function handle(e) {
    const li = e.target.closest('.cp1question1 .lst1 .li1');
    if (!li) return;

    const qBox = li.closest('.cp1question1');
    if (!qBox) return;

    const options = qsa('.lst1 .li1', qBox);
    const idx = options.indexOf(li) + 1; // 1-based
    if (idx <= 0) return;

    const panel = getPanelFromQ(qBox);
    const correctIdx = getCorrectIndex(panel);
    if (!correctIdx) {
      qBox.removeAttribute('data-answer-state');
      recompute();
      return;
    }

    qBox.setAttribute('data-answer-state', (idx === correctIdx) ? 'correct' : 'wrong');
    recompute();
  }

  // click이 막혀도 동작하도록 pointerup도 함께 수신(충돌 방어)
  document.addEventListener('click', handle, true);
  document.addEventListener('pointerup', handle, true);

  function init() { recompute(); }
  if (document.readyState === 'loading') document.addEventListener('DOMContentLoaded', init);
  else init();
})();
</script>
<!-- AUTO:score-counter end -->

</body>
</html>