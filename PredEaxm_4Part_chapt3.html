<html lang="ko" style="" class="cssscrollbar Desktop PC zoom object-fit gteIE9orSUA Chrome width-large lt-width-xlarge"><head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>예상문제 </title>
<style>
/* AUTO:exam-ui start */
/* 클릭 가능 UX */
a.b2.help,
.cp1question1 .lst1 .li1,
.cp1question1 .lst1 .li1 a {
  cursor: pointer;
}
/* hover (navy) */
.cp1question1 .lst1 .li1:hover {
  background: rgba(31, 42, 68, 0.06);
}
/* 선택 표시 (navy) */
.cp1question1 .lst1 .li1.is-selected {
  background: rgba(31, 42, 68, 0.12);
  border-radius: 6px;
}
.cp1question1 .lst1 .li1.is-selected .t1 {
  font-weight: 600;
  color: #2980b9; /* 딥 블루 */
}
/* 정답 (navy) */
.cp1question1 .lst1 .li1.is-correct {
  background: rgba(52, 152, 219, 0.18); /* 라이트 블루 */
  border-radius: 6px;
}
.cp1question1 .lst1 .li1.is-correct .t1 {
  font-weight: 700;
  color: #2980b9; /* 딥 블루 */
}
/* 오답 */
.cp1question1 .lst1 .li1.is-wrong {
  background: rgba(160, 30, 30, 0.12);
  border-radius: 6px;
}
.cp1question1 .lst1 .li1.is-wrong .t1 {
  font-weight: 600;
  color: #7a1f1f;
}
/* 보기 버튼 (navy) */
a.b2.help {
  color: #2980b9; /* 딥 블루 */
}
a.b2.help.on {
  font-weight: 600;
}
/* AUTO:exam-ui end */


/* AUTO:clickable-ui start */
a.b2.help,
.cp1question1 .lst1 .li1,
.cp1question1 .lst1 .li1 a {
  cursor: pointer;
}
.cp1question1 .lst1 .li1:hover {
  background: rgba(0, 0, 0, 0.04);
}
a.b2.help:hover {
  opacity: 0.85;
}
/* AUTO:clickable-ui end */
/* AUTO:mobile-scroll-fix start */
html {
  scroll-behavior: smooth;
}
.container {
  max-width: 600px;
  width: 100%;
  margin: 0 auto;
}
/* AUTO:mobile-scroll-fix end */
body {width:100%;}
	.eg1 {padding:10px 0px; text-align:center;width:100%;}
	.tg2 {border-bottom:1px solid #ddd;padding:5% 5%;display:none}
	.cp1question1 {padding-bottom:12px;}
	img {
	  width: 100%;
	  height: 100%;
	  object-fit: contain; /* 또는 cover */
	}
h2 a {
  font-size: 16px;        /* 글씨 크기 */
  text-decoration: none;  /* 밑줄 제거 */
  color: #333;            /* 기본 글자 색 */
  font-weight: 500;       /* 약간 두껍게 */
  transition: color 0.3s ease; /* hover 시 부드럽게 색 변화 */
}
h2 a:hover {
  color: #007acc;         /* hover 시 포인트 색 */
}

/* AUTO:cp1dlist2-style start */
.cp1dlist2 {
  display: flex;
  justify-content: flex-end;
  background-color: #f0f0f0;
  border-radius: 12px;
  padding: 10px 15px;
}

.cp1dlist2 ul {
  list-style: none;
  margin: 0;
  padding: 0;
  display: flex;
  gap: 10px;
}

.em2 {
  color: #d63031;
}
/* AUTO:cp1dlist2-style end */

</style>
</head>
<body>
<div class="container clearfix">
<div id="body" tabindex="-1">
<!-- container -->
<div class="container clearfix">
<!-- #forPrint -->
<div id="forPrint">
<!-- _content -->
<div id="body_content">
<h2><a href="./index.html"> &lt; 돌아가기</a>

<span class="all-controls" style="margin-left: 15px; vertical-align: middle;">
    <button type="button" onclick="window.controlAllAnswers(true)" style="padding: 6px 12px; background-color: #2c3e50; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 13px; font-weight: bold;">전체 정답 보기</button>
    <button type="button" onclick="window.controlAllAnswers(false)" style="padding: 6px 12px; background-color: #95a5a6; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 13px; font-weight: bold; margin-left: 5px;">전체 가리기</button>
</span></h2>
<!-- container -->
<div class="container clearfix">
<!-- cp1dlist2 -->
<div class="cp1dlist2">
<ul class="dl1">
<li class="di1">
<a class="a1">
<b class="dt1">총 문제</b>
<span class="dd1">19개</span>
</a>
</li>
<li class="di1">
<a class="a1">
<b class="dt1">맞춘 문제</b>
<span class="dd1"><b class="em1">0개</b></span>
</a>
</li>
<li class="di1">
<a class="a1">
<b class="dt1">틀린 문제</b>
<span class="dd1"><b class="em2">0개</b></span>
</a>
</li>
<li class="di1">
<a class="a1">
<b class="dt1">안 푼 문제</b>
<span class="dd1"><b class="em3">19개</b></span>
</a>
</li>
</ul>
</div>
<!-- /cp1dlist2 -->
<h3 class="hb1 h3">3장 - 데이터 마트</h3>
<!-- cp1question1 -->
<div class="cp1question1">
<div class="sg1">
<div class="w1">
<span class="g1">4과목</span>
<span class="g1">데이터변경 및 요약</span>
<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
</div>
</div>
<div class="tg1">
<strong class="tt1">
<span class="tt1n">1.</span>
<span class="tt1t1">
				데이터 웨어하우스와 사용자의 중간층에 위치한 것으로, 하나의 주제 또는 하나의 부서 중심의 데이터 웨어하우스라고 할 수 있는 데이터베이스는 무엇인가?							</span>
</strong>
<span class="tt1t1">
</span>
</div>
<ol class="lst1">
<li class="li1"><a class="a1"><span class="t1">
			데이터마트					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			모델링					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			관계형 데이터베이스					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			빅데이터					</span></a></li>
</ol>
<div class="eg1">
<a class="b2 help" href="#m-help1a1" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
<span class="t1">정답보기</span>
<i class="ic1"></i>
</a>
</div>
<div class="tg2 loaded" id="m-help1a1" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
<strong class="tt1">정답</strong>
<div class="t2">
<i class="t2n">1</i>
<span class="t2t1">
			데이터마트			</span>
</div>
<br/>
<strong class="tt1">해설</strong>
<div class="t1">
		데이터 웨어하우스와 사용자 사이의 중간층에 위치한 것으로, 하나의 주제 또는 하나의 부서중심의 데이터 웨어하우스라고 할 수 있다. 데이터 마트 내 대부분의 데이터는 데이터 웨어하우스로부터 복제되지만, 자체적으로 수집될 수도 있으며, 관계형 데이터베이스나 다차원 데이터베이스를 이용하여 구축한다.				</div>


<div class="more-c">
<strong class="tt1">비기봇 해설</strong>
<div class="t1">
				정답은 1번입니다.<br/>
<br/>
데이터 웨어하우스는 대량의 데이터를 저장하고 분석하기 위한 시스템으로, 주로 기업의 의사결정 지원을 위해 사용됩니다. 데이터 마트는 이러한 데이터 웨어하우스와 사용자 사이의 중간층에 위치하며, 특정 주제나 부서 중심으로 데이터를 구성합니다. 데이터 마트는 데이터 웨어하우스에서 데이터를 복제하거나 자체적으로 수집하여, 관계형 데이터베이스나 다차원 데이터베이스를 통해 구축됩니다. 이는 사용자가 보다 쉽게 데이터를 분석하고 활용할 수 있도록 돕습니다.<br/>
<br/>
1. 데이터마트 <br/>
: 데이터 마트는 데이터 웨어하우스의 축소판으로, 특정 주제나 부서에 초점을 맞춘 데이터베이스입니다. 데이터 웨어하우스에서 데이터를 가져오거나 자체적으로 수집하여, 사용자가 쉽게 접근하고 분석할 수 있도록 설계됩니다. 이는 데이터 웨어하우스의 복잡성을 줄이고, 특정 요구에 맞춘 데이터를 제공하는 데 유리합니다.<br/>
<br/>
2. 모델링 <br/>
: 모델링은 데이터베이스 설계의 한 과정으로, 데이터의 구조를 정의하고 설계하는 것을 의미합니다. 이는 데이터 마트와는 다른 개념으로, 데이터 마트는 이미 구축된 데이터베이스를 의미합니다. 따라서 모델링은 데이터 마트의 정의와 맞지 않습니다.<br/>
<br/>
3. 관계형 데이터베이스 <br/>
: 관계형 데이터베이스는 데이터를 테이블 형식으로 저장하는 데이터베이스 시스템입니다. 데이터 마트는 이러한 관계형 데이터베이스를 활용할 수 있지만, 데이터 마트 자체를 설명하는 개념은 아닙니다. 데이터 마트는 특정 주제나 부서 중심의 데이터베이스를 의미하므로, 관계형 데이터베이스와는 다른 개념입니다.<br/>
<br/>
4. 빅데이터 <br/>
: 빅데이터는 대량의 데이터를 처리하고 분석하는 기술을 의미합니다. 데이터 마트는 빅데이터의 일부를 특정 주제나 부서 중심으로 구성한 데이터베이스로, 빅데이터 자체를 설명하는 개념은 아닙니다. 따라서 빅데이터는 데이터 마트의 정의와 맞지 않습니다.<br/>
<br/>
데이터 마트는 데이터 웨어하우스와 사용자 사이의 중간층에 위치하며, 특정 주제나 부서 중심으로 데이터를 구성하는 데이터베이스입니다. 이는 문제에서 설명한 '하나의 주제 또는 하나의 부서 중심의 데이터 웨어하우스'라는 정의와 일치합니다. 다른 선지들은 데이터 마트의 정의와 맞지 않으며, 각각 다른 개념을 설명하고 있습니다.<br/>
따라서, 정답은 '1. 데이터마트' 입니다.<br/>
</div>
<div class="t2">
									#데이터 마트									# 데이터 웨어하우스									# 주제 중심									# 부서 중심									# 관계형 데이터베이스							</div>
</div>

</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
<div class="sg1">
<div class="w1">
<span class="g1">4과목</span>
<span class="g1">데이터변경 및 요약</span>
<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
</div>
</div>
<div class="tg1">
<strong class="tt1">
<span class="tt1n">2.</span>
<span class="tt1t1">
				변수를 조합해 변수명을 만들고 변수들을 시간, 상품 등의 차원에 결합해 다양한 요약변수와 파생변수를 쉽게 생성하여 데이터 마트를 구성할 수 있는 패키지는 무엇인가?							</span>
</strong>
<span class="tt1t1">
</span>
</div>
<ol class="lst1">
<li class="li1"><a class="a1"><span class="t1">
			ETL					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			reshape					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			OLAP					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			rattle					</span></a></li>
</ol>
<div class="eg1">
<a class="b2 help" href="#m-help1a2" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
<span class="t1">정답보기</span>
<i class="ic1"></i>
</a>
</div>
<div class="tg2 loaded" id="m-help1a2" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
<strong class="tt1">정답</strong>
<div class="t2">
<i class="t2n">2</i>
<span class="t2t1">
			reshape			</span>
</div>
<br/>
<strong class="tt1">해설</strong>
<div class="t1">
		reshape 패키지는 데이터를 원하는 형태로 바꿔주는 melt 함수와 원하는 부분만을 선택하는 cast 함수로 구성되어 있다.				</div>


<div class="more-c">
<strong class="tt1">비기봇 해설</strong>
<div class="t1">
				1. ETL(Extract, Transform, Load)은 데이터 웨어하우스에 필요한 데이터를 추출, 변환, 적재하는 과정을 말합니다. 이는 데이터 마트를 구성하는 과정이지만, 질문에서 요구하는 것처럼 변수를 조합하거나 요약변수와 파생변수를 생성하는 기능은 제공하지 않습니다.<br/>
<br/>
2. reshape는 R에서 제공하는 패키지로, 데이터의 형태를 변경하는데 사용됩니다. 이 패키지를 사용하면 변수들을 시간, 상품 등의 차원에 결합해 다양한 요약변수와 파생변수를 쉽게 생성할 수 있습니다. 따라서 이 패키지를 사용해 데이터 마트를 구성할 수 있습니다.<br/>
<br/>
3. OLAP(Online Analytical Processing)은 다차원 데이터 분석을 위한 기술입니다. 이는 데이터 웨어하우스에서 데이터를 분석하는데 사용되지만, 직접적으로 변수를 조합하거나 요약변수와 파생변수를 생성하는 기능은 제공하지 않습니다.<br/>
<br/>
4. rattle은 R에서 제공하는 데이터 마이닝 툴킷입니다. 이는 데이터 마이닝 과정을 지원하지만, 질문에서 요구하는 것처럼 변수를 조합하거나 요약변수와 파생변수를 생성하는 기능은 제공하지 않습니다.<br/>
</div>
<div class="t2">
									# 변수									# 조합									# 요약 변수									# 파생 변수									# 데이터 마트									# 패키지									# ETL									# reshape									# OLAP									# rattle									# 데이터 웨어하우스									# 데이터 마이닝							</div>
</div>

</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
<div class="sg1">
<div class="w1">
<span class="g1">4과목</span>
<span class="g1">데이터변경 및 요약</span>
<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
</div>
</div>
<div class="tg1">
<strong class="tt1">
<span class="tt1n">3.</span>
<span class="tt1t1">
				파생변수는 사용자가 특정 조건을 만족하거나 특정 함수에 의해 값을 만들어 의미를 부여한 변수이다. 다음 중 파생변수의 설명으로 적절한 것은?							</span>
</strong>
<span class="tt1t1">
</span>
</div>
<ol class="lst1">
<li class="li1"><a class="a1"><span class="t1">
			파생변수는 매우 주관적인 변수일 수 있으므로 논리적 타당성을 갖춰야 한다. 					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			파생변수는 많은 모델에서 공통적으로 많이 사용될 수 있다.					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			파생변수는 재활용성이 높다.					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			파생변수는 다양한 모델을 개발해야 하는 경우, 효율적으로 사용할 수 있다.					</span></a></li>
</ol>
<div class="eg1">
<a class="b2 help" href="#m-help1a3" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
<span class="t1">정답보기</span>
<i class="ic1"></i>
</a>
</div>
<div class="tg2 loaded" id="m-help1a3" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
<strong class="tt1">정답</strong>
<div class="t2">
<i class="t2n">1</i>
<span class="t2t1">
			파생변수는 매우 주관적인 변수일 수 있으므로 논리적 타당성을 갖춰야 한다. 			</span>
</div>
<br/>
<strong class="tt1">해설</strong>
<div class="t1">
		파생변수는 사용자가 특정 조건을 만족하거나 특정 함수에 의해 값을 만들어 의미를 부여한 변수로서, 매우 주관적일 수 있으므로 논리적 타당성을 갖추어 개발해야 한다.				</div>


<div class="more-c">
<strong class="tt1">비기봇 해설</strong>
<div class="t1">
				정답은 1번입니다.<br/>
<br/>
파생변수는 기존의 데이터를 기반으로 새로운 의미를 부여하여 생성된 변수입니다. 이러한 변수는 데이터 분석 및 모델링에서 중요한 역할을 하며, 특정 조건이나 함수를 통해 만들어집니다.<br/>
<br/>
1. 파생변수는 매우 주관적인 변수일 수 있으므로 논리적 타당성을 갖춰야 한다.<br/>
: 파생변수는 주관적인 해석이 개입될 수 있기 때문에, 이를 사용할 때는 논리적 타당성을 확보하는 것이 중요합니다. 이는 데이터의 신뢰성을 높이는 데 기여합니다.<br/>
<br/>
2. 파생변수는 많은 모델에서 공통적으로 많이 사용될 수 있다.<br/>
: 파생변수는 특정 모델에 특화된 경우가 많아, 모든 모델에서 공통적으로 사용되기보다는 특정 목적에 맞춰 사용됩니다.<br/>
<br/>
3. 파생변수는 재활용성이 높다.<br/>
: 파생변수는 특정한 목적을 위해 만들어지기 때문에, 다른 데이터셋이나 모델에 재활용하기 어려운 경우가 많습니다.<br/>
<br/>
4. 파생변수는 다양한 모델을 개발해야 하는 경우, 효율적으로 사용할 수 있다.<br/>
: 파생변수는 다양한 모델을 개발할 때, 특정한 목적에 맞춰 효율적으로 사용할 수 있습니다. 이는 모델의 성능을 향상시키는 데 기여할 수 있습니다.<br/>
<br/>
<br/>
파생변수는 주관적인 해석이 개입될 수 있기 때문에, 논리적 타당성을 갖추는 것이 중요합니다. 이는 데이터 분석의 신뢰성을 높이는 데 필수적입니다. 다른 선택지들은 파생변수의 일반적인 특성을 설명하지 못하거나, 오해의 소지가 있는 설명을 포함하고 있습니다.<br/>
<br/>
따라서, 정답은 '1. 파생변수는 매우 주관적인 변수일 수 있으므로 논리적 타당성을 갖춰야 한다.' 입니다.<br/>
</div>
<div class="t2">
									#파생변수									# 논리적 타당성									# 데이터 분석									# 모델링							</div>
</div>

</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
<div class="sg1">
<div class="w1">
<span class="g1">4과목</span>
<span class="g1">데이터변경 및 요약</span>
<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
</div>
</div>
<div class="tg1">
<strong class="tt1">
<span class="tt1n">4.</span>
<span class="tt1t1">
				많은 기업에서 평균거래주기를 3,4배 이상 초과하거나 다음 달에 거래가 없을 것으로 예상되는 고객을 (  ㉠  )으로 정의하고 있다. 다음 중 (  ㉠  )에 가장 적절한 것은?							</span>
</strong>
<span class="tt1t1">
</span>
</div>
<ol class="lst1">
<li class="li1"><a class="a1"><span class="t1">
			신규고객					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			우량고객					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			가망고객					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			휴면고객					</span></a></li>
</ol>
<div class="eg1">
<a class="b2 help" href="#m-help1a4" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
<span class="t1">정답보기</span>
<i class="ic1"></i>
</a>
</div>
<div class="tg2 loaded" id="m-help1a4" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
<strong class="tt1">정답</strong>
<div class="t2">
<i class="t2n">4</i>
<span class="t2t1">
			휴면고객			</span>
</div>
<br/>
<strong class="tt1">해설</strong>
<div class="t1">
		휴면고객이란 일정 기간 동안 구매나 서비스 이용 등의 활동이 전혀 없는 고객을 의미한다.				</div>


<div class="more-c">
<strong class="tt1">비기봇 해설</strong>
<div class="t1">
				정답은 4번입니다.<br/>
<br/>
기업에서 고객을 분류할 때, 거래 주기와 거래 빈도를 기준으로 고객의 상태를 파악합니다. 평균 거래 주기를 3, 4배 이상 초과하거나 다음 달에 거래가 없을 것으로 예상되는 고객은 일반적으로 '휴면고객'으로 분류됩니다. 이는 고객이 더 이상 활발하게 거래하지 않으며, 기업의 매출에 기여하지 않는 상태를 의미합니다. 이러한 고객을 식별하여 적절한 마케팅 전략을 수립하는 것이 중요합니다.<br/>
<br/>
1. 신규고객 <br/>
: 신규고객은 최근에 기업과 거래를 시작한 고객을 의미합니다. 이들은 평균 거래 주기나 거래 빈도와 관련이 없으며, 주로 첫 거래 이후의 활동을 기반으로 분석됩니다. 따라서 평균 거래 주기를 초과하거나 거래가 없을 것으로 예상되는 고객과는 관련이 없습니다.<br/>
<br/>
2. 우량고객 <br/>
: 우량고객은 기업과의 거래가 활발하고, 높은 매출을 발생시키는 고객을 의미합니다. 이들은 평균 거래 주기를 초과하지 않으며, 지속적인 거래가 예상됩니다. 따라서 거래가 없을 것으로 예상되는 고객과는 반대되는 개념입니다.<br/>
<br/>
3. 가망고객 <br/>
: 가망고객은 아직 거래를 시작하지 않았지만, 향후 거래 가능성이 있는 잠재 고객을 의미합니다. 이들은 평균 거래 주기와 직접적인 관련이 없으며, 주로 마케팅 활동을 통해 거래를 유도하는 대상입니다.<br/>
<br/>
4. 휴면고객 <br/>
: 휴면고객은 과거에 거래가 있었으나 현재는 거래가 중단된 고객을 의미합니다. 이들은 평균 거래 주기를 초과하거나 다음 달에 거래가 없을 것으로 예상되는 고객으로, 기업의 매출에 기여하지 않는 상태입니다. 따라서 문제에서 정의한 조건에 가장 부합합니다.<br/>
<br/>
정답은 '휴면고객'입니다. 이는 평균 거래 주기를 3, 4배 이상 초과하거나 다음 달에 거래가 없을 것으로 예상되는 고객을 지칭하는 용어로, 문제의 조건에 정확히 부합합니다. 다른 선지들은 각각 신규, 우량, 가망 고객을 설명하며, 이들은 거래 주기와 거래 빈도와 관련된 문제의 조건과 맞지 않습니다.<br/>
따라서, 정답은 '4. 휴면고객' 입니다.<br/>
</div>
<div class="t2">
									#휴면고객									# 평균 거래 주기									# 고객 분류									# 거래 빈도									# 마케팅 전략							</div>
</div>

</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
<div class="sg1">
<div class="w1">
<span class="g1">4과목</span>
<span class="g1">데이터변경 및 요약</span>
<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
</div>
</div>
<div class="tg1">
<strong class="tt1">
<span class="tt1n">5.</span>
<span class="tt1t1">
				아래 표는 데이터의 변경을 통해 새로운 구조의 데이터셋을 구성하고자 할때 사용하는 R 프로그램 중 melt함수와 cast 함수의 예시이다. 데이터셋 MD를 새로운 데이터 형태로 변경하기 위한 cast 함수를 활용한 R 프로그램 중 옳은 것은?							</span>
</strong>
<span class="tt1t1">
<a class="p1" href="exam1view1img1.php?img=c9f527b6-d84a-8d46-5758-1c892073deef.jpg" rel="noopener" target="_blank" title="새 창">
<img alt="문제에 포함된 이미지" src="https://www.dataedupt.kr/data/img/question/c9f527b6-d84a-8d46-5758-1c892073deef.jpg"/>
</a>
</span>
</div>
<ol class="lst1">
<li class="li1"><a class="a1"><span class="t1">
			cast(md, id,variable+time) 					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			cast(md, id+variable,time) 					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			cast(md, id+time,variable) 					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			cast(md, id,variable, mean)					</span></a></li>
</ol>
<div class="eg1">
<a class="b2 help" href="#m-help1a5" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
<span class="t1">정답보기</span>
<i class="ic1"></i>
</a>
</div>
<div class="tg2 loaded" id="m-help1a5" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
<strong class="tt1">정답</strong>
<div class="t2">
<i class="t2n">2</i>
<span class="t2t1">
			cast(md, id+variable,time) 			</span>
</div>
<br/>
<strong class="tt1">해설</strong>
<div class="t1">
		csat 함수는 모양을 만드는 함수로서 오른쪽의 각 ID와 Variable에 대해 Time의 Value 를 확인하는 것이므로 cast(md, id+variable ,time)이 정답이다.				</div>


<div class="more-c">
<strong class="tt1">비기봇 해설</strong>
<div class="t1">
				R 프로그램에서 cast 함수는 데이터를 재 구조화하는데 사용됩니다. 이 함수의 기본 구조는 cast(data, formula, function)입니다. 여기서 formula는 id + variable 형태로, id는 행을 구분하는 변수, variable은 열을 구분하는 변수를 의미합니다. function은 각 데이터 셀에 적용할 함수를 의미합니다.<br/>
<br/>
1. cast(md, id,variable+time): 이 코드는 variable과 time을 열로 만들고 id를 행으로 만드는 것을 시도합니다. 그러나 이는 cast 함수의 기본 구조에 맞지 않습니다.<br/>
<br/>
2. cast(md, id+variable,time): 이 코드는 id와 variable을 행으로 만들고 time을 열로 만듭니다. 이는 cast 함수의 기본 구조에 맞습니다.<br/>
<br/>
3. cast(md, id+time,variable): 이 코드는 id와 time을 행으로 만들고 variable을 열로 만듭니다. 이는 cast 함수의 기본 구조에 맞습니다. 그러나 문제에서 요구하는 것은 id와 variable을 행으로 만드는 것이므로 이 코드는 옳지 않습니다.<br/>
<br/>
4. cast(md, id,variable, mean): 이 코드는 id를 행으로 만들고 variable을 열로 만듭니다. 그리고 각 데이터 셀에 mean 함수를 적용합니다. 그러나 문제에서 요구하는 것은 id와 variable을 행으로 만드는 것이므로 이 코드는 옳지 않습니다.<br/>
</div>
<div class="t2">
									# R 프로그램									# cast()									# 데이터 재 구조화									# R 출력 결과									# data									# formula									# function									# mean									# 							</div>
</div>

</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
<div class="sg1">
<div class="w1">
<span class="g1">4과목</span>
<span class="g1">데이터변경 및 요약</span>
<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
</div>
</div>
<div class="tg1">
<strong class="tt1">
<span class="tt1n">6.</span>
<span class="tt1t1">
				아래의 정의가 가리키는 데이터 마트의 구성요소로 가장 적절한 것은?					
					<span class="tt1t1">
						특정한 의미를 갖는 작위적 정의에 의한 변수로, 사용자가 특정 조건을 만족하거나 특정 함수에 의해 값을 만들어 의미를 부여한 변수					</span>
</span>
</strong>
<span class="tt1t1">
</span>
</div>
<ol class="lst1">
<li class="li1"><a class="a1"><span class="t1">
			반응변수					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			파생변수					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			설명변수					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			요약변수					</span></a></li>
</ol>
<div class="eg1">
<a class="b2 help" href="#m-help1a6" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
<span class="t1">정답보기</span>
<i class="ic1"></i>
</a>
</div>
<div class="tg2 loaded" id="m-help1a6" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
<strong class="tt1">정답</strong>
<div class="t2">
<i class="t2n">2</i>
<span class="t2t1">
			파생변수			</span>
</div>
<br/>
<strong class="tt1">해설</strong>
<div class="t1">
		아래의 정의는 파생변수에 대한 설명이다.				</div>


<div class="more-c">
<strong class="tt1">비기봇 해설</strong>
<div class="t1">
				정답은 2번입니다.<br/>
<br/>
데이터 마트는 데이터 분석을 위해 데이터를 저장하고 관리하는 시스템입니다. 데이터 마트의 구성 요소 중 하나인 파생변수는 사용자가 특정 조건을 만족하거나 특정 함수에 의해 값을 만들어 의미를 부여한 변수입니다. 이는 매우 주관적일 수 있으며, 논리적 타당성을 갖추어 개발해야 합니다. 파생변수는 세분화, 고객 행동 예측, 캠페인 반응 예측 등에 잘 활용됩니다. 반면, 요약변수는 수집된 정보를 분석에 맞게 종합한 변수로, 합계나 횟수와 같은 간단한 구조를 가집니다. 요약변수는 데이터 마트에서 가장 기본적인 변수로, 많은 모델에 공통으로 사용될 수 있어 재활용성이 높습니다.<br/>
<br/>
1. 반응변수 <br/>
: 반응변수는 통계학에서 종속변수로, 독립변수의 변화에 따라 영향을 받는 변수입니다. 데이터 마트의 구성 요소로서의 파생변수나 요약변수와는 다른 개념입니다. 따라서 이 문제의 정의와는 관련이 없습니다.<br/>
<br/>
2. 파생변수 <br/>
: 파생변수는 사용자가 특정 조건을 만족하거나 특정 함수에 의해 값을 만들어 의미를 부여한 변수입니다. 이는 매우 주관적일 수 있으며, 논리적 타당성을 갖추어 개발해야 합니다. 문제에서 언급된 '특정한 의미를 갖는 작위적 정의에 의한 변수'는 파생변수의 정의와 일치합니다.<br/>
<br/>
3. 설명변수 <br/>
: 설명변수는 독립변수로, 반응변수에 영향을 미치는 변수입니다. 데이터 마트의 구성 요소로서의 파생변수나 요약변수와는 다른 개념입니다. 따라서 이 문제의 정의와는 관련이 없습니다.<br/>
<br/>
4. 요약변수 <br/>
: 요약변수는 수집된 정보를 분석에 맞게 종합한 변수로, 합계나 횟수와 같은 간단한 구조를 가집니다. 이는 문제에서 언급된 '특정한 의미를 갖는 작위적 정의에 의한 변수'와는 다릅니다.<br/>
<br/>
정답은 '파생변수'입니다. 문제에서 언급된 '특정한 의미를 갖는 작위적 정의에 의한 변수'는 사용자가 특정 조건을 만족하거나 특정 함수에 의해 값을 만들어 의미를 부여한 파생변수의 정의와 일치합니다. 반면, 반응변수와 설명변수는 통계학에서의 개념으로, 데이터 마트의 구성 요소로서의 파생변수나 요약변수와는 관련이 없습니다. 요약변수는 수집된 정보를 분석에 맞게 종합한 변수로, 문제의 정의와는 다릅니다.<br/>
따라서, 정답은 '2. 파생변수' 입니다.<br/>
</div>
<div class="t2">
									#데이터 마트									# 파생변수									# 요약변수									# 반응변수									# 설명변수							</div>
</div>

</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
<div class="sg1">
<div class="w1">
<span class="g1">4과목</span>
<span class="g1">데이터변경 및 요약</span>
<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
</div>
</div>
<div class="tg1">
<strong class="tt1">
<span class="tt1n">7.</span>
<span class="tt1t1">
				아래의 왼쪽 자료를 오른쪽의 형태로 변환하기 위한 명령어로 적절한 것은?							</span>
</strong>
<span class="tt1t1">
<a class="p1" href="exam1view1img1.php?img=5af4df3b-8b0f-e7fd-1ffd-6d78c071c5e5.jpg" rel="noopener" target="_blank" title="새 창">
<img alt="문제에 포함된 이미지" src="https://www.dataedupt.kr/data/img/question/5af4df3b-8b0f-e7fd-1ffd-6d78c071c5e5.jpg"/>
</a>
</span>
</div>
<ol class="lst1">
<li class="li1"><a class="a1"><span class="t1">
			aqm&lt;-melt(airquality, id=c(“Month”,”Day”), na.r m=TRUE) 					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			aqm&lt;-melt(airquality, id=c(“Month”,”Day”))					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			aqm&lt;-melt(airquality, id=c(“Ozone”,”Solar.R”,”Wind”,”Temp”), na.rm=TRUE) 					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			aqm&lt;-melt(airquality, id=c(“Ozone”,”Solar.R”,”Wind”,”Temp”))					</span></a></li>
</ol>
<div class="eg1">
<a class="b2 help" href="#m-help1a7" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
<span class="t1">정답보기</span>
<i class="ic1"></i>
</a>
</div>
<div class="tg2 loaded" id="m-help1a7" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
<strong class="tt1">정답</strong>
<div class="t2">
<i class="t2n">1</i>
<span class="t2t1">
			aqm&lt;-melt(airquality, id=c(“Month”,”Day”), na.r m=TRUE) 			</span>
</div>
<br/>
<strong class="tt1">해설</strong>
<div class="t1">
		melt 함수는 데이터를 재구성하기 위한 함수로서 id는 month와 day이고 각 variable별로 value 값을 나타내고 NA값은 na.rm =TRUE로 제외했음을 알 수 있다.				</div>


<div class="more-c">
<strong class="tt1">비기봇 해설</strong>
<div class="t1">
				1. aqm &lt;- melt(airquality, id=c("Month","Day"), na.rm=TRUE)<br/>
이 명령어는 'Month'와 'Day'를 식별자로 사용하고, 나머지 변수들(Ozone, Solar.R, Wind, Temp)을 긴 형태로 변환하며 NA 값을 제거합니다. 따라서 오른쪽 형태로 변환하는데 적절합니다.<br/>
<br/>
2. aqm &lt;- melt(airquality, id=c("Month","Day"))<br/>
이 명령어도 'Month'와 'Day'를 식별자로 사용하여 나머지 변수들을 긴 형태로 변환합니다. 그러나 NA 값 제거 옵션이 없으므로 NA 값이 포함되므로 적절하지 않습니다.<br/>
<br/>
3.  aqm &lt;- melt(airquality, id=c("Ozone","Solar.R","Wind","Temp"), na.rm=TRUE)<br/>
이 명령어는 'Ozone', 'Solar.R', 'Wind', 'Temp'를 식별자로 사용합니다. 이는 적절하지 않습니다. 식별자로 사용되는 변수는 'Month'와 'Day'이어야 합니다.<br/>
<br/>
4. aqm &lt;- melt(airquality, id=c("Ozone","Solar.R","Wind","Temp"))<br/>
이 명령어도 'Ozone', 'Solar.R', 'Wind', 'Temp'를 식별자로 사용하므로 적절하지 않습니다.<br/>
</div>
<div class="t2">
									#R프로그램 출력 결과									# 데이터 정제									# melt()							</div>
</div>

</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
<div class="sg1">
<div class="w1">
<span class="g1">4과목</span>
<span class="g1">데이터변경 및 요약</span>
<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
</div>
</div>
<div class="tg1">
<strong class="tt1">
<span class="tt1n">8.</span>
<span class="tt1t1">
				"iris"라는 데이터셋에서 데이터의 내용을 조회할 때, R프로그램으로 적절한 것은?							</span>
</strong>
<span class="tt1t1">
</span>
</div>
<ol class="lst1">
<li class="li1"><a class="a1"><span class="t1">
			plyr("select*from iris")					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			sql("select*from iris")					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			mysql("select*from iris")					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			sqldf("select*from iris")					</span></a></li>
</ol>
<div class="eg1">
<a class="b2 help" href="#m-help1a8" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
<span class="t1">정답보기</span>
<i class="ic1"></i>
</a>
</div>
<div class="tg2 loaded" id="m-help1a8" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
<strong class="tt1">정답</strong>
<div class="t2">
<i class="t2n">4</i>
<span class="t2t1">
			sqldf("select*from iris")			</span>
</div>
<br/>
<strong class="tt1">해설</strong>
<div class="t1">
		sqldf 패키지는 R에서 sql의 명령어를 사용가능하게 해주는 패키지이다.				</div>


<div class="more-c">
<strong class="tt1">비기봇 해설</strong>
<div class="t1">
				정답은 4번입니다.<br/>
<br/>
R에서 데이터셋을 조회하거나 조작할 때, SQL 문법을 활용할 수 있는 패키지가 있습니다. 그 중 하나가 'sqldf' 패키지로, 이는 SQL 쿼리를 사용하여 데이터프레임을 조회할 수 있게 해줍니다. 예를 들어, 'sqldf("select * from iris")'는 iris 데이터셋의 모든 행과 열을 선택하는 SQL 쿼리입니다. 이는 SQL의 'SELECT * FROM' 구문을 사용하여 데이터프레임을 조회하는 방법을 제공합니다.<br/>
<br/>
1. plyr("select*from iris") <br/>
: plyr 패키지는 데이터 조작을 위한 다양한 함수들을 제공하지만, SQL 쿼리를 직접적으로 실행할 수 있는 기능은 없습니다. 따라서 'plyr("select*from iris")'는 문법적으로도 기능적으로도 맞지 않습니다.<br/>
<br/>
2. sql("select*from iris") <br/>
: sql 함수는 R에서 기본적으로 제공되지 않으며, SQL 쿼리를 실행하기 위해서는 적절한 패키지가 필요합니다. 따라서 'sql("select*from iris")'는 R에서 사용할 수 없는 구문입니다.<br/>
<br/>
3. mysql("select*from iris") <br/>
: mysql은 데이터베이스 관리 시스템으로, R에서 직접적으로 SQL 쿼리를 실행하기 위한 함수가 아닙니다. 따라서 'mysql("select*from iris")'는 R에서 사용할 수 없는 구문입니다.<br/>
<br/>
4. sqldf("select*from iris") <br/>
: sqldf 패키지는 R에서 SQL 쿼리를 사용하여 데이터프레임을 조회할 수 있게 해줍니다. 'sqldf("select*from iris")'는 iris 데이터셋의 모든 데이터를 조회하는 올바른 방법입니다. 이는 SQL의 'SELECT * FROM' 구문을 사용하여 데이터프레임을 조회하는 방법을 제공합니다.<br/>
<br/>
정답은 '4'입니다. 'sqldf' 패키지는 R에서 SQL 쿼리를 사용하여 데이터프레임을 조회할 수 있게 해주는 패키지입니다. 따라서 'sqldf("select*from iris")'는 iris 데이터셋을 조회하는 올바른 방법입니다. 나머지 선지들은 R에서 SQL 쿼리를 실행할 수 있는 적절한 방법이 아니며, 문법적으로도 맞지 않습니다.<br/>
따라서, 정답은 '4. sqldf("select*from iris")' 입니다.<br/>
</div>
<div class="t2">
									#R									# SQL									# sqldf									# 데이터프레임									# 데이터 조회							</div>
</div>

</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
<div class="sg1">
<div class="w1">
<span class="g1">4과목</span>
<span class="g1">데이터변경 및 요약</span>
<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
</div>
</div>
<div class="tg1">
<strong class="tt1">
<span class="tt1n">9.</span>
<span class="tt1t1">
				chickwts 데이터 프레임은 여섯가지 종류의 닭 사료 첨가물(feed)과 각 사료를 먹인 닭의 무게(weight)를 변수로 가진다. 아래의 (1)의 기초통계량과 각 feed별 weight의 평균을 계산하여, 아래 (2)와 같은 결과물을 만들기 위한 코드로 다음 중 가장 적절한 것은?							</span>
</strong>
<span class="tt1t1">
<a class="p1" href="exam1view1img1.php?img=c2f12de4-f1bd-12c7-ce1d-ef1e078a665b.jpg" rel="noopener" target="_blank" title="새 창">
<img alt="문제에 포함된 이미지" src="https://www.dataedupt.kr/data/img/question/c2f12de4-f1bd-12c7-ce1d-ef1e078a665b.jpg"/>
</a>
</span>
</div>
<ol class="lst1">
<li class="li1"><a class="a1"><span class="t1">
			ddply(chickwts, ,feed, groupmean=mean(weight))					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			ddply(chickwts, weight,feed, summarize, groupmean=mean(weight)) 					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			ddply(chickwts, ,feed, summarize, groupmean=mean(weight)) 					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			ddply(chickwts, weight,feed, groupmean=mean(weight))					</span></a></li>
</ol>
<div class="eg1">
<a class="b2 help" href="#m-help1a9" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
<span class="t1">정답보기</span>
<i class="ic1"></i>
</a>
</div>
<div class="tg2 loaded" id="m-help1a9" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
<strong class="tt1">정답</strong>
<div class="t2">
<i class="t2n">3</i>
<span class="t2t1">
			ddply(chickwts, ,feed, summarize, groupmean=mean(weight)) 			</span>
</div>
<br/>
<strong class="tt1">해설</strong>
<div class="t1">
		각 feed별 weight의 평균을 계산하기 위해서는 ,feed, summarize, mean이라는 명령어가 있는 것이 정답이다. 				</div>


<div class="more-c">
<strong class="tt1">비기봇 해설</strong>
<div class="t1">
				1. ddply(chickwts, ,feed, groupmean=mean(weight)) - 이 코드는 ddply 함수의 사용법에 맞지 않습니다. ddply 함수는 첫 번째 인자로 데이터 프레임을, 두 번째 인자로 그룹화할 변수를, 세 번째 인자로 적용할 함수를 받습니다. 여기서는 두 번째 인자가 누락되어 있습니다.<br/>
<br/>
2. ddply(chickwts, weight,feed, summarize, groupmean=mean(weight)) - 이 코드는 ddply 함수의 사용법에 맞지 않습니다. ddply 함수는 첫 번째 인자로 데이터 프레임을, 두 번째 인자로 그룹화할 변수를, 세 번째 인자로 적용할 함수를 받습니다. 여기서는 두 번째 인자가 weight로 잘못 설정되어 있습니다.<br/>
<br/>
3. ddply(chickwts, ,feed, summarize, groupmean=mean(weight)) - 이 코드는 ddply 함수를 올바르게 사용하였습니다. 첫 번째 인자로 데이터 프레임을, 두 번째 인자로 그룹화할 변수를, 세 번째 인자로 적용할 함수를 올바르게 설정하였습니다. 따라서 이 코드는 각 feed별 weight의 평균을 계산합니다.<br/>
<br/>
4. ddply(chickwts, weight,feed, groupmean=mean(weight)) - 이 코드는 ddply 함수의 사용법에 맞지 않습니다. ddply 함수는 첫 번째 인자로 데이터 프레임을, 두 번째 인자로 그룹화할 변수를, 세 번째 인자로 적용할 함수를 받습니다. 여기서는 두 번째 인자가 weight로 잘못 설정되어 있습니다.<br/>
</div>
<div class="t2">
									# ddply									# 데이터 프레임									# 그룹화									# 평균 계산									# 기초통계량									# R 프로그램 결과 출력									# R 프로그램 출력 결과							</div>
</div>

</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
<div class="sg1">
<div class="w1">
<span class="g1">4과목</span>
<span class="g1">데이터변경 및 요약</span>
<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
</div>
</div>
<div class="tg1">
<strong class="tt1">
<span class="tt1n">10.</span>
<span class="tt1t1">
				다음 중 결측치에 대한 설명으로 가장 부적절한 것은?							</span>
</strong>
<span class="tt1t1">
</span>
</div>
<ol class="lst1">
<li class="li1"><a class="a1"><span class="t1">
			해당 칸이 비어있는 경우 결측치 여부는 알기 쉽다.					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			관측치가 있지만 실상은 Default 값이 기록 된 경우에도 결측치로 처리해야 하는 것이 바람직하다. 					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			결측치가 있는 경우 다양한 대치(Imputation)방법을 사용하여 완전한 자료로 만든 후 분석을 진행할 수 있다.					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			결측치가 20% 이상인 경우에는 해당 변수를 제거하고 분석해야 한다.					</span></a></li>
</ol>
<div class="eg1">
<a class="b2 help" href="#m-help1a10" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
<span class="t1">정답보기</span>
<i class="ic1"></i>
</a>
</div>
<div class="tg2 loaded" id="m-help1a10" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
<strong class="tt1">정답</strong>
<div class="t2">
<i class="t2n">2</i>
<span class="t2t1">
			관측치가 있지만 실상은 Default 값이 기록 된 경우에도 결측치로 처리해야 하는 것이 바람직하다. 			</span>
</div>
<br/>
<strong class="tt1">해설</strong>
<div class="t1">
		관측치가 기록된 값을 결측치로 처리하여 분석에 활용하는 것은 옳지 않다. Default 값이 기록된 경우라도 그 값의 의미를 가지고 있기 때문에 결측치로 처리하면 분석에 큰 오류로 작용할 수도 있다.				</div>


<div class="more-c">
<strong class="tt1">비기봇 해설</strong>
<div class="t1">
				1. 해당 칸이 비어있는 경우 결측치 여부는 알기 쉽다. - 이 설명은 결측치를 확인하는 가장 기본적인 방법으로, 데이터셋에서 빈 칸이나 null 값이 있는지 확인하는 것이다. <br/>
<br/>
2. 관측치가 있지만 실상은 Default 값이 기록 된 경우에도 결측치로 처리해야 하는 것이 바람직하다. - 이 설명은 적절하지 않다. 실제로 데이터가 있지만 기본값이 기록 되었다고 해서 결측치로 처리하는 것은 바람직하지 않다.<br/>
<br/>
3. 결측치가 있는 경우 다양한 대치(Imputation)방법을 사용하여 완전한 자료로 만든 후 분석을 진행할 수 있다. - 이 설명은 결측치를 처리하는 방법 중 하나로, 평균, 중앙값, 최빈값 등으로 대치하거나 머신러닝 기법을 활용하여 대치할 수 있다. 따라서 이 설명은 적절하다.<br/>
<br/>
4. 결측치가 20% 이상인 경우에는 해당 변수를 제거하고 분석해야 한다. - 결측치가 20% 이상인 경우에는 해당 변수를 제거하고 분석하는 것이 바람직할 수 있다.<br/>
</div>
<div class="t2">
									#결측치									# 결측치 처리									# Default									# Imputation									# 대치 방법							</div>
</div>

</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
<div class="sg1">
<div class="w1">
<span class="g1">4과목</span>
<span class="g1">데이터변경 및 요약</span>
<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
</div>
</div>
<div class="tg1">
<strong class="tt1">
<span class="tt1n">11.</span>
<span class="tt1t1">
				다음은 결측값을 확인하고 결측값을 대치하는데 활용되는 R 함수들이다. 설명이 잘못된 것을 고르시오. 							</span>
</strong>
<span class="tt1t1">
</span>
</div>
<ol class="lst1">
<li class="li1"><a class="a1"><span class="t1">
			complete.cases( ) : 데이터 내 레코드에 결측값이 있으면 TRUE, 없으면 FALSE를 반환하는 함수					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			is.na( ) : 결측값이 NA인지 여부를 판단하여 반환하는 함수 					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			knnImputation( ) : NA값을 k 최근 이웃 분류 알고리즘을 사용하여 대치하는 함수로 k개 주변 이웃까지의 거리를 고려하여 가중 평균한 값을 대치해 주는 함수					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			rfImpute( ) : 랜덤 포레스트 모형의 경우, 결측값이 있으면 에러를 발생하기 때문에 랜덤포레스트 패키지에서 NA 결측값을 대치하도록 하는 함수					</span></a></li>
</ol>
<div class="eg1">
<a class="b2 help" href="#m-help1a11" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
<span class="t1">정답보기</span>
<i class="ic1"></i>
</a>
</div>
<div class="tg2 loaded" id="m-help1a11" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
<strong class="tt1">정답</strong>
<div class="t2">
<i class="t2n">1</i>
<span class="t2t1">
			complete.cases( ) : 데이터 내 레코드에 결측값이 있으면 TRUE, 없으면 FALSE를 반환하는 함수			</span>
</div>
<br/>
<strong class="tt1">해설</strong>
<div class="t1">
		complete.cases 함수는 레코드에 결측 값이 없으면 TRUE, 있으면 FALSE를 반환하는 함수이다.				</div>


<div class="more-c">
<strong class="tt1">비기봇 해설</strong>
<div class="t1">
				1. complete.cases( ) 함수는 데이터 내 레코드에 결측값이 없으면 TRUE, 있으면 FALSE를 반환하는 함수입니다. 따라서 설명이 잘못되었습니다.<br/>
<br/>
2. is.na( ) 함수는 말 그대로 결측값이 NA인지 여부를 판단하여 반환하는 함수입니다. 따라서 설명이 정확합니다.<br/>
<br/>
3. knnImputation( ) 함수는 k 최근 이웃 분류 알고리즘을 사용하여 NA값을 대치하는 함수로, k개 주변 이웃까지의 거리를 고려하여 가중 평균한 값을 대치해 주는 함수입니다. 따라서 설명이 정확합니다.<br/>
<br/>
4. rfImpute( ) 함수는 랜덤 포레스트 모형의 경우, 결측값이 있으면 에러를 발생하기 때문에 랜덤포레스트 패키지에서 NA 결측값을 대치하도록 하는 함수입니다. 따라서 설명이 정확합니다.<br/>
</div>
<div class="t2">
									# 결측값									# 대치									# R 함수									# completecases( )									# isna( )									# knnImputation( )									# rfImpute( )									# NA									# 랜덤 포레스트							</div>
</div>

</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
<div class="sg1">
<div class="w1">
<span class="g1">4과목</span>
<span class="g1">데이터변경 및 요약</span>
<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
</div>
</div>
<div class="tg1">
<strong class="tt1">
<span class="tt1n">12.</span>
<span class="tt1t1">
				결측값은 관측되어 얻어지는 실험 자료에서 종종 나타나는 현상이다. 결측값을 분석할 수 있는 통계분석 방법론으로 대치법이 있다. 다음 중 결측값을 처리하는 방법에 대한 설명 중 부적절한 것은?							</span>
</strong>
<span class="tt1t1">
</span>
</div>
<ol class="lst1">
<li class="li1"><a class="a1"><span class="t1">
			Complete Analysis는 불완전 자료를 모두 삭제하고 완전한 관측치만으로 자료를 분석하는 방법이다. 그러나 부분적 관측자료를 사용하므로 통계적 추론의 타당성 문제가 있다.					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			평균대치법은 자료의 평균값으로 결측값을 대치하여 불완전한 자료를 완전한 자료로 만들어 분석하는 방법이다.					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			단순확률 대치법은 평균 대치법에서 추정량 표준오차의 과소 추정문제를 보완하고자 고안된 방법이다.					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			다중 대치법은 단순 대치법을 한번하지 않고 m번 대치를 통해 m개의 가상적 완전 자료를 만들어서 분석하는 방법으로 순서는 1단계인 대치(imputation step), 2단계인 결합(combination step), 3단계인 분석(Analysis step)이다.					</span></a></li>
</ol>
<div class="eg1">
<a class="b2 help" href="#m-help1a12" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
<span class="t1">정답보기</span>
<i class="ic1"></i>
</a>
</div>
<div class="tg2 loaded" id="m-help1a12" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
<strong class="tt1">정답</strong>
<div class="t2">
<i class="t2n">4</i>
<span class="t2t1">
			다중 대치법은 단순 대치법을 한번하지 않고 m번 대치를 통해 m개의 가상적 완전 자료를 만들어서 분석하는 방법으로 순서는 1단계인 대치(imputation step), 2단계인 결합(combination step), 3단계인 분석(Analysis step)이다.			</span>
</div>
<br/>
<strong class="tt1">해설</strong>
<div class="t1">
		다중 대치법의 순서는 1단계인 대치(Imputation step), 2단계인 분석(Analysis step), 결합(Combination step)이다. 				</div>


<div class="more-c">
<strong class="tt1">비기봇 해설</strong>
<div class="t1">
				1번 보기에서는 Complete Analysis가 불완전한 자료를 모두 삭제하고 완전한 관측치만으로 자료를 분석하는 방법이라고 설명하고 있습니다. 이 방법은 부분적 관측자료를 사용하므로 통계적 추론의 타당성 문제가 있을 수 있습니다.<br/>
<br/>
2번 보기에서는 평균대치법이라는 결측값 처리 방법을 설명하고 있습니다. 이 방법은 자료의 평균값으로 결측값을 대치하여 불완전한 자료를 완전한 자료로 만들어 분석하는 방법입니다. 이는 결측값을 처리하는 적절한 방법입니다.<br/>
<br/>
3번 보기에서는 단순 확률대치법을 설명하고 있습니다. 이 방법은 평균대치법에서 추정량 표준오차의 과소 추정문제를 보완하고자 고안된 방법입니다. 이 역시 결측값을 처리하는 적절한 방법입니다.<br/>
<br/>
4번 보기에서 추정량의 과소추정이나 계산의 난해성 문제가 보완된 방법은 단순확률 대치법이므로, 잘못된 설명입니다.<br/>
</div>
<div class="t2">
									#결측치									# 결측치 처리									# 통계분석 방법론									# Complete Analysis									# 평균 대치법									# 닩순확률 대치법									# 다중 대치법									# imputation step									# combination step									# Analysis step							</div>
</div>

</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
<div class="sg1">
<div class="w1">
<span class="g1">4과목</span>
<span class="g1">데이터변경 및 요약</span>
<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
</div>
</div>
<div class="tg1">
<strong class="tt1">
<span class="tt1n">13.</span>
<span class="tt1t1">
				이상치를 찾는 것은 데이터 분석에서 데이터 전처리를 어떻게 할지 검정할 때 사용할 수 있다. 다음 중 상자그림을 이용하여 이상치를 판정하는 방법에 대한 설명으로 가장 부적절한 것은?							</span>
</strong>
<span class="tt1t1">
</span>
</div>
<ol class="lst1">
<li class="li1"><a class="a1"><span class="t1">
			IQR=Q3-Q1이라고 할 때, Q1-1.5*IQR&lt; X &lt;Q3+1.5*IQR을 벗어나는 X를 이상치라고 규정한다.					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			평균으로부터 3*표준편차 벗어나는 것들을 비정상이라 규정하고 제거한다.					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			이상치는 변수의 분포에서 벗어난 값으로 상자 그림을 통해 확인할 수 있다.					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			이상치는 분포를 왜곡할 수 있으나 실제 오류인자에 대해서는 통계적으로 실행하지 못하기 때문에 제거여부는 실무자들을 통해서 결정하는 것이 바람직하다.					</span></a></li>
</ol>
<div class="eg1">
<a class="b2 help" href="#m-help1a13" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
<span class="t1">정답보기</span>
<i class="ic1"></i>
</a>
</div>
<div class="tg2 loaded" id="m-help1a13" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
<strong class="tt1">정답</strong>
<div class="t2">
<i class="t2n">2</i>
<span class="t2t1">
			평균으로부터 3*표준편차 벗어나는 것들을 비정상이라 규정하고 제거한다.			</span>
</div>
<br/>
<strong class="tt1">해설</strong>
<div class="t1">
		‘이상치’라고 규정한 자료는 분석에서 제외를 할 수 있지만 무조건적으로 제거할 수 는 없다.				</div>


<div class="more-c">
<strong class="tt1">비기봇 해설</strong>
<div class="t1">
				정답은 2번입니다.<br/>
<br/>
이 문제는 상자그림(Box plot)을 이용한 이상치 판정 방법에 대한 이해를 평가합니다. 상자그림은 데이터의 분포를 시각적으로 표현하며, 이상치를 판정하는 데 유용한 도구입니다. 일반적으로 IQR(Interquartile Range)을 이용하여 이상치를 판정합니다.<br/>
<br/>
1. IQR=Q3-Q1이라고 할 때, Q1-1.5*IQR&lt; X &lt;Q3+1.5*IQR을 벗어나는 X를 이상치라고 규정한다.<br/>
: IQR을 이용한 이상치 판정은 상자그림에서 흔히 사용되는 방법입니다. Q1과 Q3는 각각 1사분위수와 3사분위수를 의미하며, 이 범위를 벗어나는 값을 이상치로 간주합니다.<br/>
<br/>
2. 평균으로부터 3*표준편차 벗어나는 것들을 비정상이라 규정하고 제거한다.<br/>
: 평균과 표준편차를 이용한 방법은 상자그림과는 다른 통계적 방법입니다. 이는 정규분포를 가정할 때 사용되며, 상자그림과는 직접적인 관련이 없습니다.<br/>
<br/>
3. 이상치는 변수의 분포에서 벗어난 값으로 상자 그림을 통해 확인할 수 있다.<br/>
: 상자그림은 데이터의 분포를 시각적으로 보여주며, 이상치를 확인하는 데 유용합니다. 이는 상자그림의 기본적인 기능 중 하나입니다.<br/>
<br/>
4. 이상치는 분포를 왜곡할 수 있으나 실제 오류인자에 대해서는 통계적으로 실행하지 못하기 때문에 제거여부는 실무자들을 통해서 결정하는 것이 바람직하다.<br/>
: 이상치는 데이터 분석에 영향을 미칠 수 있으며, 제거 여부는 데이터의 특성과 분석 목적에 따라 결정해야 합니다. 이는 실무적인 판단이 필요합니다.<br/>
<br/>
<br/>
정답은 2번입니다. 상자그림을 이용한 이상치 판정은 IQR을 기준으로 하며, 평균과 표준편차를 이용한 방법은 상자그림과는 다른 방법입니다. 따라서 2번이 상자그림을 이용한 이상치 판정 방법에 대한 설명으로 부적절합니다.<br/>
<br/>
따라서, 정답은 '2. 평균으로부터 3*표준편차 벗어나는 것들을 비정상이라 규정하고 제거한다.' 입니다.<br/>
</div>
<div class="t2">
									#상자그림									# IQR									# 이상치									# 표준편차							</div>
</div>

</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
<div class="sg1">
<div class="w1">
<span class="g1">4과목</span>
<span class="g1">데이터변경 및 요약</span>
<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
</div>
</div>
<div class="tg1">
<strong class="tt1">
<span class="tt1n">14.</span>
<span class="tt1t1">
				다음 중 이상값 검색을 활용한 응용시스템으로 가장 적절한 것은?							</span>
</strong>
<span class="tt1t1">
</span>
</div>
<ol class="lst1">
<li class="li1"><a class="a1"><span class="t1">
			장바구니분석 시스템					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			데이터 마트 					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			교차판매 시스템 					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			부정사용방지 시스템					</span></a></li>
</ol>
<div class="eg1">
<a class="b2 help" href="#m-help1a14" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
<span class="t1">정답보기</span>
<i class="ic1"></i>
</a>
</div>
<div class="tg2 loaded" id="m-help1a14" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
<strong class="tt1">정답</strong>
<div class="t2">
<i class="t2n">4</i>
<span class="t2t1">
			부정사용방지 시스템			</span>
</div>
<br/>
<strong class="tt1">해설</strong>
<div class="t1">
		이상값을 검색하여 한 집단에서 매우 크거나, 매우 작으면 의심되는 대상이므로 부정사용방지 시스템에 활용이 가능하다. 				</div>


<div class="more-c">
<strong class="tt1">비기봇 해설</strong>
<div class="t1">
				정답은 4번입니다.<br/>
<br/>
이상값 검색은 데이터 분석에서 비정상적이거나 예외적인 데이터를 식별하는 과정입니다. 이는 주로 데이터의 무결성을 확인하거나, 비정상적인 패턴을 탐지하는 데 사용됩니다. 예를 들어, 금융 거래에서의 사기 탐지, 네트워크 보안에서의 침입 탐지 등이 있습니다. 이러한 이상값 검색은 데이터의 정상적인 패턴에서 벗어난 데이터를 식별하여 문제를 예방하거나 해결하는 데 중요한 역할을 합니다.<br/>
<br/>
1. 장바구니분석 시스템 <br/>
: 장바구니 분석 시스템은 고객이 구매하는 상품 간의 연관성을 분석하여 교차판매를 촉진하는 데 사용됩니다. 이는 주로 연관성 분석을 통해 고객의 구매 패턴을 파악하고, 관련 상품을 추천하는 방식으로 이루어집니다. 이상값 검색보다는 연관성 분석에 더 적합한 시스템입니다.<br/>
<br/>
2. 데이터 마트 <br/>
: 데이터 마트는 특정 비즈니스 기능을 지원하기 위해 설계된 데이터 저장소로, 주로 데이터 분석과 보고를 용이하게 하기 위해 사용됩니다. 데이터 마트 자체는 이상값 검색보다는 데이터의 저장과 관리에 중점을 둡니다.<br/>
<br/>
3. 교차판매 시스템 <br/>
: 교차판매 시스템은 고객이 구매한 상품과 관련된 다른 상품을 추천하여 추가 판매를 유도하는 시스템입니다. 이는 주로 연관성 분석을 통해 이루어지며, 이상값 검색과는 직접적인 관련이 없습니다.<br/>
<br/>
4. 부정사용방지 시스템 <br/>
: 부정사용방지 시스템은 이상값 검색을 활용하여 비정상적인 패턴이나 행동을 탐지하고, 이를 통해 사기나 부정 사용을 방지하는 시스템입니다. 예를 들어, 금융 거래에서 비정상적인 거래를 탐지하여 사기를 예방하는 데 사용됩니다. 이는 이상값 검색의 대표적인 응용 사례입니다.<br/>
<br/>
부정사용방지 시스템은 이상값 검색을 통해 비정상적인 패턴을 탐지하여 부정 사용을 방지하는 데 중점을 둡니다. 다른 선택지들은 이상값 검색보다는 다른 분석 기법에 중점을 두고 있습니다.<br/>
<br/>
따라서, 정답은 '4. 부정사용방지 시스템' 입니다.<br/>
</div>
<div class="t2">
									#이상값 검색									# 부정사용방지									# 사기 탐지									# 연관성 분석									# 데이터 마트							</div>
</div>

</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
<div class="sg1">
<div class="w1">
<span class="g1">4과목</span>
<span class="g1">데이터변경 및 요약</span>
<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
</div>
</div>
<div class="tg1">
<strong class="tt1">
<span class="tt1n">15.</span>
<span class="tt1t1">
				이상치에 대한 설명으로 가장 부적절한 것은?							</span>
</strong>
<span class="tt1t1">
</span>
</div>
<ol class="lst1">
<li class="li1"><a class="a1"><span class="t1">
			군집분석을 이용하여 다른 데이터들과 거리상 멀리 떨어진 데이터를 이상치로 판정한다. 					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			이상치는 분석 결과를 왜곡하기 때문에 반드시 삭제한 후 분석한다. 					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			특정 조건(문맥)에서 그 값 자체는 이상하지 않지만, 상황(시간, 장소, 그룹)에서는 이상한 경우 이상치로 정의한다.					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			통상 평균으로부터 표준편차의 3배가 되는 점을 기준으로 이상치를 정의한다.					</span></a></li>
</ol>
<div class="eg1">
<a class="b2 help" href="#m-help1a15" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
<span class="t1">정답보기</span>
<i class="ic1"></i>
</a>
</div>
<div class="tg2 loaded" id="m-help1a15" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
<strong class="tt1">정답</strong>
<div class="t2">
<i class="t2n">2</i>
<span class="t2t1">
			이상치는 분석 결과를 왜곡하기 때문에 반드시 삭제한 후 분석한다. 			</span>
</div>
<br/>
<strong class="tt1">해설</strong>
<div class="t1">
		이상치는 분석에 의미가 있을 수 있으므로 제거하면 안된다.				</div>


<div class="more-c">
<strong class="tt1">비기봇 해설</strong>
<div class="t1">
				정답은 2번입니다.<br/>
<br/>
이상치는 데이터 분석에서 중요한 개념으로, 데이터의 분포에서 벗어난 값들을 의미합니다. 이상치는 분석 결과에 큰 영향을 미칠 수 있기 때문에 적절한 처리가 필요합니다.<br/>
<br/>
1. 군집분석을 이용하여 다른 데이터들과 거리상 멀리 떨어진 데이터를 이상치로 판정한다.<br/>
: 군집분석은 데이터의 유사성을 기반으로 그룹을 형성하는 방법으로, 이상치를 판별하는 데 유용할 수 있습니다. 그러나 군집분석만으로 이상치를 판정하는 것은 일반적이지 않습니다.<br/>
<br/>
2. 이상치는 분석 결과를 왜곡하기 때문에 반드시 삭제한 후 분석한다.<br/>
: 이상치를 무조건 삭제하는 것은 데이터의 중요한 정보를 잃을 수 있는 위험이 있습니다. 따라서 이상치를 삭제하기 전에 그 원인을 분석하고, 적절한 처리 방법을 선택하는 것이 중요합니다.<br/>
<br/>
3. 특정 조건(문맥)에서 그 값 자체는 이상하지 않지만, 상황(시간, 장소, 그룹)에서는 이상한 경우 이상치로 정의한다.<br/>
: 데이터 값 자체는 일반적인 범위에 속하지만, 특정 조건(문맥, Context)에서 보면 비정상적인 경우, 즉, 그 값이 시간, 장소, 그룹 등 특정 상황에서 기대되는 값과 비교해볼 때 이상한 것을 군집 이상치(문맥적 이상치, Contextual Outlier) 라고 합니다.<br/>
<br/>
4. 통상 평균으로부터 표준편차의 3배가 되는 점을 기준으로 이상치를 정의한다.<br/>
: 평균으로부터 표준편차의 3배 이상 떨어진 값을 이상치로 정의하는 것은 통계적으로 흔히 사용되는 방법입니다. 이는 정규분포를 가정할 때 유용한 기준입니다.<br/>
<br/>
<br/>
이상치를 반드시 삭제해야 한다는 것은 부적절한 설명입니다. 이상치는 분석 결과에 영향을 미칠 수 있지만, 무조건 삭제하기보다는 그 원인을 파악하고 적절한 방법으로 처리하는 것이 중요합니다. 다른 선택지들은 이상치의 정의나 판별 방법에 대한 적절한 설명을 포함하고 있습니다.<br/>
<br/>
따라서, 정답은 '2. 이상치는 분석 결과를 왜곡하기 때문에 반드시 삭제한 후 분석한다.' 입니다.<br/>
</div>
<div class="t2">
									#이상치									# 군집분석									# 데이터 분석									# 표준편차							</div>
</div>

</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
<div class="sg1">
<div class="w1">
<span class="g1">4과목</span>
<span class="g1">데이터변경 및 요약</span>
<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
</div>
</div>
<div class="tg1">
<strong class="tt1">
<span class="tt1n">16.</span>
<span class="tt1t1">
				다음은 이상값(Outlier)에 대한 설명이다. 잘못 설명한 내용을 고르시오.							</span>
</strong>
<span class="tt1t1">
</span>
</div>
<ol class="lst1">
<li class="li1"><a class="a1"><span class="t1">
			부정사용방지 시스템이나 부도예측시스템에서는 이상값(Outlier)이라도 의미가 있으므로 제거하지 않는다. 					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			이상값 인식에 있어서 가장 많이 활용하는 방법은 ESD(Extreme Studentized Deviation)으로 평균에서 3 표준편차를 벗어나는 경우 이상값으로 인식하는 방법이다.					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			이상값의 처리에 있어서 극단값 절단 방법과 조정 방법이 있으며 조정의 경우, 제거 방법에 비해 데이터 손실율이 높아 설명력이 낮아지는 단점이 있다. 					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			의도하지 않게 잘못 입력된 데이터인 경우 Bad Data에 해당되며 이러한 경우, 데이터를 제거하여 분석한다.					</span></a></li>
</ol>
<div class="eg1">
<a class="b2 help" href="#m-help1a16" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
<span class="t1">정답보기</span>
<i class="ic1"></i>
</a>
</div>
<div class="tg2 loaded" id="m-help1a16" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
<strong class="tt1">정답</strong>
<div class="t2">
<i class="t2n">3</i>
<span class="t2t1">
			이상값의 처리에 있어서 극단값 절단 방법과 조정 방법이 있으며 조정의 경우, 제거 방법에 비해 데이터 손실율이 높아 설명력이 낮아지는 단점이 있다. 			</span>
</div>
<br/>
<strong class="tt1">해설</strong>
<div class="t1">
		이상치를 절단이나 조정하는 경우 제거방법에 비해 데이터의 손실율이 낮아지기 때문에 설명력이 높아지는 장점이 생긴다. 				</div>


<div class="more-c">
<strong class="tt1">비기봇 해설</strong>
<div class="t1">
				정답은 3번입니다.<br/>
<br/>
이상값(Outlier)은 데이터 분석에서 일반적인 패턴에서 벗어난 데이터를 의미합니다. 이러한 이상값은 데이터의 오류로 인해 발생할 수도 있고, 실제로 중요한 정보를 담고 있을 수도 있습니다. 이상값을 인식하는 방법 중 하나는 ESD(Extreme Studentized Deviation)로, 이는 평균에서 3 표준편차를 벗어나는 값을 이상값으로 간주합니다. 이상값 처리 방법에는 극단값 절단과 조정 방법이 있으며, 극단값 절단은 데이터의 일부를 제거하는 반면, 조정 방법은 데이터를 수정하여 분석에 포함시킵니다. 이상값이 의미 있는 경우에는 제거하지 않고 분석에 포함시켜야 하며, 잘못 입력된 데이터는 제거하는 것이 일반적입니다.<br/>
<br/>
1. 부정사용방지 시스템이나 부도예측시스템에서는 이상값(Outlier)이라도 의미가 있으므로 제거하지 않는다. <br/>
: 부정사용방지 시스템이나 부도예측시스템에서는 이상값이 중요한 정보를 담고 있을 수 있기 때문에 제거하지 않고 분석에 포함시킵니다. 이는 이상값이 단순한 오류가 아니라 중요한 패턴을 나타낼 수 있기 때문입니다.<br/>
<br/>
2. 이상값 인식에 있어서 가장 많이 활용하는 방법은 ESD(Extreme Studentized Deviation)으로 평균에서 3 표준편차를 벗어나는 경우 이상값으로 인식하는 방법이다. <br/>
: ESD는 평균에서 3 표준편차를 벗어나는 값을 이상값으로 인식하는 방법입니다. 이는 통계적으로 이상값을 식별하는 데 널리 사용되는 방법으로, 데이터의 분포를 이해하는 데 도움을 줍니다.<br/>
<br/>
3. 이상값의 처리에 있어서 극단값 절단 방법과 조정 방법이 있으며 조정의 경우, 제거 방법에 비해 데이터 손실율이 높아 설명력이 낮아지는 단점이 있다. <br/>
: 극단값 절단 방법은 데이터를 제거하는 방식으로, 조정 방법에 비해 데이터 손실율이 높지 않습니다. 오히려 조정 방법이 데이터 손실율이 적고 설명력이 높습니다. 따라서 이 선지는 잘못된 설명입니다.<br/>
<br/>
4. 의도하지 않게 잘못 입력된 데이터인 경우 Bad Data에 해당되며 이러한 경우, 데이터를 제거하여 분석한다. <br/>
: 의도하지 않게 잘못 입력된 데이터는 Bad Data로 간주되며, 이러한 경우에는 데이터를 제거하여 분석하는 것이 일반적입니다. 이는 데이터의 정확성을 높이기 위한 조치입니다.<br/>
<br/>
선지 3은 극단값 절단 방법과 조정 방법에 대한 설명이 잘못되었습니다. 조정 방법은 데이터 손실율이 적고 설명력이 높기 때문에, 극단값 절단 방법에 비해 더 나은 방법으로 평가됩니다. 나머지 선지들은 이상값의 처리와 인식에 대한 올바른 설명을 제공하고 있습니다.<br/>
따라서, 정답은 '3. 이상값의 처리에 있어서 극단값 절단 방법과 조정 방법이 있으며 조정의 경우, 제거 방법에 비해 데이터 손실율이 높아 설명력이 낮아지는 단점이 있다.' 입니다.<br/>
</div>
<div class="t2">
									#이상값									# ESD									# 극단값 절단									# 조정 방법									# 데이터 손실							</div>
</div>

</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
<div class="sg1">
<div class="w1">
<span class="g1">4과목</span>
<span class="g1">데이터변경 및 요약</span>
<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
</div>
</div>
<div class="tg1">
<strong class="tt1">
<span class="tt1n">17.</span>
<span class="tt1t1">
				결측치(Missing data) 핸들링은 데이터분석을 위한 전처리 작업에서 가장 중요한 단계 중에 하나이다. R 프로그램에서 결측치의 표현으로 맞는 것은?							</span>
</strong>
<span class="tt1t1">
</span>
</div>
<ol class="lst1">
<li class="li1"><a class="a1"><span class="t1">
			Missing					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			999999999					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			NaN(Not a Number) 					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			NA(Not Available)					</span></a></li>
</ol>
<div class="eg1">
<a class="b2 help" href="#m-help1a17" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
<span class="t1">정답보기</span>
<i class="ic1"></i>
</a>
</div>
<div class="tg2 loaded" id="m-help1a17" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
<strong class="tt1">정답</strong>
<div class="t2">
<i class="t2n">4</i>
<span class="t2t1">
			NA(Not Available)			</span>
</div>
<br/>
<strong class="tt1">해설</strong>
<div class="t1">
		R에서는 결측값을 NA(not available)로 처리한다.				</div>


<div class="more-c">
<strong class="tt1">비기봇 해설</strong>
<div class="t1">
				정답은 4번입니다.<br/>
<br/>
결측치(Missing data)는 데이터 분석에서 매우 중요한 문제로, 데이터의 완전성을 보장하기 위해 반드시 처리해야 합니다. R 프로그램에서는 결측치를 'NA'로 표현합니다. 이는 'Not Available'의 약자로, 데이터가 존재하지 않음을 나타냅니다. 결측치를 처리하는 방법에는 여러 가지가 있으며, 대표적으로 결측치를 제거하거나 대체하는 방법이 있습니다. R에서는 'is.na()' 함수를 사용하여 결측치를 확인할 수 있으며, 'na.rm' 옵션을 통해 결측치를 무시하고 계산을 수행할 수 있습니다.<br/>
<br/>
1. Missing <br/>
: R에서 결측치를 'Missing'으로 표현하지 않습니다. 'Missing'은 결측치의 일반적인 개념을 설명하는 용어일 뿐, R에서의 결측치 표현과는 다릅니다. 따라서 이 선지는 R의 결측치 표현과 관련이 없습니다.<br/>
<br/>
2. 999999999 <br/>
: 999999999와 같은 특정 숫자를 결측치로 사용하는 경우도 있지만, 이는 데이터셋의 특수한 경우에 해당하며, R의 기본 결측치 표현 방식과는 다릅니다. R에서는 결측치를 'NA'로 표현하므로 이 선지는 오답입니다.<br/>
<br/>
3. NaN(Not a Number) <br/>
: NaN은 'Not a Number'의 약자로, 수학적으로 정의되지 않은 연산의 결과를 나타냅니다. 이는 결측치와는 다른 개념으로, R에서 결측치를 나타내는 표현이 아닙니다. 따라서 이 선지는 오답입니다.<br/>
<br/>
4. NA(Not Available) <br/>
: R에서 결측치는 'NA'로 표현됩니다. 이는 'Not Available'의 약자로, 데이터가 존재하지 않음을 나타냅니다. R의 결측치 처리 함수들은 'NA'를 기준으로 작동하므로, 이 선지가 정답입니다.<br/>
<br/>
R에서 결측치는 'NA'로 표현되며, 이는 'Not Available'의 약자입니다. 'is.na()'와 같은 함수는 'NA'를 기준으로 결측치를 확인합니다. 다른 선지들은 R의 결측치 표현과 관련이 없거나 다른 개념을 설명하고 있습니다.<br/>
따라서, 정답은 '4. NA(Not Available)' 입니다.<br/>
</div>
<div class="t2">
									#결측치									# NA									# R 프로그래밍									# 데이터 전처리									# is.na()							</div>
</div>

</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
<div class="sg1">
<div class="w1">
<span class="g1">4과목</span>
<span class="g1">데이터변경 및 요약</span>
<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
</div>
</div>
<div class="tg1">
<strong class="tt1">
<span class="tt1n">18.</span>
<span class="tt1t1">
				데이터 전처리 단계에서 데이터의 이상치(Outlier)에 대한 설명으로 틀린 것은?							</span>
</strong>
<span class="tt1t1">
</span>
</div>
<ol class="lst1">
<li class="li1"><a class="a1"><span class="t1">
			최댓값과 최솟값 					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			데이터 입력 시 오타로 인해 잘못 입력된 경우 					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			분석 목적에 부합되지 않아 제거해야 하는 경우 					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			부정사용방지 시스템에서 의도된 이상 값					</span></a></li>
</ol>
<div class="eg1">
<a class="b2 help" href="#m-help1a18" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
<span class="t1">정답보기</span>
<i class="ic1"></i>
</a>
</div>
<div class="tg2 loaded" id="m-help1a18" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
<strong class="tt1">정답</strong>
<div class="t2">
<i class="t2n">1</i>
<span class="t2t1">
			최댓값과 최솟값 			</span>
</div>
<br/>
<strong class="tt1">해설</strong>
<div class="t1">
		최댓값과 최솟값은 이상치(Outlier)로 볼 수 없다.				</div>


<div class="more-c">
<strong class="tt1">비기봇 해설</strong>
<div class="t1">
				1. 최댓값과 최솟값은 데이터의 범위를 나타내는 값들로, 자체적으로 이상치를 의미하지는 않습니다. 그러나 이들 값이 다른 값들과 비교하여 극단적으로 높거나 낮을 경우, 이상치로 간주될 수 있습니다.<br/>
<br/>
2. 데이터 입력 시 발생하는 오타는 이상치를 생성하는 일반적인 원인 중 하나입니다. 예를 들어, 사람의 키를 입력하는데 '180cm' 대신 '1800cm'를 입력하면 이는 명백한 이상치가 됩니다.<br/>
<br/>
3. 분석 목적에 부합되지 않는 데이터는 이상치로 간주될 수 있습니다. 예를 들어, 특정 연령대를 대상으로 한 분석에서 다른 연령대의 데이터는 이상치로 간주될 수 있습니다.<br/>
<br/>
4. 부정사용방지 시스템에서 의도된 이상값은 이상치로 간주됩니다. 예를 들어, 사용자의 정상적인 거래 패턴과 크게 다른 거래가 발생하면, 이는 이상치로 간주되어 부정사용을 탐지하는 데 사용될 수 있습니다.<br/>
</div>
<div class="t2">
									# 데이터 전처리									# 이상치(Outlier)									# 최댓값과 최솟값									# 데이터 입력 오류									# 분석 목적									# 부정사용방지 시스템							</div>
</div>

</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
<div class="sg1">
<div class="w1">
<span class="g1">4과목</span>
<span class="g1">데이터변경 및 요약</span>
<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
</div>
</div>
<div class="tg1">
<strong class="tt1">
<span class="tt1n">19.</span>
<span class="tt1t1">
				아래는 이상치(Outlier) 탐지에 대한 설명이다. 다음 중 이상치를 유용하게 사용하는 분야의 예로 부적절한 것은?					
					<span class="tt1t1">
						&lt;아래&gt;<br/>
이상치(Outlier) 탐지의 목적은 대부분의 객체들과 다른 객체들을 찾는 것이다. 이상치 탐지는 속성값들의 일반적인 값들과 상당히 편차가 큰 값을 가지므로 편차 탐지(deviation detection) 라고도 한다. 그러나 이상치는 반드시 비정상적인 객체를 의미하지는 않는다.					</span>
</span>
</strong>
<span class="tt1t1">
</span>
</div>
<ol class="lst1">
<li class="li1"><a class="a1"><span class="t1">
			사기탐지 - 도난당한 신용카드의 구매 행위는 원 소유자의 행위와 다를 수 있다. 평상시의 행위와 다른 구매패턴을 조사하여 사기를 탐지할 수 있다.					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			환경파괴 - 자연 세계에서는 환경에 중요한 영향을 줄 수 있는 홍수, 가뭄 같은 사건들이 있다. 그러나 이러한 사건은 정상적인 환경에서 발생하는 사건으로 해석할 수 있다.					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			의료 – 특정 환자에게 보이는 예외적인 증세나 검사 결과는 잠재적인 건강 문제를 나타낸다. 					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			침입탐지 - 컴퓨터 네트워크에 대한 공격은 보편화되었다. 침입의 다수는 네트워크에 대한 예외적인 행위를 감시하는 경우에 탐지할 수 있다.					</span></a></li>
</ol>
<div class="eg1">
<a class="b2 help" href="#m-help1a19" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
<span class="t1">정답보기</span>
<i class="ic1"></i>
</a>
</div>
<div class="tg2 loaded" id="m-help1a19" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
<strong class="tt1">정답</strong>
<div class="t2">
<i class="t2n">2</i>
<span class="t2t1">
			환경파괴 - 자연 세계에서는 환경에 중요한 영향을 줄 수 있는 홍수, 가뭄 같은 사건들이 있다. 그러나 이러한 사건은 정상적인 환경에서 발생하는 사건으로 해석할 수 있다.			</span>
</div>
<br/>
<strong class="tt1">해설</strong>
<div class="t1">
		이상치 탐지에 활용할 수 있는 분야는 사기탐지, 의료, 침입탐지 등에 활용이 가능하지 환경 파괴에는 적용하기 어렵다. 				</div>


<div class="more-c">
<strong class="tt1">비기봇 해설</strong>
<div class="t1">
				정답은 2번입니다.<br/>
<br/>
이상치 탐지는 데이터 분석에서 비정상적인 데이터를 식별하는 과정으로, 다양한 분야에서 활용됩니다. 이상치는 일반적인 패턴에서 벗어난 데이터를 의미하며, 이를 통해 특정한 문제나 사건을 감지할 수 있습니다.<br/>
<br/>
1. 사기탐지 - 도난당한 신용카드의 구매 행위는 원 소유자의 행위와 다를 수 있다. 평상시의 행위와 다른 구매패턴을 조사하여 사기를 탐지할 수 있다.<br/>
: 사기탐지에서는 비정상적인 구매 패턴을 통해 사기 행위를 감지할 수 있습니다. 이는 이상치 탐지의 전형적인 활용 사례입니다.<br/>
<br/>
2. 환경파괴 - 자연 세계에서는 환경에 중요한 영향을 줄 수 있는 홍수, 가뭄 같은 사건들이 있다. 그러나 이러한 사건은 정상적인 환경에서 발생하는 사건으로 해석할 수 있다.<br/>
: 환경파괴의 경우, 홍수나 가뭄 같은 사건은 자연적인 현상으로, 이상치로 간주되지 않습니다. 이는 정상적인 환경에서 발생할 수 있는 사건으로 해석됩니다.<br/>
<br/>
3. 의료 – 특정 환자에게 보이는 예외적인 증세나 검사 결과는 잠재적인 건강 문제를 나타낸다.<br/>
: 의료 분야에서는 환자의 예외적인 증세나 검사 결과를 통해 잠재적인 건강 문제를 조기에 발견할 수 있습니다. 이는 이상치 탐지의 중요한 활용 사례입니다.<br/>
<br/>
4. 침입탐지 - 컴퓨터 네트워크에 대한 공격은 보편화되었다. 침입의 다수는 네트워크에 대한 예외적인 행위를 감시하는 경우에 탐지할 수 있다.<br/>
: 침입탐지에서는 네트워크에 대한 비정상적인 행위를 감시하여 침입을 탐지할 수 있습니다. 이는 이상치 탐지의 대표적인 활용 사례입니다.<br/>
<br/>
<br/>
환경파괴의 경우, 홍수나 가뭄 같은 사건은 자연적인 현상으로 간주되며, 이상치로 해석되지 않습니다. 따라서 이는 이상치를 유용하게 사용하는 분야의 예로 부적절합니다. 다른 선택지들은 모두 이상치 탐지를 통해 문제를 감지하거나 해결할 수 있는 분야입니다.<br/>
<br/>
따라서, 정답은 '2. 환경파괴 - 자연 세계에서는 환경에 중요한 영향을 줄 수 있는 홍수, 가뭄 같은 사건들이 있다. 그러나 이러한 사건은 정상적인 환경에서 발생하는 사건으로 해석할 수 있다.' 입니다.<br/>
</div>
<div class="t2">
									#이상치 탐지									# 사기탐지									# 환경파괴									# 의료									# 침입탐지							</div>
</div>

</div>
</div>
<!-- /cp1question1 -->





<script>
/* === AUTO-PATCH: answer-toggle-v2 === */
(function () {
  function qsa(sel, root) { return Array.from((root || document).querySelectorAll(sel)); }
  function qs(sel, root) { return (root || document).querySelector(sel); }

  function getPanelFromBtn(btn) {
    const href = btn && btn.getAttribute('href');
    if (!href || !href.startsWith('#')) return null;
    return document.querySelector(href);
  }

  function setHelpLabel(btn, open) {
    const t = btn ? btn.querySelector('.t1') : null;
    if (t) t.textContent = open ? '정답닫기' : '정답보기';
    if (btn) btn.setAttribute('aria-expanded', String(open));
  }

  function panelIsOpen(panel) {
    if (!panel) return false;
    if (panel.style.display) return panel.style.display !== 'none';
    return getComputedStyle(panel).display !== 'none';
  }

  function openPanel(btn, panel) {
    if (!panel) return;
    panel.style.display = 'block';
    panel.classList.add('loaded');     // 기존 테마 연동
    setHelpLabel(btn, true);
  }

  function closePanel(btn, panel) {
    if (!panel) return;
    panel.style.display = 'none';
    setHelpLabel(btn, false);
  }

  // ✅ 전체 정답 보기/닫기
  window.controlAllAnswers = function (show) {
    qsa('.tg2').forEach(panel => {
      panel.style.display = show ? 'block' : 'none';
      if (show) panel.classList.add('loaded');
    });
    qsa('a.b2.help').forEach(btn => setHelpLabel(btn, show));
  };

  // ✅ 개별 정답보기 토글 (이게 없으면 "클릭해도 아무 동작 없음")
  function onHelpClick(e) {
    const btn = e.target.closest('a.b2.help[href^="#"]');
    if (!btn) return;
    e.preventDefault();

    const panel = getPanelFromBtn(btn);
    if (!panel) return;

    panelIsOpen(panel) ? closePanel(btn, panel) : openPanel(btn, panel);
  }

  // ✅ 보기 클릭 → 정오답 판정 + s1/s2 적용 + 자동 정답보기
  function onOptionPick(e) {
    const li = e.target.closest('.cp1question1 .lst1 .li1');
    if (!li) return;

    const qBox = li.closest('.cp1question1');
    if (!qBox) return;

    const btn = qs('a.b2.help[href^="#"]', qBox);
    const panel = getPanelFromBtn(btn);

    // 정답 번호(i.t2n)는 해설 패널 안에 있음(1-based)
    const n = panel ? panel.querySelector('i.t2n') : null;
    const correctIdx = n ? parseInt((n.textContent || '').trim(), 10) : NaN;

    const options = qsa('.lst1 .li1', qBox);
    const idx = options.indexOf(li) + 1; // 1-based

    if (!Number.isFinite(correctIdx) || correctIdx <= 0) return;

    const isCorrect = idx === correctIdx;
    qBox.setAttribute('data-answer-state', isCorrect ? 'correct' : 'wrong');

    // 헤더 표시 (정답 s1 | 오답 s2)
    const b = qs('.w1 b', qBox);
    if (b) b.className = isCorrect ? 's1' : 's2';

    // 보기에도 클래스 부여(원하면 CSS로 강조)
    options.forEach((opt, i) => {
      opt.classList.remove('is-correct', 'is-wrong');
      if (i + 1 === correctIdx) opt.classList.add('is-correct');
    });
    li.classList.add(isCorrect ? 'is-correct' : 'is-wrong');

    // 자동 정답보기
    openPanel(btn, panel);
  }

  // capture로 등록: 다른 스크립트가 click을 막아도 최대한 동작
  document.addEventListener('click', onHelpClick, true);
  document.addEventListener('click', onOptionPick, true);
})();
</script>

<!-- AUTO:score-counter start -->
<script>
(function () {
  function qsa(sel, root) { return Array.from((root || document).querySelectorAll(sel)); }
  function qs(sel, root) { return (root || document).querySelector(sel); }

  function setText(el, n) {
    if (!el) return;
    el.textContent = String(n) + '개';
  }

  function updateTotal(total) {
    const block = qs('.cp1dlist2');
    if (!block) return;
    qsa('.cp1dlist2 .di1', block).forEach(li => {
      const label = (qs('.dt1', li)?.textContent || '').trim();
      if (label === '총 문제') {
        const dd = qs('.dd1', li);
        if (dd) dd.textContent = String(total) + '개';
      }
    });
  }

  function getPanelFromQ(qBox) {
    const btn = qBox.querySelector('a.b2.help[href^="#"]');
    if (!btn) return null;
    const href = btn.getAttribute('href');
    if (!href || !href.startsWith('#')) return null;
    return document.querySelector(href);
  }

  function getCorrectIndex(panel) {
    const n = panel ? panel.querySelector('i.t2n') : null;
    if (!n) return null;
    const v = parseInt((n.textContent || '').trim(), 10);
    return Number.isFinite(v) ? v : null; // 1-based
  }

  function recompute() {
    const total = qsa('.cp1question1').length;
    let correct = 0;
    let wrong = 0;

    qsa('.cp1question1').forEach(qBox => {
      const state = qBox.getAttribute('data-answer-state');
      if (state === 'correct') correct += 1;
      else if (state === 'wrong') wrong += 1;
    });

    const unanswered = Math.max(0, total - (correct + wrong));

    updateTotal(total);
    setText(qs('.cp1dlist2 .em1'), correct);
    setText(qs('.cp1dlist2 .em2'), wrong);
    setText(qs('.cp1dlist2 .em3'), unanswered);
  }

  function handle(e) {
    const li = e.target.closest('.cp1question1 .lst1 .li1');
    if (!li) return;

    const qBox = li.closest('.cp1question1');
    if (!qBox) return;

    const options = qsa('.lst1 .li1', qBox);
    const idx = options.indexOf(li) + 1; // 1-based
    if (idx <= 0) return;

    const panel = getPanelFromQ(qBox);
    const correctIdx = getCorrectIndex(panel);
    if (!correctIdx) {
      qBox.removeAttribute('data-answer-state');
      recompute();
      return;
    }

    qBox.setAttribute('data-answer-state', (idx === correctIdx) ? 'correct' : 'wrong');
    recompute();
  }

  // click이 막혀도 동작하도록 pointerup도 함께 수신(충돌 방어)
  document.addEventListener('click', handle, true);
  document.addEventListener('pointerup', handle, true);

  function init() { recompute(); }
  if (document.readyState === 'loading') document.addEventListener('DOMContentLoaded', init);
  else init();
})();
</script>
<!-- AUTO:score-counter end -->

</body>
</html>
