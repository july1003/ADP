<html lang="ko" class="cssscrollbar Desktop PC zoom object-fit gteIE9orSUA Chrome width-large lt-width-xlarge" style=""><head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>예상문제 </title>
<style>
/* AUTO:exam-ui start */
/* 클릭 가능 UX */
a.b2.help,
.cp1question1 .lst1 .li1,
.cp1question1 .lst1 .li1 a {
  cursor: pointer;
}
/* hover (navy) */
.cp1question1 .lst1 .li1:hover {
  background: rgba(31, 42, 68, 0.06);
}
/* 선택 표시 (navy) */
.cp1question1 .lst1 .li1.is-selected {
  background: rgba(31, 42, 68, 0.12);
  border-radius: 6px;
}
.cp1question1 .lst1 .li1.is-selected .t1 {
  font-weight: 600;
  color: #2980b9; /* 딥 블루 */
}
/* 정답 (navy) */
.cp1question1 .lst1 .li1.is-correct {
  background: rgba(52, 152, 219, 0.18); /* 라이트 블루 */
  border-radius: 6px;
}
.cp1question1 .lst1 .li1.is-correct .t1 {
  font-weight: 700;
  color: #2980b9; /* 딥 블루 */
}
/* 오답 */
.cp1question1 .lst1 .li1.is-wrong {
  background: rgba(160, 30, 30, 0.12);
  border-radius: 6px;
}
.cp1question1 .lst1 .li1.is-wrong .t1 {
  font-weight: 600;
  color: #7a1f1f;
}
/* 보기 버튼 (navy) */
a.b2.help {
  color: #2980b9; /* 딥 블루 */
}
a.b2.help.on {
  font-weight: 600;
}
/* AUTO:exam-ui end */


/* AUTO:clickable-ui start */
a.b2.help,
.cp1question1 .lst1 .li1,
.cp1question1 .lst1 .li1 a {
  cursor: pointer;
}
.cp1question1 .lst1 .li1:hover {
  background: rgba(0, 0, 0, 0.04);
}
a.b2.help:hover {
  opacity: 0.85;
}
/* AUTO:clickable-ui end */
/* AUTO:mobile-scroll-fix start */
html {
  scroll-behavior: smooth;
}
.container {
  max-width: 600px;
  width: 100%;
  margin: 0 auto;
}
/* AUTO:mobile-scroll-fix end */
body {width:100%;}
	.eg1 {padding:10px 0px; text-align:center;width:100%;}
	.tg2 {border-bottom:1px solid #ddd;padding:5% 5%;display:none}
	.cp1question1 {padding-bottom:12px;}
	img {
	  width: 100%;
	  height: 100%;
	  object-fit: contain; /* 또는 cover */
	}
h2 a {
  font-size: 16px;        /* 글씨 크기 */
  text-decoration: none;  /* 밑줄 제거 */
  color: #333;            /* 기본 글자 색 */
  font-weight: 500;       /* 약간 두껍게 */
  transition: color 0.3s ease; /* hover 시 부드럽게 색 변화 */
}
h2 a:hover {
  color: #007acc;         /* hover 시 포인트 색 */
}

/* AUTO:cp1dlist2-style start */
.cp1dlist2 {
  display: flex;
  justify-content: flex-end;
  background-color: #f0f0f0;
  border-radius: 12px;
  padding: 10px 15px;
}

.cp1dlist2 ul {
  list-style: none;
  margin: 0;
  padding: 0;
  display: flex;
  gap: 10px;
}

.em2 {
  color: #d63031;
}
/* AUTO:cp1dlist2-style end */

</style>
</head>
<body>
<div class="container clearfix">
<div id="body" tabindex="-1">
<!-- container -->
<div class="container clearfix">
<!-- #forPrint -->
<div id="forPrint">
<!-- _content -->
<div id="body_content">
<h2><a href="./index.html"> &lt; 돌아가기</a>

<span class="all-controls" style="margin-left: 15px; vertical-align: middle;">
    <button type="button" onclick="window.controlAllAnswers(true)" style="padding: 6px 12px; background-color: #2c3e50; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 13px; font-weight: bold;">전체 정답 보기</button>
    <button type="button" onclick="window.controlAllAnswers(false)" style="padding: 6px 12px; background-color: #95a5a6; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 13px; font-weight: bold; margin-left: 5px;">전체 가리기</button>
</span></h2>
<!-- container -->
<div class="container clearfix">
<!-- cp1dlist2 -->
<div class="cp1dlist2">
<ul class="dl1">
<li class="di1">
<a class="a1">
<b class="dt1">총 문제</b>
<span class="dd1">20개</span>
</a>
</li>
<li class="di1">
<a class="a1">
<b class="dt1">맞춘 문제</b>
<span class="dd1"><b class="em1">0개</b></span>
</a>
</li>
<li class="di1">
<a class="a1">
<b class="dt1">틀린 문제</b>
<span class="dd1"><b class="em2">0개</b></span>
</a>
</li>
<li class="di1">
<a class="a1">
<b class="dt1">안 푼 문제</b>
<span class="dd1"><b class="em3">20개</b></span>
</a>
</li>
</ul>
</div>
<!-- /cp1dlist2 -->
<h3 class="hb1 h3">2장 - 데이터 처리 기술</h3>
<!-- cp1question1 -->
<div class="cp1question1">
<div class="sg1">
<div class="w1">
<span class="g1">2과목</span>
<span class="g1">분산 데이터 저장 기술</span>
<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
</div>
</div>
<div class="tg1">
<strong class="tt1">
<span class="tt1n">1.</span>
<span class="tt1t1">
				아마존 SimpleDB의 데이터 모델용어와 관계형 데이터베이스(RDMBS)의 데이터 모델용어의 연결이 적절하지 않은 것은?							</span>
</strong>
<span class="tt1t1">
</span>
</div>
<ol class="lst1">
<li class="li1"><a class="a1"><span class="t1">
			Domain - Table					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			Attribute - Column					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			Data Dictionary - schema					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			Item - Record					</span></a></li>
</ol>
<div class="eg1">
<a class="b2 help" href="#m-help1a1" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
<span class="t1">정답보기</span>
<i class="ic1"></i>
</a>
</div>
<div class="tg2 loaded" id="m-help1a1" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
<strong class="tt1">정답</strong>
<div class="t2">
<i class="t2n">3</i>
<span class="t2t1">
			Data Dictionary - schema			</span>
</div>
<br/>
<strong class="tt1">해설</strong>
<div class="t1">
		SimpleDB의 데이터 모델은 Domain, Item, Attribute, Value로 구성되며 스키마(schema)가 없는 구조이다.				</div>


<div class="more-c">
<strong class="tt1">비기봇 해설</strong>
<div class="t1">
				정답은 3번입니다.<br/>
<br/>
아마존 SimpleDB와 관계형 데이터베이스(RDBMS)는 데이터 저장과 관리에 대한 두 가지 다른 접근 방식을 제공합니다. SimpleDB는 비관계형 데이터베이스로, 데이터가 도메인, 아이템, 속성으로 구성됩니다. 반면, RDBMS는 테이블, 레코드, 컬럼 등의 구조를 사용합니다. SimpleDB의 도메인은 RDBMS의 테이블과 유사하며, 아이템은 레코드, 속성은 컬럼과 대응됩니다. 그러나 데이터 사전은 RDBMS에서 스키마와 관련이 있지만, SimpleDB에서는 별도의 개념으로 존재하지 않습니다.<br/>
<br/>
1. Domain - Table <br/>
: SimpleDB의 도메인은 데이터를 저장하는 기본 단위로, RDBMS의 테이블과 유사한 역할을 합니다. 테이블은 데이터를 행과 열로 구성하여 저장하는 구조로, 도메인과 마찬가지로 데이터를 그룹화하는 역할을 합니다. 따라서 이 연결은 적절합니다.<br/>
<br/>
2. Attribute - Column <br/>
: SimpleDB의 속성은 각 아이템의 특성을 정의하는 요소로, RDBMS의 컬럼과 유사합니다. 컬럼은 테이블 내에서 각 레코드의 특정 속성을 나타내며, 속성과 컬럼은 데이터의 세부 정보를 저장하는 역할을 합니다. 이 연결도 적절합니다.<br/>
<br/>
3. Data Dictionary - schema <br/>
: 데이터 사전은 RDBMS에서 데이터베이스의 구조와 메타데이터를 설명하는 스키마와 관련이 있습니다. 그러나 SimpleDB에서는 데이터 사전이라는 개념이 별도로 존재하지 않으며, 스키마와 직접적으로 연결되지 않습니다. 따라서 이 연결은 부적절합니다.<br/>
<br/>
4. Item - Record <br/>
: SimpleDB의 아이템은 도메인 내의 개별 데이터 항목으로, RDBMS의 레코드와 유사합니다. 레코드는 테이블 내의 한 행을 나타내며, 아이템과 레코드는 데이터의 개별 단위를 나타냅니다. 이 연결은 적절합니다.<br/>
<br/>
선지 3은 데이터 사전과 스키마의 연결이 부적절합니다. 데이터 사전은 RDBMS에서 데이터베이스의 구조를 설명하는 메타데이터로, 스키마와 관련이 있지만 SimpleDB에서는 이러한 개념이 존재하지 않습니다. 나머지 선지들은 SimpleDB와 RDBMS의 유사한 개념을 적절히 연결하고 있습니다.<br/>
따라서, 정답은 '3. Data Dictionary - schema' 입니다.<br/>
</div>
<div class="t2">
									#SimpleDB									# RDBMS									# 도메인									# 테이블									# 속성									# 컬럼									# 데이터 사전									# 스키마							</div>
</div>

</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
<div class="sg1">
<div class="w1">
<span class="g1">2과목</span>
<span class="g1">분산 데이터 저장 기술</span>
<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
</div>
</div>
<div class="tg1">
<strong class="tt1">
<span class="tt1n">2.</span>
<span class="tt1t1">
				무공유(Shared Nothing) 클러스터와 공유 디스크(Shared Disk) 클러스터를 비교한 내용 중  옳지 않은 것은?							</span>
</strong>
<span class="tt1t1">
</span>
</div>
<ol class="lst1">
<li class="li1"><a class="a1"><span class="t1">
			무공유 클러스터에서 각 데이터베이스 인스턴스는 자신이 관리하는 데이터 파일을 자신의 로컬 디스크에 저장하며, 이 파일들은 노드 간에 공유하지 않는다.					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			공유 디스크 클러스터는 노드 확장에 제한이 없으나, 무공유 디스크는 클러스터가 커지면 디스크 영역에서 병목현상이 발생한다.					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			공유 디스크 클러스터의 경우 높은 수준의 폴트톨러런스(fault-tolerance)를 제공하므로 클러스터를 구성하는 노드 중 하나의 노드만 살아 있어도 서비스가 가능하다.					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			Oracle RAC(Real Application Cluster)를 제외한 대부분의 데이터베이스 클러스터가 무공유 방식을 채택하고 있다.					</span></a></li>
</ol>
<div class="eg1">
<a class="b2 help" href="#m-help1a2" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
<span class="t1">정답보기</span>
<i class="ic1"></i>
</a>
</div>
<div class="tg2 loaded" id="m-help1a2" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
<strong class="tt1">정답</strong>
<div class="t2">
<i class="t2n">2</i>
<span class="t2t1">
			공유 디스크 클러스터는 노드 확장에 제한이 없으나, 무공유 디스크는 클러스터가 커지면 디스크 영역에서 병목현상이 발생한다.			</span>
</div>
<br/>
<strong class="tt1">해설</strong>
<div class="t1">
		무공유 클러스터는 노드 확장에 제한이 없고, 무공유 디스크 클러스터는 클러스터의 규모가 커지면 디스크 영역에서 병목 현상이 발생한다는 단점을 가진다.				</div>


<div class="more-c">
<strong class="tt1">비기봇 해설</strong>
<div class="t1">
				1. 무공유 클러스터에서는 각 노드가 자신의 로컬 디스크에 데이터를 저장하고, 데이터는 노드 간에 공유되지 않습니다. 이 설명은 적절합니다.<br/>
<br/>
2. 실제로는 공유 디스크 클러스터가 디스크 I/O 병목현상을 겪기 쉽고, 노드 확장에 제한이 있을 수 있습니다. 반면 무공유 클러스터는 각 노드가 독립적인 디스크를 사용하므로 확장성이 뛰어납니다. 이 설명은 부적절합니다.<br/>
<br/>
3. 공유 디스크 클러스터는 모든 노드가 동일한 디스크에 접근할 수 있기 때문에, 하나의 노드가 고장나더라도 다른 노드가 계속해서 서비스할 수 있습니다. 이 설명은 적절합니다.<br/>
<br/>
4. <br/>
Oracle RAC는 공유 디스크 클러스터의 예이며, 대부분의 최신 데이터베이스 클러스터는 무공유 방식을 채택하여 확장성과 성능을 높입니다. 이 설명은 적절합니다.<br/>
</div>
<div class="t2">
									# 무공유 클러스터									# 공유 디스크 클러스터							</div>
</div>

</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
<div class="sg1">
<div class="w1">
<span class="g1">2과목</span>
<span class="g1">분산 데이터 저장 기술</span>
<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
</div>
</div>
<div class="tg1">
<strong class="tt1">
<span class="tt1n">3.</span>
<span class="tt1t1">
				다음 중 구글 파일 시스템(GFS)을 설계할 때 세웠던 가정으로 적절하지 않은 것은?							</span>
</strong>
<span class="tt1t1">
</span>
</div>
<ol class="lst1">
<li class="li1"><a class="a1"><span class="t1">
			높은 처리율보다 낮은 응답 지연시간이 중요하다.					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			여러 클라이언트에서 동시에 동일한 파일에 데이터를 추가하는 경우를 고려한다.					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			파일에 대한 쓰기 연산은 주로 순차적으로 일어나고, 파일에 대한 갱신은 드물게 이루어진다. 					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			저가형 서버로 구성된 환경으로 서버의 고장이 빈번히 발생할 수 있다고 가정한다.					</span></a></li>
</ol>
<div class="eg1">
<a class="b2 help" href="#m-help1a3" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
<span class="t1">정답보기</span>
<i class="ic1"></i>
</a>
</div>
<div class="tg2 loaded" id="m-help1a3" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
<strong class="tt1">정답</strong>
<div class="t2">
<i class="t2n">1</i>
<span class="t2t1">
			높은 처리율보다 낮은 응답 지연시간이 중요하다.			</span>
</div>
<br/>
<strong class="tt1">해설</strong>
<div class="t1">
		GFS를 설계할 때는 낮은 응답 지연시간보다 높은 처리율이 더 중요하다.				</div>


<div class="more-c">
<strong class="tt1">비기봇 해설</strong>
<div class="t1">
				정답은 1번입니다.<br/>
<br/>
구글 파일 시스템(GFS)은 대규모 데이터 처리를 위해 설계된 분산 파일 시스템입니다. GFS는 대용량 데이터를 효율적으로 저장하고 처리하기 위해 여러 가지 가정을 기반으로 설계되었습니다.<br/>
<br/>
1. 높은 처리율보다 낮은 응답 지연시간이 중요하다.<br/>
: GFS는 대규모 데이터 처리에 중점을 두고 설계되었기 때문에 높은 처리율이 중요합니다. 응답 지연시간보다는 대량의 데이터를 빠르게 처리할 수 있는 능력이 더 중요합니다.<br/>
<br/>
2. 여러 클라이언트에서 동시에 동일한 파일에 데이터를 추가하는 경우를 고려한다.<br/>
: GFS는 여러 클라이언트가 동시에 동일한 파일에 데이터를 추가할 수 있는 상황을 고려하여 설계되었습니다. 이는 대규모 데이터 처리 환경에서 흔히 발생하는 시나리오입니다.<br/>
<br/>
3. 파일에 대한 쓰기 연산은 주로 순차적으로 일어나고, 파일에 대한 갱신은 드물게 이루어진다.<br/>
: GFS에서는 파일에 대한 쓰기 연산이 주로 순차적으로 이루어지며, 파일 갱신은 드물게 발생합니다. 이는 대규모 로그 파일이나 데이터 수집 파일의 특성을 반영한 것입니다.<br/>
<br/>
4. 저가형 서버로 구성된 환경으로 서버의 고장이 빈번히 발생할 수 있다고 가정한다.<br/>
: GFS는 저가형 서버로 구성된 환경에서 서버의 고장이 빈번히 발생할 수 있다는 가정을 하고 있습니다. 따라서 이러한 고장에 대비한 복구 메커니즘이 중요합니다.<br/>
<br/>
<br/>
GFS는 높은 처리율을 중요시하며, 응답 지연시간보다는 대량의 데이터를 빠르게 처리할 수 있는 능력을 중시합니다. 따라서 '높은 처리율보다 낮은 응답 지연시간이 중요하다'는 GFS의 설계 가정에 적절하지 않습니다. 다른 선택지들은 GFS의 설계 가정에 부합합니다.<br/>
<br/>
따라서, 정답은 '1. 높은 처리율보다 낮은 응답 지연시간이 중요하다.' 입니다.<br/>
</div>
<div class="t2">
									#GFS									# 분산 파일 시스템									# 대규모 데이터 처리									# 서버 고장							</div>
</div>

</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
<div class="sg1">
<div class="w1">
<span class="g1">2과목</span>
<span class="g1">분산 데이터 저장 기술</span>
<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
</div>
</div>
<div class="tg1">
<strong class="tt1">
<span class="tt1n">4.</span>
<span class="tt1t1">
				GFS(Google File System)의 구동원리 중 옳지 않은 것은?							</span>
</strong>
<span class="tt1t1">
</span>
</div>
<ol class="lst1">
<li class="li1"><a class="a1"><span class="t1">
			청크(chunk)는 청크서버에 의해 생성/삭제 될 수 있으며, 유일한 식별자에 의해 구별된다.					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			GFS는 트리 구조가 아닌 해시 테이블 구조 등을 사용함으로써 메모리상에서 보다 효율적인 메타데이터의 처리를 지원한다.					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			GFS는 파일을 임의의 크기의 청크(chunk)들로 나누어 청크서버들에 분산·저장한다.					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			클라이언트는 마스터로부터 읽고자 하는 파일의 청크(chunk)가 저장된 청크서버의 위치를 알아온 뒤, 직접 청크서버에 파일 데이터를 요청한다.					</span></a></li>
</ol>
<div class="eg1">
<a class="b2 help" href="#m-help1a4" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
<span class="t1">정답보기</span>
<i class="ic1"></i>
</a>
</div>
<div class="tg2 loaded" id="m-help1a4" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
<strong class="tt1">정답</strong>
<div class="t2">
<i class="t2n">1</i>
<span class="t2t1">
			청크(chunk)는 청크서버에 의해 생성/삭제 될 수 있으며, 유일한 식별자에 의해 구별된다.			</span>
</div>
<br/>
<strong class="tt1">해설</strong>
<div class="t1">
		청크(chunk)는 마스터에 의해 생성/삭제될 수 있다.				</div>


<div class="more-c">
<strong class="tt1">비기봇 해설</strong>
<div class="t1">
				1. GFS에서 청크(chunk)의 생성과 삭제는 마스터 서버에 의해 제어됩니다. 청크서버는 청크를 저장하고 읽기/쓰기 요청을 처리하지만, 청크의 생성과 삭제는 마스터 서버가 관리합니다. <br/>
<br/>
2. GFS는 트리 구조가 아닌 해시 테이블 구조 등을 사용함으로써 메모리상에서 보다 효율적인 메타데이터의 처리를 지원합니다.<br/>
<br/>
3. GFS는 파일을 임의의 크기인 64MB 청크(chunk)들로 나누어 청크서버들에 분산·저장합니다.<br/>
<br/>
4. 클라이언트는 마스터로부터 읽고자 하는 파일의 청크(chunk)가 저장된 청크서버의 위치를 알아온 뒤, 직접 청크서버에 파일 데이터를 요청합니다.<br/>
</div>
<div class="t2">
									# GFS									# GFS의 구성요소							</div>
</div>

</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
<div class="sg1">
<div class="w1">
<span class="g1">2과목</span>
<span class="g1">분산 데이터 저장 기술</span>
<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
</div>
</div>
<div class="tg1">
<strong class="tt1">
<span class="tt1n">5.</span>
<span class="tt1t1">
				분산 파일 시스템인 러스터(Luster)에 대한 설명 중 옳지 않은 것은?							</span>
</strong>
<span class="tt1t1">
</span>
</div>
<ol class="lst1">
<li class="li1"><a class="a1"><span class="t1">
			클러스터 파일 시스템(Cluster File Systems Inc.)에서 개발한 객체 기반 클러스터 파일 시스템이다.					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			고속네트워크로 연결된 클라이언트 파일 시스템, 메타데이터 서버, 객체 저장서버들로 구성 되어있다.					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			러스터는 파일의 메타 데이터와 파일 데이터에 대한 동시성 제어를 위해 별도의 잠금을 사용한다.					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			객체 저장서버는 파일 시스템의 이름 공간과 파일에 대한 메타데이터를 관리한다.					</span></a></li>
</ol>
<div class="eg1">
<a class="b2 help" href="#m-help1a5" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
<span class="t1">정답보기</span>
<i class="ic1"></i>
</a>
</div>
<div class="tg2 loaded" id="m-help1a5" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
<strong class="tt1">정답</strong>
<div class="t2">
<i class="t2n">4</i>
<span class="t2t1">
			객체 저장서버는 파일 시스템의 이름 공간과 파일에 대한 메타데이터를 관리한다.			</span>
</div>
<br/>
<strong class="tt1">해설</strong>
<div class="t1">
		파일 시스템의 이름 공간과 파일에 대한 메타데이터를 관리하는 것은 메타데이터 서버이다.				</div>


<div class="more-c">
<strong class="tt1">비기봇 해설</strong>
<div class="t1">
				정답은 4번입니다.<br/>
<br/>
러스터(Lustre)는 고성능 컴퓨팅 환경에서 사용되는 분산 파일 시스템으로, 대규모 데이터 저장과 빠른 데이터 접근을 지원합니다. 주로 슈퍼컴퓨터와 대규모 클러스터 환경에서 사용됩니다.<br/>
<br/>
1. 클러스터 파일 시스템(Cluster File Systems Inc.)에서 개발한 객체 기반 클러스터 파일 시스템이다.<br/>
: 러스터는 클러스터 파일 시스템(Cluster File Systems Inc.)에서 개발된 객체 기반 클러스터 파일 시스템입니다. 이는 러스터의 기원과 개발 배경을 설명하는 부분입니다.<br/>
<br/>
2. 고속네트워크로 연결된 클라이언트 파일 시스템, 메타데이터 서버, 객체 저장서버들로 구성 되어있다.<br/>
: 러스터는 고속 네트워크로 연결된 클라이언트 파일 시스템, 메타데이터 서버, 객체 저장 서버들로 구성되어 있습니다. 이는 러스터의 기본 아키텍처를 설명합니다.<br/>
<br/>
3. 러스터는 파일의 메타 데이터와 파일 데이터에 대한 동시성 제어를 위해 별도의 잠금을 사용한다.<br/>
: 러스터는 파일의 메타 데이터와 파일 데이터에 대한 동시성 제어를 위해 별도의 잠금을 사용하지 않습니다. 이는 러스터의 동시성 제어 방식에 대한 설명입니다.<br/>
<br/>
4. 객체 저장서버는 파일 시스템의 이름 공간과 파일에 대한 메타데이터를 관리한다.<br/>
: 객체 저장 서버는 파일 시스템의 이름 공간과 파일에 대한 메타데이터를 관리하지 않습니다. 이는 메타데이터 서버의 역할에 대한 설명입니다.<br/>
<br/>
<br/>
러스터에서 객체 저장 서버는 파일 데이터를 저장하는 역할을 하며, 파일 시스템의 이름 공간과 파일에 대한 메타데이터 관리는 메타데이터 서버가 담당합니다. 따라서 4번 선택지가 틀린 설명입니다.<br/>
<br/>
따라서, 정답은 '4. 객체 저장서버는 파일 시스템의 이름 공간과 파일에 대한 메타데이터를 관리한다.' 입니다.<br/>
</div>
<div class="t2">
									#러스터									# 분산 파일 시스템									# 메타데이터 서버									# 객체 저장 서버							</div>
</div>

</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
<div class="sg1">
<div class="w1">
<span class="g1">2과목</span>
<span class="g1">분산 데이터 저장 기술</span>
<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
</div>
</div>
<div class="tg1">
<strong class="tt1">
<span class="tt1n">6.</span>
<span class="tt1t1">
				Oracle RAC 데이터베이스 서버에 대한 다음의 설명 중 옳지 않은 것은?							</span>
</strong>
<span class="tt1t1">
</span>
</div>
<ol class="lst1">
<li class="li1"><a class="a1"><span class="t1">
			Oracle RAC 데이터베이스 서버는 한 노드가 어떤 이유로 장애를 일으켰을 때 클러스터를 구성하는 노드 중 하나의 노드만 살아 있어도 서비스가 가능하다.					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			추가 처리 성능이 필요하면 응용 프로그램이나 데이터베이스를 수정할 필요 없이 새 노드를 클러스터에 쉽게 추가할 수 있다.					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			클러스터의 모든 노드는 데이터베이스의 모든 테이블에 차등하여 액세스하며, 특정 노드가 데이터를 ‘소유’하는 개념이 존재한다.					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			RAC는 표준화된 소규모(CPU 4개 미만) 저가형 상용 하드웨어의 클러스터에서도 고가의 SMP 시스템만큼 효율적으로 응용 프로그램을 실행함으로써 하드웨어 비용을 절감한다.					</span></a></li>
</ol>
<div class="eg1">
<a class="b2 help" href="#m-help1a6" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
<span class="t1">정답보기</span>
<i class="ic1"></i>
</a>
</div>
<div class="tg2 loaded" id="m-help1a6" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
<strong class="tt1">정답</strong>
<div class="t2">
<i class="t2n">3</i>
<span class="t2t1">
			클러스터의 모든 노드는 데이터베이스의 모든 테이블에 차등하여 액세스하며, 특정 노드가 데이터를 ‘소유’하는 개념이 존재한다.			</span>
</div>
<br/>
<strong class="tt1">해설</strong>
<div class="t1">
		클러스터의 모든 노드는 데이터베이스의 모든 테이블에 동등하게 액세스하며, 특정 노드가 데이터를 ‘소유’하는 개념이 없다.				</div>


<div class="more-c">
<strong class="tt1">비기봇 해설</strong>
<div class="t1">
				정답은 3번입니다.<br/>
<br/>
Oracle RAC(Real Application Clusters)는 여러 노드가 하나의 데이터베이스를 공유하여 고가용성과 확장성을 제공하는 시스템입니다. 각 노드는 데이터베이스에 대한 동등한 접근 권한을 가지며, 특정 노드가 데이터를 소유하는 개념은 존재하지 않습니다. 이는 데이터베이스의 모든 테이블에 대한 균등한 접근을 가능하게 하여 장애 발생 시에도 다른 노드가 서비스를 지속할 수 있도록 합니다.<br/>
<br/>
1. Oracle RAC 데이터베이스 서버는 한 노드가 어떤 이유로 장애를 일으켰을 때 클러스터를 구성하는 노드 중 하나의 노드만 살아 있어도 서비스가 가능하다.<br/>
: Oracle RAC는 고가용성을 제공하기 때문에 한 노드에 장애가 발생하더라도 다른 노드가 서비스를 지속할 수 있습니다. 이는 클러스터의 장점 중 하나입니다.<br/>
<br/>
2. 추가 처리 성능이 필요하면 응용 프로그램이나 데이터베이스를 수정할 필요 없이 새 노드를 클러스터에 쉽게 추가할 수 있다.<br/>
: RAC의 확장성은 뛰어나며, 추가적인 처리 성능이 필요할 때 응용 프로그램이나 데이터베이스를 수정할 필요 없이 노드를 추가할 수 있습니다.<br/>
<br/>
3. 클러스터의 모든 노드는 데이터베이스의 모든 테이블에 차등하여 액세스하며, 특정 노드가 데이터를 ‘소유’하는 개념이 존재한다.<br/>
: RAC에서는 모든 노드가 데이터베이스에 균등하게 접근하며, 특정 노드가 데이터를 소유하는 개념은 없습니다. 이는 데이터의 일관성과 가용성을 높이는 데 기여합니다.<br/>
<br/>
4. RAC는 표준화된 소규모(CPU 4개 미만) 저가형 상용 하드웨어의 클러스터에서도 고가의 SMP 시스템만큼 효율적으로 응용 프로그램을 실행함으로써 하드웨어 비용을 절감한다.<br/>
: RAC는 저가형 하드웨어에서도 고성능을 발휘할 수 있어 하드웨어 비용을 절감할 수 있습니다. 이는 RAC의 경제적 이점 중 하나입니다.<br/>
<br/>
<br/>
정답은 3번입니다. Oracle RAC에서는 특정 노드가 데이터를 소유하는 개념이 존재하지 않습니다. 모든 노드가 데이터베이스에 균등하게 접근할 수 있으며, 이는 데이터의 일관성과 가용성을 보장합니다. 다른 선택지들은 RAC의 특성과 일치합니다.<br/>
<br/>
따라서, 정답은 '3. 클러스터의 모든 노드는 데이터베이스의 모든 테이블에 차등하여 액세스하며, 특정 노드가 데이터를 ‘소유’하는 개념이 존재한다.' 입니다.<br/>
</div>
<div class="t2">
									#Oracle RAC									# 고가용성									# 확장성									# 데이터 소유							</div>
</div>

</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
<div class="sg1">
<div class="w1">
<span class="g1">2과목</span>
<span class="g1">분산 데이터 저장 기술</span>
<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
</div>
</div>
<div class="tg1">
<strong class="tt1">
<span class="tt1n">7.</span>
<span class="tt1t1">
				NoSQL에 대한 다음의 설명 중 옳지 않은 것은?							</span>
</strong>
<span class="tt1t1">
</span>
</div>
<ol class="lst1">
<li class="li1"><a class="a1"><span class="t1">
			NoSQL은 Key와 Value의 형태로 자료를 저장하고, 빠르게 조회할 수 있는 자료 구조를 제공하는 저장소다.					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			전통적인 RDBMS의 장점이라고 할 수 있는 복잡한 Join 연산 기능을 지원한다.					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			스키마 없이 동작하며, 구조에 대한 정의 변경없이 자유롭게 데이터베이스의 레코드에 필드를 추가할 수 있다.					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			높은 수평적 확장성, 가용성, 성능을 제공한다.					</span></a></li>
</ol>
<div class="eg1">
<a class="b2 help" href="#m-help1a7" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
<span class="t1">정답보기</span>
<i class="ic1"></i>
</a>
</div>
<div class="tg2 loaded" id="m-help1a7" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
<strong class="tt1">정답</strong>
<div class="t2">
<i class="t2n">2</i>
<span class="t2t1">
			전통적인 RDBMS의 장점이라고 할 수 있는 복잡한 Join 연산 기능을 지원한다.			</span>
</div>
<br/>
<strong class="tt1">해설</strong>
<div class="t1">
		NoSQL은 전통적인 RDBMS의 장점이라고 할 수 있는 복잡한 Join 연산 기능은 지원하지 않는다.				</div>


<div class="more-c">
<strong class="tt1">비기봇 해설</strong>
<div class="t1">
				정답은 2번입니다.<br/>
<br/>
NoSQL은 전통적인 관계형 데이터베이스 관리 시스템(RDBMS)과는 다른 방식으로 데이터를 저장하고 관리하는 시스템입니다. NoSQL은 주로 대량의 비정형 데이터를 처리하기 위해 설계되었으며, Key-Value, Document, Graph, Column 모델 등 다양한 데이터 모델을 지원합니다. 이러한 시스템은 스키마가 없거나 유연한 스키마를 사용하여 데이터 구조의 변경이 용이하며, 수평적 확장성을 통해 대규모 데이터 처리에 적합합니다. 그러나 RDBMS의 복잡한 Join 연산을 지원하지 않는 대신, 높은 성능과 가용성을 제공합니다.<br/>
<br/>
1. NoSQL은 Key와 Value의 형태로 자료를 저장하고, 빠르게 조회할 수 있는 자료 구조를 제공하는 저장소다. <br/>
: NoSQL 데이터베이스는 Key-Value 형태로 데이터를 저장하는 방식 중 하나로, 빠른 데이터 조회를 가능하게 합니다. 이는 데이터가 키를 통해 직접 접근 가능하기 때문에 조회 속도가 빠르며, 대량의 데이터를 효율적으로 관리할 수 있습니다.<br/>
<br/>
2. 전통적인 RDBMS의 장점이라고 할 수 있는 복잡한 Join 연산 기능을 지원한다. <br/>
: NoSQL은 전통적인 RDBMS와 달리 복잡한 Join 연산을 지원하지 않습니다. 이는 NoSQL이 대량의 데이터를 빠르게 처리하고 수평적으로 확장하는 데 중점을 두기 때문입니다. 따라서 복잡한 관계를 처리하는 데는 적합하지 않으며, 이 점이 오답인 이유입니다.<br/>
<br/>
3. 스키마 없이 동작하며, 구조에 대한 정의 변경없이 자유롭게 데이터베이스의 레코드에 필드를 추가할 수 있다. <br/>
: NoSQL은 스키마가 없거나 유연한 스키마를 사용하여 데이터 구조의 변경 없이 필드를 추가할 수 있습니다. 이는 데이터의 유연성을 높이고, 다양한 형태의 데이터를 쉽게 저장할 수 있게 합니다.<br/>
<br/>
4. 높은 수평적 확장성, 가용성, 성능을 제공한다. <br/>
: NoSQL은 높은 수평적 확장성, 가용성, 성능을 제공하는 시스템입니다. 이는 대량의 데이터를 처리하고, 여러 서버에 걸쳐 데이터를 분산 저장하여 시스템의 성능과 가용성을 높이는 데 기여합니다.<br/>
<br/>
선지 2는 NoSQL이 전통적인 RDBMS의 복잡한 Join 연산을 지원한다고 잘못 설명하고 있습니다. NoSQL은 이러한 연산을 지원하지 않으며, 대신 대량의 데이터 처리와 수평적 확장성에 중점을 둡니다. 나머지 선지들은 NoSQL의 특성을 올바르게 설명하고 있습니다.<br/>
따라서, 정답은 '2. 전통적인 RDBMS의 장점이라고 할 수 있는 복잡한 Join 연산 기능을 지원한다.' 입니다.<br/>
</div>
<div class="t2">
									#NoSQL									# Key-Value									# 스키마 없음									# 수평적 확장성									# Join 연산							</div>
</div>

</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
<div class="sg1">
<div class="w1">
<span class="g1">2과목</span>
<span class="g1">분산 컴퓨팅 기술</span>
<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
</div>
</div>
<div class="tg1">
<strong class="tt1">
<span class="tt1n">8.</span>
<span class="tt1t1">
				구글 Sawzall에 대한 설명 중 옳은 것은?							</span>
</strong>
<span class="tt1t1">
</span>
</div>
<ol class="lst1">
<li class="li1"><a class="a1"><span class="t1">
			Sawzall은 MapReduce를 구체화한 스크립트 형태의 병렬 프로그래밍 언어다.					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			Sawzall은 사용자가 이해하기 쉬운 인터페이스를 제공하며, MapReduece 개발 생산성과는 관련성이 없다.					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			오픈소스 프로젝트인 Pig나 하이브(Hive)의 개발 배경과 기본적인 개념은 Sawzall과 유사하다.					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			MapReduce에 대한 이해가 없으면 병렬 프로그래밍에 어려움이 있다.					</span></a></li>
</ol>
<div class="eg1">
<a class="b2 help" href="#m-help1a8" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
<span class="t1">정답보기</span>
<i class="ic1"></i>
</a>
</div>
<div class="tg2 loaded" id="m-help1a8" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
<strong class="tt1">정답</strong>
<div class="t2">
<i class="t2n">3</i>
<span class="t2t1">
			오픈소스 프로젝트인 Pig나 하이브(Hive)의 개발 배경과 기본적인 개념은 Sawzall과 유사하다.			</span>
</div>
<br/>
<strong class="tt1">해설</strong>
<div class="t1">
		Sawzall은 MapReduce를 추상화한 스크립트 형태의 병렬 프로그래밍 언어다. Sawzall은 MapReduece 개발 생산성을 높였다. MapReduce에 대한 이해가 없는 사용자들도 더욱 쉽게 병렬 프로그래밍을 할 수 있다.				</div>


<div class="more-c">
<strong class="tt1">비기봇 해설</strong>
<div class="t1">
				1.  Sawzall은 MapReduce 작업에서 데이터를 처리하고 요약하는 데 사용되는 스크립트 언어이며, MapReduce를 구체화한 것이 아닌, 추상화한 스크립트 형태의 병렬 쿼리 언어입니다. 따라서 이 설명은 부적절합니다.<br/>
<br/>
2. Sawzall은 이해하기 쉬운 인터페이스를 제공하지만, MapReduce를 기반으로 병렬 처리를 수행하므로 개발 생산성과 관련이 있습니다. 이 설명은 부적절합니다.<br/>
<br/>
3.  Pig, Hive, 그리고 Sawzall 모두 대규모 데이터 처리를 위해 설계되었고, 고수준의 데이터 처리 언어를 제공하여 사용자가 복잡한 분산 처리를 쉽게 수행할 수 있도록 하기 때문에 이 설명은 적절합니다.<br/>
<br/>
4. Sawzall은 사용자가 MapReduce의 세부 사항을 직접 다루지 않도록 설계되었기 때문에, 사용자가 반드시 MapReduce에 대한 깊은 이해를 필요로 하지 않습니다. 이 설명은 부적절합니다.<br/>
</div>
<div class="t2">
									# Sawzall							</div>
</div>

</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
<div class="sg1">
<div class="w1">
<span class="g1">2과목</span>
<span class="g1">분산 데이터 저장 기술</span>
<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
</div>
</div>
<div class="tg1">
<strong class="tt1">
<span class="tt1n">9.</span>
<span class="tt1t1">
				MySQL에 대한 다음의 설명 중 옳지 않은 것은?							</span>
</strong>
<span class="tt1t1">
</span>
</div>
<ol class="lst1">
<li class="li1"><a class="a1"><span class="t1">
			특정한 하드웨어 및 소프트웨어를 요구하지 않고 병렬 서버구조로 확장이 가능하다.					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			MySQL 운영 중에 노드를 추가/삭제가 가능하다.					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			MySQL 클러스터는 데이터의 가용성을 높이기 위해 데이터를 다른 노드에 복제시키며, 특정 노드에 장애가 발생하더라도 지속적인 데이터 서비스가 가능하다.					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			클러스터에 참여하는 노드(SQL 노드, 데이터 노드, 매니저를 포함) 수는 255로 제한한다. 데이터 노드는 최대 48개까지만 가능하다.					</span></a></li>
</ol>
<div class="eg1">
<a class="b2 help" href="#m-help1a9" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
<span class="t1">정답보기</span>
<i class="ic1"></i>
</a>
</div>
<div class="tg2 loaded" id="m-help1a9" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
<strong class="tt1">정답</strong>
<div class="t2">
<i class="t2n">2</i>
<span class="t2t1">
			MySQL 운영 중에 노드를 추가/삭제가 가능하다.			</span>
</div>
<br/>
<strong class="tt1">해설</strong>
<div class="t1">
		운영 중에 노드를 추가/삭제할 수 없다.				</div>


<div class="more-c">
<strong class="tt1">비기봇 해설</strong>
<div class="t1">
				1. MySQL은 특정한 하드웨어 및 소프트웨어에 의존하지 않으며, 병렬 서버구조로 확장이 가능합니다. 다양한 플랫폼에서 실행할 수 있습니다. 따라서 이 설명은 적절합니다.<br/>
<br/>
2. MySQL 자체는 단일 인스턴스 데이터베이스 관리 시스템으로 설계되어 있으며, 운영 중에 노드를 추가하거나 삭제하는 기능을 기본적으로 지원하지 않습니다. MySQL 클러스터나 Galera Cluster와 같은 솔루션을 사용해야 이러한 기능이 가능합니다.<br/>
<br/>
3. MySQL 클러스터는 고가용성을 제공하기 위해 데이터 복제를 사용하며, 특정 노드에 장애가 발생해도 서비스가 지속될 수 있도록 설계되었습니다. 따라서 이 설명은 적절합니다.<br/>
<br/>
4. MySQL 클러스터의 설정에서 클러스터에 참여하는 노드 수는 255로 제한되며, 데이터 노드는 최대 48개까지 가능합니다.<br/>
</div>
<div class="t2">
									# MySQL									# MySQL의 특징							</div>
</div>

</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
<div class="sg1">
<div class="w1">
<span class="g1">2과목</span>
<span class="g1">분산 컴퓨팅 기술</span>
<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
</div>
</div>
<div class="tg1">
<strong class="tt1">
<span class="tt1n">10.</span>
<span class="tt1t1">
				MapReduce에 대한 설명 중 옳지 않은 것은?							</span>
</strong>
<span class="tt1t1">
</span>
</div>
<ol class="lst1">
<li class="li1"><a class="a1"><span class="t1">
			분할정복 방식으로 대용량 데이터를 병렬로 처리할 수 있는 프로그래밍 모델이다. 					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			맵과 리듀스라는 2개의 함수 구현으로 동작되는 시스템이다.					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			정렬과 같은 작업은 맵리듀스 모델을 적용하여 처리하기에 매우 적합하다. 					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			map 단계에서는 key와 value의 쌍들을 입력으로 받는다.					</span></a></li>
</ol>
<div class="eg1">
<a class="b2 help" href="#m-help1a10" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
<span class="t1">정답보기</span>
<i class="ic1"></i>
</a>
</div>
<div class="tg2 loaded" id="m-help1a10" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
<strong class="tt1">정답</strong>
<div class="t2">
<i class="t2n">3</i>
<span class="t2t1">
			정렬과 같은 작업은 맵리듀스 모델을 적용하여 처리하기에 매우 적합하다. 			</span>
</div>
<br/>
<strong class="tt1">해설</strong>
<div class="t1">
		정렬과 같은 작업은 오버헤드로 인해 수행 성능이 저하되므로 맵리듀스 모델에 적용하기에 적합하지 않다.				</div>


<div class="more-c">
<strong class="tt1">비기봇 해설</strong>
<div class="t1">
				정답은 3번입니다.<br/>
<br/>
MapReduce는 구글에서 개발한 대용량 데이터 처리 프레임워크로, 분산 병렬 컴퓨팅을 통해 데이터를 효율적으로 처리할 수 있습니다. 이 모델은 '맵'과 '리듀스'라는 두 가지 주요 함수로 구성되어 있으며, 대량의 데이터를 작은 조각으로 나누어 병렬로 처리한 후, 결과를 결합하여 최종 결과를 도출합니다. 이 과정은 분할정복(Divide and Conquer) 방식으로 이루어지며, 대용량 데이터의 병렬 처리를 가능하게 합니다. 특히, 정렬과 같은 작업은 맵리듀스 모델을 통해 효과적으로 수행될 수 있습니다. 맵 단계에서는 입력 데이터를 key-value 쌍으로 받아들이고, 리듀스 단계에서는 이 데이터를 처리하여 최종 결과를 생성합니다.<br/>
<br/>
1. 분할정복 방식으로 대용량 데이터를 병렬로 처리할 수 있는 프로그래밍 모델이다. <br/>
: MapReduce는 대용량 데이터를 처리하기 위해 분할정복 방식을 사용합니다. 이는 문제를 작은 부분으로 나누어 각각을 해결한 후, 전체 문제의 해답을 얻는 방식입니다. 이 모델은 병렬 처리를 통해 대량의 데이터를 효율적으로 처리할 수 있습니다.<br/>
<br/>
2. 맵과 리듀스라는 2개의 함수 구현으로 동작되는 시스템이다. <br/>
: MapReduce는 두 가지 주요 함수, 즉 '맵'과 '리듀스'로 구성됩니다. 맵 함수는 데이터를 key-value 쌍으로 변환하고, 리듀스 함수는 이 데이터를 집계하여 최종 결과를 생성합니다. 이 두 함수의 조합은 대용량 데이터 처리의 핵심입니다.<br/>
<br/>
3. 정렬과 같은 작업은 맵리듀스 모델을 적용하여 처리하기에 매우 적합하다. <br/>
: 정렬 작업은 MapReduce 모델을 통해 매우 효과적으로 수행될 수 있습니다. 맵 단계에서 데이터를 key-value 쌍으로 변환하고, 셔플과 정렬 과정을 통해 데이터를 정렬한 후, 리듀스 단계에서 최종 결과를 생성합니다. 이는 대량의 데이터를 효율적으로 정렬하는 데 적합합니다.<br/>
<br/>
4. map 단계에서는 key와 value의 쌍들을 입력으로 받는다. <br/>
: 맵 단계에서는 입력 데이터를 key-value 쌍으로 받아들입니다. 이는 데이터의 구조를 정의하고, 이후의 셔플과 정렬 과정을 통해 데이터를 효율적으로 처리할 수 있도록 합니다. 이 단계는 MapReduce의 기본적인 데이터 처리 방식입니다.<br/>
<br/>
선지 3은 정렬 작업이 MapReduce 모델에 적합하다고 설명하고 있습니다. 그러나 정렬은 MapReduce의 기본 기능 중 하나로, 이 모델을 통해 매우 효율적으로 수행될 수 있습니다. 따라서 선지 3은 옳지 않은 설명입니다. 나머지 선지들은 MapReduce의 개념과 기능을 정확히 설명하고 있습니다.<br/>
따라서, 정답은 '3. 정렬과 같은 작업은 맵리듀스 모델을 적용하여 처리하기에 매우 적합하다.' 입니다.<br/>
</div>
<div class="t2">
									#MapReduce									# 분할정복									# 병렬 처리									# 맵 함수									# 리듀스 함수									# 대용량 데이터							</div>
</div>

</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
<div class="sg1">
<div class="w1">
<span class="g1">2과목</span>
<span class="g1">클라우드 인프라 기술</span>
<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
</div>
</div>
<div class="tg1">
<strong class="tt1">
<span class="tt1n">11.</span>
<span class="tt1t1">
				다음 중 가상화 기술을 이용할 경우 얻을 수 있는 효과로 가장 부적절한 것은?							</span>
</strong>
<span class="tt1t1">
</span>
</div>
<ol class="lst1">
<li class="li1"><a class="a1"><span class="t1">
			수시로 변화하는 가상머신의 자원 요구량에 맞추어 전체 시스템의 자원을 재배치함으로써 자원 할당의 유연성을 증가시킨다.					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			가상머신에서 수행중인 애플리케이션의 장애가 다른 가상머신에는 전혀 영향을 미치지 않는다.					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			다양한 운영체제나 운영환경에서 테스트가 필요한 경우, 새로운 서버를 추가하지 않아도 테스트 환경을 구성할 수 있다.					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			마이그레이션(migration) 기능을 이용할 경우 운영 중인 가상머신을 중지하고, 가상머신을 다른 물리적인 서버로 이동시킬 수 있다.					</span></a></li>
</ol>
<div class="eg1">
<a class="b2 help" href="#m-help1a11" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
<span class="t1">정답보기</span>
<i class="ic1"></i>
</a>
</div>
<div class="tg2 loaded" id="m-help1a11" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
<strong class="tt1">정답</strong>
<div class="t2">
<i class="t2n">4</i>
<span class="t2t1">
			마이그레이션(migration) 기능을 이용할 경우 운영 중인 가상머신을 중지하고, 가상머신을 다른 물리적인 서버로 이동시킬 수 있다.			</span>
</div>
<br/>
<strong class="tt1">해설</strong>
<div class="t1">
		마이그레이션 기능을 이용할 경우 운영 중인 가상머신의 중지 없이 가상머신을 다른 물리적인 서버로 이동시킬 수 있다. 				</div>


<div class="more-c">
<strong class="tt1">비기봇 해설</strong>
<div class="t1">
				정답은 4번입니다.<br/>
<br/>
가상화 기술은 물리적인 하드웨어 자원을 추상화하여 여러 가상 머신(VM)을 실행할 수 있게 하는 기술입니다. 이를 통해 서버 통합, 자원 할당의 유연성, 테스트 환경의 손쉬운 구성, 장애 격리 등의 이점을 제공합니다. 가상화는 하이퍼바이저를 통해 물리적 자원을 가상화하여 각 VM이 독립적으로 운영되도록 하며, 자원 사용의 효율성을 극대화합니다. 또한, 가상화는 다양한 운영체제와 환경에서의 테스트를 용이하게 하고, 자원 요구에 따라 동적으로 자원을 재배치할 수 있는 유연성을 제공합니다.<br/>
<br/>
1. 수시로 변화하는 가상머신의 자원 요구량에 맞추어 전체 시스템의 자원을 재배치함으로써 자원 할당의 유연성을 증가시킨다. <br/>
: 가상화 기술의 핵심은 자원의 유연한 할당입니다. 가상 머신의 자원 요구가 변화할 때, 하이퍼바이저는 전체 시스템의 자원을 재배치하여 자원 활용도를 극대화합니다. 이는 가상화의 주요 장점 중 하나로, 자원 할당의 유연성을 높여 다양한 워크로드에 대응할 수 있게 합니다.<br/>
<br/>
2. 가상머신에서 수행중인 애플리케이션의 장애가 다른 가상머신에는 전혀 영향을 미치지 않는다. <br/>
: 가상화 환경에서는 각 가상 머신이 독립적으로 운영되기 때문에, 한 가상 머신에서 발생한 장애가 다른 가상 머신에 영향을 미치지 않습니다. 이는 가상화의 격리 기능 덕분에 가능하며, 애플리케이션의 안정성을 높이는 데 기여합니다.<br/>
<br/>
3. 다양한 운영체제나 운영환경에서 테스트가 필요한 경우, 새로운 서버를 추가하지 않아도 테스트 환경을 구성할 수 있다. <br/>
: 가상화는 다양한 운영체제나 환경에서 테스트를 수행할 때 새로운 물리적 서버를 추가하지 않고도 테스트 환경을 구성할 수 있게 합니다. 이는 가상 머신을 통해 다양한 환경을 손쉽게 시뮬레이션할 수 있기 때문입니다.<br/>
<br/>
4. 마이그레이션(migration) 기능을 이용할 경우 운영 중인 가상머신을 중지하고, 가상머신을 다른 물리적인 서버로 이동시킬 수 있다. <br/>
: 마이그레이션 기능은 가상 머신을 중지하지 않고도 다른 물리적 서버로 이동시킬 수 있는 기능입니다. 이는 가상화의 중요한 기능 중 하나로, 시스템의 가용성을 높이고 유지보수 작업을 용이하게 합니다. 따라서, 가상 머신을 중지해야 한다는 설명은 부적절합니다.<br/>
<br/>
선지 4는 가상화의 마이그레이션 기능에 대한 잘못된 설명을 포함하고 있습니다. 마이그레이션은 가상 머신을 중지하지 않고도 다른 서버로 이동할 수 있는 기능으로, 이는 가상화의 큰 장점 중 하나입니다. 나머지 선지들은 가상화의 장점을 올바르게 설명하고 있습니다.<br/>
따라서, 정답은 '4. 마이그레이션(migration) 기능을 이용할 경우 운영 중인 가상머신을 중지하고, 가상머신을 다른 물리적인 서버로 이동시킬 수 있다.' 입니다.<br/>
</div>
<div class="t2">
									#가상화									# 자원 할당									# 장애 격리									# 테스트 환경									# 마이그레이션							</div>
</div>

</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
<div class="sg1">
<div class="w1">
<span class="g1">2과목</span>
<span class="g1">분산 컴퓨팅 기술</span>
<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
</div>
</div>
<div class="tg1">
<strong class="tt1">
<span class="tt1n">12.</span>
<span class="tt1t1">
				Hadoop Architecture에 대한 설명 중 옳지 않은 것은?							</span>
</strong>
<span class="tt1t1">
</span>
</div>
<ol class="lst1">
<li class="li1"><a class="a1"><span class="t1">
			JobTracker는 MapReduce 시스템의 마스터이고, TaskTracker는 워커 데몬이다.					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			TaskTracker는 JobTracker에게 3초에 한 번씩 주기적으로 하트비트(Heartbeat)를 보내 살아 있다는 것을 알린다.					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			데몬 관점에서 하둡은 2개의 구성요소를 가지고 있다.					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			네임노드(NameNode)와 데이터노드(DataNode)는 분산 파일 시스템의 데몬들이다.					</span></a></li>
</ol>
<div class="eg1">
<a class="b2 help" href="#m-help1a12" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
<span class="t1">정답보기</span>
<i class="ic1"></i>
</a>
</div>
<div class="tg2 loaded" id="m-help1a12" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
<strong class="tt1">정답</strong>
<div class="t2">
<i class="t2n">3</i>
<span class="t2t1">
			데몬 관점에서 하둡은 2개의 구성요소를 가지고 있다.			</span>
</div>
<br/>
<strong class="tt1">해설</strong>
<div class="t1">
		데몬 관점에서 하둡은 4개의 구성요소를 가지고 있다.				</div>


<div class="more-c">
<strong class="tt1">비기봇 해설</strong>
<div class="t1">
				정답은 3번입니다.<br/>
<br/>
Hadoop은 대규모 데이터 처리를 위한 분산 컴퓨팅 플랫폼으로, 여러 구성 요소가 협력하여 데이터를 처리합니다. 이 문제는 Hadoop의 아키텍처와 관련된 구성 요소의 역할과 기능에 대한 이해를 평가합니다.<br/>
<br/>
1. JobTracker는 MapReduce 시스템의 마스터이고, TaskTracker는 워커 데몬이다.<br/>
: JobTracker는 Hadoop의 MapReduce 작업을 관리하는 마스터 노드로, 작업을 분배하고 상태를 모니터링합니다. TaskTracker는 각 노드에서 실제 작업을 수행하는 워커 데몬입니다.<br/>
<br/>
2. TaskTracker는 JobTracker에게 3초에 한 번씩 주기적으로 하트비트(Heartbeat)를 보내 살아 있다는 것을 알린다.<br/>
: TaskTracker는 JobTracker와의 통신을 유지하기 위해 주기적으로 하트비트를 보내며, 이를 통해 자신의 상태를 알립니다.<br/>
<br/>
3. 데몬 관점에서 하둡은 2개의 구성요소를 가지고 있다.<br/>
: Hadoop은 여러 데몬으로 구성되며, 일반적으로 네임노드와 데이터노드, JobTracker와 TaskTracker 등 다양한 구성 요소가 있습니다. 따라서 두 개의 구성 요소만 있다는 설명은 잘못되었습니다.<br/>
<br/>
4. 네임노드(NameNode)와 데이터노드(DataNode)는 분산 파일 시스템의 데몬들이다.<br/>
: 네임노드와 데이터노드는 Hadoop의 분산 파일 시스템(HDFS)의 핵심 구성 요소로, 각각 메타데이터 관리와 실제 데이터 저장을 담당합니다.<br/>
<br/>
<br/>
선지 3은 Hadoop의 데몬 구성 요소에 대한 설명이 잘못되었습니다. Hadoop은 여러 데몬으로 구성되어 있으며, 두 개의 구성 요소만으로 설명할 수 없습니다. 다른 선택지들은 각각의 역할과 기능에 대한 설명이 정확합니다.<br/>
<br/>
따라서, 정답은 '3. 데몬 관점에서 하둡은 2개의 구성요소를 가지고 있다.' 입니다.<br/>
</div>
<div class="t2">
									#Hadoop									# JobTracker									# TaskTracker									# 네임노드									# 데이터노드							</div>
</div>

</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
<div class="sg1">
<div class="w1">
<span class="g1">2과목</span>
<span class="g1">분산 컴퓨팅 기술</span>
<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
</div>
</div>
<div class="tg1">
<strong class="tt1">
<span class="tt1n">13.</span>
<span class="tt1t1">
				SQL on Hadoop 기술에 대한 설명 중 옳지 않은 것은?							</span>
</strong>
<span class="tt1t1">
</span>
</div>
<ol class="lst1">
<li class="li1"><a class="a1"><span class="t1">
			하둡에 저장된 대용량 데이터를 대화형식의 SQL 질의를 통해서 처리하고 분석하는 기술이다.					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			임팔라는 하둡과 Hbase에 저장된 데이터를 대상으로 SQL 질의를 할 수 있다. 					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			호튼웍스에서 개발한 아파치 스팅거(Stinger)는 하이브 코드를 최대한 이용하여 성능을 개선하는 방식으로 개발되었다.					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			SQL on Hadoop 원조 기술은 구글에서 개발한 빅테이블이다.					</span></a></li>
</ol>
<div class="eg1">
<a class="b2 help" href="#m-help1a13" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
<span class="t1">정답보기</span>
<i class="ic1"></i>
</a>
</div>
<div class="tg2 loaded" id="m-help1a13" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
<strong class="tt1">정답</strong>
<div class="t2">
<i class="t2n">4</i>
<span class="t2t1">
			SQL on Hadoop 원조 기술은 구글에서 개발한 빅테이블이다.			</span>
</div>
<br/>
<strong class="tt1">해설</strong>
<div class="t1">
		구글의 빅테이블은 대표적인 NoSQL 기술이며, 클라우데라 임팔라가 SQL on Hadoop 기술 중 먼저 대중에게 공개된 기술이다.				</div>


<div class="more-c">
<strong class="tt1">비기봇 해설</strong>
<div class="t1">
				정답은 4번입니다.<br/>
<br/>
SQL on Hadoop 기술은 하둡에 저장된 대용량 데이터를 SQL 질의를 통해 처리하고 분석하는 기술입니다. 이 기술은 대용량 데이터 처리의 효율성을 높이기 위해 다양한 오픈 소스 프로젝트와 상용 솔루션이 개발되었습니다.<br/>
<br/>
1. 하둡에 저장된 대용량 데이터를 대화형식의 SQL 질의를 통해서 처리하고 분석하는 기술이다.<br/>
: 하둡에 저장된 데이터를 SQL 질의를 통해 처리하는 것은 SQL on Hadoop의 기본적인 기능입니다. 이는 대화형 SQL 질의를 통해 대용량 데이터를 효율적으로 분석할 수 있게 합니다.<br/>
<br/>
2. 임팔라는 하둡과 Hbase에 저장된 데이터를 대상으로 SQL 질의를 할 수 있다.<br/>
: 임팔라는 하둡과 HBase에 저장된 데이터를 대상으로 SQL 질의를 수행할 수 있는 기술로, 빠른 쿼리 성능을 제공하는 것이 특징입니다.<br/>
<br/>
3. 호튼웍스에서 개발한 아파치 스팅거(Stinger)는 하이브 코드를 최대한 이용하여 성능을 개선하는 방식으로 개발되었다.<br/>
: 아파치 스팅거는 하이브의 성능을 개선하기 위해 개발된 프로젝트로, 하이브의 기존 코드를 최대한 활용하여 성능을 향상시키는 것을 목표로 했습니다.<br/>
<br/>
4. SQL on Hadoop 원조 기술은 구글에서 개발한 빅테이블이다.<br/>
: 빅테이블은 구글에서 개발한 분산 데이터 저장 시스템으로, SQL on Hadoop의 원조 기술이라고 보기 어렵습니다. SQL on Hadoop은 주로 하둡 생태계 내에서 발전한 기술입니다.<br/>
<br/>
<br/>
빅테이블은 구글에서 개발한 기술로, SQL on Hadoop의 원조 기술이라고 할 수 없습니다. SQL on Hadoop은 하둡 생태계에서 발전한 기술로, 하둡에 저장된 데이터를 SQL로 처리하는 데 중점을 둡니다. 따라서 4번이 옳지 않은 설명입니다.<br/>
<br/>
따라서, 정답은 '4. SQL on Hadoop 원조 기술은 구글에서 개발한 빅테이블이다.' 입니다.<br/>
</div>
<div class="t2">
									#SQL on Hadoop									# 하둡									# 임팔라									# 아파치 스팅거									# 빅테이블							</div>
</div>

</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
<div class="sg1">
<div class="w1">
<span class="g1">2과목</span>
<span class="g1">분산 컴퓨팅 기술</span>
<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
</div>
</div>
<div class="tg1">
<strong class="tt1">
<span class="tt1n">14.</span>
<span class="tt1t1">
				다음 중 하둡의 성능과 관련된 설명으로 옳지 않은 것은?							</span>
</strong>
<span class="tt1t1">
</span>
</div>
<ol class="lst1">
<li class="li1"><a class="a1"><span class="t1">
			맵리듀스 작업에서 sort 작업은 데이터가 커지더라도 처리시간이 크게 증가하지 않는다. 					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			하둡 클러스터를 구성하는 서버의 수를 늘림으로써 처리시간을 줄일 수 있는 것은 아니다. 					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			플랫폼이 선형 확장성을 가지고 있다면 처리 속도를 개선할 수 있다.					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			맵리듀스의 sort는 map에서 reduce로 넘어가는 과정에서 항상 발생하는 프로세스이다.					</span></a></li>
</ol>
<div class="eg1">
<a class="b2 help" href="#m-help1a14" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
<span class="t1">정답보기</span>
<i class="ic1"></i>
</a>
</div>
<div class="tg2 loaded" id="m-help1a14" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
<strong class="tt1">정답</strong>
<div class="t2">
<i class="t2n">1</i>
<span class="t2t1">
			맵리듀스 작업에서 sort 작업은 데이터가 커지더라도 처리시간이 크게 증가하지 않는다. 			</span>
</div>
<br/>
<strong class="tt1">해설</strong>
<div class="t1">
		sort 작업은 데이터가 커질수록 처리 시간이 선형적으로 증가한다.				</div>


<div class="more-c">
<strong class="tt1">비기봇 해설</strong>
<div class="t1">
				정답은 1번입니다.<br/>
<br/>
하둡은 대용량 데이터를 분산 처리하기 위한 오픈 소스 프레임워크로, 주로 MapReduce 프로그래밍 모델을 사용합니다. 하둡의 성능은 데이터 처리의 효율성과 확장성에 크게 의존합니다. <br/>
<br/>
1. 맵리듀스 작업에서 sort 작업은 데이터가 커지더라도 처리시간이 크게 증가하지 않는다. <br/>
: MapReduce 작업에서 Sort는 데이터가 커질수록 처리 시간이 선형적으로 증가합니다. 이는 데이터의 양이 많아질수록 정렬에 필요한 시간이 비례적으로 늘어난다는 것을 의미합니다. 따라서, 데이터가 커지더라도 처리 시간이 크게 증가하지 않는다는 설명은 잘못된 것입니다.<br/>
<br/>
2. 하둡 클러스터를 구성하는 서버의 수를 늘림으로써 처리시간을 줄일 수 있는 것은 아니다. <br/>
: 하둡 클러스터의 서버 수를 늘리는 것만으로는 처리 시간을 줄일 수 없습니다. 이는 하둡이 선형 확장성을 가져야만 클러스터 확장이 성능 향상으로 이어질 수 있기 때문입니다. 따라서, 서버 수 증가만으로 성능 향상이 보장되지 않는다는 설명은 옳습니다.<br/>
<br/>
3. 플랫폼이 선형 확장성을 가지고 있다면 처리 속도를 개선할 수 있다. <br/>
: 플랫폼이 선형 확장성을 가지면, 클러스터의 크기를 늘릴 때 성능이 비례적으로 향상됩니다. 이는 하둡의 성능을 개선하는 중요한 요소로, 선형 확장성을 통해 처리 속도를 개선할 수 있습니다. 따라서, 이 설명은 옳습니다.<br/>
<br/>
4. 맵리듀스의 sort는 map에서 reduce로 넘어가는 과정에서 항상 발생하는 프로세스이다. <br/>
: MapReduce의 Sort는 Map 단계에서 Reduce 단계로 넘어가는 과정에서 항상 발생하는 필수적인 프로세스입니다. 이는 데이터의 정렬이 MapReduce 작업의 핵심 과정 중 하나임을 의미합니다. 따라서, 이 설명은 옳습니다.<br/>
<br/>
MapReduce 작업에서 Sort는 데이터가 커질수록 처리 시간이 선형적으로 증가하기 때문에, '처리 시간이 크게 증가하지 않는다'는 설명은 잘못되었습니다. 나머지 선지들은 하둡의 성능과 확장성에 대한 올바른 설명을 포함하고 있습니다.<br/>
<br/>
따라서, 정답은 '1. 맵리듀스 작업에서 sort 작업은 데이터가 커지더라도 처리시간이 크게 증가하지 않는다.' 입니다.<br/>
</div>
<div class="t2">
									#하둡									# MapReduce									# Sort									# 선형 확장성									# 클러스터									# 데이터 처리							</div>
</div>

</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
<div class="sg1">
<div class="w1">
<span class="g1">2과목</span>
<span class="g1">분산 컴퓨팅 기술</span>
<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
</div>
</div>
<div class="tg1">
<strong class="tt1">
<span class="tt1n">15.</span>
<span class="tt1t1">
				병렬 쿼리 시스템 중 하나인 아파치 Pig에 대한 설명으로 옳은 것은?							</span>
</strong>
<span class="tt1t1">
</span>
</div>
<ol class="lst1">
<li class="li1"><a class="a1"><span class="t1">
			야후에서 개발한 데이터 저장을 위한 언어이며, 아직 오픈소스 프로젝트화되지 않았다. 					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			Hadoop MapReduce 위에서 동작하는 구체화된 병렬 처리 언어이다.					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			Pig는 맵리듀스의 중복된 알고리즘 개발, 코드 공유의 어려움 등의 요구사항을 해결하기 위해 정의된 언어이다.					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			아파치 Pig를 이용하면 MapReduce를 이용할 때 보다 프로그래밍해야 할 코드 라인의 수는 줄지 않지만 데이터 처리 속도가 매우 빨라진다.					</span></a></li>
</ol>
<div class="eg1">
<a class="b2 help" href="#m-help1a15" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
<span class="t1">정답보기</span>
<i class="ic1"></i>
</a>
</div>
<div class="tg2 loaded" id="m-help1a15" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
<strong class="tt1">정답</strong>
<div class="t2">
<i class="t2n">3</i>
<span class="t2t1">
			Pig는 맵리듀스의 중복된 알고리즘 개발, 코드 공유의 어려움 등의 요구사항을 해결하기 위해 정의된 언어이다.			</span>
</div>
<br/>
<strong class="tt1">해설</strong>
<div class="t1">
		아파치 Pig는 야후에서 개발해 오픈소스 프로젝트화한 데이터 처리를 위한 고차원 언어로, Hadoop MapReduce 위에서 동작하는 추상화된 병렬 처리 언어이다. 아파치 Pig는 프로그래밍해야 할 코드 라인의 수를 획기적으로 줄여준다.				</div>


<div class="more-c">
<strong class="tt1">비기봇 해설</strong>
<div class="t1">
				정답은 3번입니다.<br/>
<br/>
아파치 Pig는 야후에서 개발한 오픈소스 프로젝트로, 대용량 데이터 처리를 위한 고차원 언어입니다. Pig는 Hadoop MapReduce 위에서 동작하는 추상화된 병렬 처리 언어로, MapReduce의 복잡한 코딩을 간소화하여 개발자들이 더 쉽게 병렬 처리를 구현할 수 있도록 돕습니다. Pig는 특히 MapReduce의 중복된 알고리즘 개발과 코드 공유의 어려움을 해결하기 위해 설계되었습니다. Pig를 사용하면 MapReduce를 직접 코딩하는 것보다 코드 라인의 수를 줄일 수 있으며, 이는 개발 생산성을 높이는 데 기여합니다.<br/>
<br/>
1. 야후에서 개발한 데이터 저장을 위한 언어이며, 아직 오픈소스 프로젝트화되지 않았다. <br/>
: 아파치 Pig는 야후에서 개발한 것이 맞지만, 이미 오픈소스 프로젝트로 공개되어 있습니다. 따라서 '아직 오픈소스 프로젝트화되지 않았다'는 부분이 틀렸습니다.<br/>
<br/>
2. Hadoop MapReduce 위에서 동작하는 구체화된 병렬 처리 언어이다. <br/>
: Pig는 Hadoop MapReduce 위에서 동작하는 추상화된 병렬 처리 언어입니다. 이는 Pig가 MapReduce의 복잡성을 줄이고, 개발자들이 더 쉽게 병렬 처리를 구현할 수 있도록 돕는다는 것을 의미합니다. 따라서 이 설명은 맞습니다.<br/>
<br/>
3. Pig는 맵리듀스의 중복된 알고리즘 개발, 코드 공유의 어려움 등의 요구사항을 해결하기 위해 정의된 언어이다. <br/>
: Pig는 MapReduce의 중복된 알고리즘 개발과 코드 공유의 어려움을 해결하기 위해 정의된 언어입니다. 이는 Pig의 개발 배경과 목적을 정확히 설명하고 있습니다.<br/>
<br/>
4. 아파치 Pig를 이용하면 MapReduce를 이용할 때 보다 프로그래밍해야 할 코드 라인의 수는 줄지 않지만 데이터 처리 속도가 매우 빨라진다. <br/>
: Pig를 사용하면 MapReduce를 직접 코딩하는 것보다 프로그래밍해야 할 코드 라인의 수가 줄어듭니다. 따라서 '코드 라인의 수는 줄지 않지만'이라는 부분이 틀렸습니다.<br/>
<br/>
정답은 3번입니다. Pig는 MapReduce의 중복된 알고리즘 개발과 코드 공유의 어려움을 해결하기 위해 정의된 언어로, 이는 Pig의 개발 목적과 일치합니다. 1번은 Pig가 이미 오픈소스 프로젝트로 공개되어 있다는 점에서 틀렸고, 2번은 Pig의 동작 원리를 정확히 설명하고 있어 맞습니다. 4번은 Pig를 사용하면 코드 라인의 수가 줄어든다는 점에서 틀렸습니다.<br/>
따라서, 정답은 '3. Pig는 맵리듀스의 중복된 알고리즘 개발, 코드 공유의 어려움 등의 요구사항을 해결하기 위해 정의된 언어이다.' 입니다.<br/>
</div>
<div class="t2">
									#아파치 Pig									# Hadoop MapReduce									# 병렬 처리									# 오픈소스									# 코드 간소화							</div>
</div>

</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
<div class="sg1">
<div class="w1">
<span class="g1">2과목</span>
<span class="g1">클라우드 인프라 기술</span>
<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
</div>
</div>
<div class="tg1">
<strong class="tt1">
<span class="tt1n">16.</span>
<span class="tt1t1">
				클라우드 컴퓨팅의 기반이 되는 인프라 기술인 가상화에 대한 설명 중 옳지 않은 것은?							</span>
</strong>
<span class="tt1t1">
</span>
</div>
<ol class="lst1">
<li class="li1"><a class="a1"><span class="t1">
			최근에는 CPU 제조업체에서도 하드웨어에서 가상화 기술을 지원하는 등 새로운 가상화 방법이 계속 나오고 있기 때문에 서버 가상화 기술을 정확하게 분류하기는 힘들다.					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			컨테이너 기반 가상화 방식에서 가상화를 지원하는 계층을 하이퍼바이저라고 한다. 					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			서버 가상화는 물리적인 서버와 운영체제 사이에 적절한 계층을 추가해 서버를 사용하는 사용자에게 물리적인 자원은 숨기고 논리적인 자원만을 보여주는 기술이다.					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			완전가상화는 어떠한 운영 체제라도 수정하지 않은 채 설치가 가능하다.					</span></a></li>
</ol>
<div class="eg1">
<a class="b2 help" href="#m-help1a16" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
<span class="t1">정답보기</span>
<i class="ic1"></i>
</a>
</div>
<div class="tg2 loaded" id="m-help1a16" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
<strong class="tt1">정답</strong>
<div class="t2">
<i class="t2n">2</i>
<span class="t2t1">
			컨테이너 기반 가상화 방식에서 가상화를 지원하는 계층을 하이퍼바이저라고 한다. 			</span>
</div>
<br/>
<strong class="tt1">해설</strong>
<div class="t1">
		컨테이너 기반 가상화 방식에서 가상화를 지원하는 계층은 가상 운영환경(Virtual server environment)이라고 부른다.				</div>


<div class="more-c">
<strong class="tt1">비기봇 해설</strong>
<div class="t1">
				정답은 2번입니다.<br/>
<br/>
가상화는 물리적 하드웨어 자원을 추상화하여 여러 가상 시스템을 생성하고 관리하는 기술입니다. 이는 클라우드 컴퓨팅의 핵심 기술로, 자원의 효율적인 사용과 유연한 관리가 가능합니다.<br/>
<br/>
1. 최근에는 CPU 제조업체에서도 하드웨어에서 가상화 기술을 지원하는 등 새로운 가상화 방법이 계속 나오고 있기 때문에 서버 가상화 기술을 정확하게 분류하기는 힘들다.<br/>
: CPU 제조업체들이 하드웨어 수준에서 가상화 기술을 지원함으로써, 가상화 기술은 계속 발전하고 있으며, 다양한 방법으로 분류될 수 있습니다.<br/>
<br/>
2. 컨테이너 기반 가상화 방식에서 가상화를 지원하는 계층을 하이퍼바이저라고 한다.<br/>
: 컨테이너 기반 가상화는 운영체제 수준에서 가상화를 지원하며, 하이퍼바이저는 주로 하드웨어 가상화에서 사용되는 계층입니다. 따라서 컨테이너 기반 가상화에서 하이퍼바이저라는 용어는 적절하지 않습니다.<br/>
<br/>
3. 서버 가상화는 물리적인 서버와 운영체제 사이에 적절한 계층을 추가해 서버를 사용하는 사용자에게 물리적인 자원은 숨기고 논리적인 자원만을 보여주는 기술이다.<br/>
: 서버 가상화는 물리적 서버와 운영체제 사이에 가상화 계층을 추가하여 사용자에게 물리적 자원을 숨기고 논리적 자원만을 제공하는 기술입니다.<br/>
<br/>
4. 완전가상화는 어떠한 운영 체제라도 수정하지 않은 채 설치가 가능하다.<br/>
: 완전가상화는 운영체제를 수정하지 않고도 설치할 수 있는 가상화 방식으로, 하드웨어 가상화 지원이 필요합니다.<br/>
<br/>
<br/>
컨테이너 기반 가상화는 운영체제 수준에서 가상화를 지원하며, 하이퍼바이저는 주로 하드웨어 가상화에서 사용되는 용어입니다. 따라서 2번 선택지가 옳지 않은 설명입니다. 다른 선택지들은 각각의 가상화 기술에 대한 올바른 설명을 제공하고 있습니다.<br/>
<br/>
따라서, 정답은 '2. 컨테이너 기반 가상화 방식에서 가상화를 지원하는 계층을 하이퍼바이저라고 한다.' 입니다.<br/>
</div>
<div class="t2">
									#가상화									# 하이퍼바이저									# 컨테이너									# 서버 가상화							</div>
</div>

</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
<div class="sg1">
<div class="w1">
<span class="g1">2과목</span>
<span class="g1">클라우드 인프라 기술</span>
<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
</div>
</div>
<div class="tg1">
<strong class="tt1">
<span class="tt1n">17.</span>
<span class="tt1t1">
				하이퍼바이저 기반의 가상화와 컨테이너 기반 가상화를 비교한 다음의 내용 중 옳지 않은 것은?							</span>
</strong>
<span class="tt1t1">
</span>
</div>
<ol class="lst1">
<li class="li1"><a class="a1"><span class="t1">
			하이퍼바이저 기반 가상화는 가상머신 내에서 완전한 하드웨어 독립성을 가지며, 컨테이너 기반 가상화는 호스트 OS를 사용한다.					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			하이퍼바이저 기반 가상화는 높은 오버헤드를 발생시키는 반면, 컨테이너 기반 가상화는 오버헤드가 거의 없다.					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			컨테이너 기반 가상화는 공통 소프트웨어에 의한 중앙 집중식 관리 구조를 가지며, 하이퍼 바이저 기반 가상화는 가상머신별로 별도로 관리되는 구조를 가진다.					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			Xen과 VMware ESX는 컨테이너 기반 가상화의 대표 제품이다.					</span></a></li>
</ol>
<div class="eg1">
<a class="b2 help" href="#m-help1a17" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
<span class="t1">정답보기</span>
<i class="ic1"></i>
</a>
</div>
<div class="tg2 loaded" id="m-help1a17" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
<strong class="tt1">정답</strong>
<div class="t2">
<i class="t2n">4</i>
<span class="t2t1">
			Xen과 VMware ESX는 컨테이너 기반 가상화의 대표 제품이다.			</span>
</div>
<br/>
<strong class="tt1">해설</strong>
<div class="t1">
		Xen과 VMware ESX는 하이퍼바이저 기반 가상화의 대표 제품이다.				</div>


<div class="more-c">
<strong class="tt1">비기봇 해설</strong>
<div class="t1">
				정답은 4번입니다.<br/>
<br/>
이 문제는 하이퍼바이저 기반 가상화와 컨테이너 기반 가상화의 차이점을 이해하는 것이 핵심입니다. 하이퍼바이저 기반 가상화는 가상머신(VM)을 생성하여 각 VM이 독립적인 운영체제를 실행할 수 있도록 하며, 하드웨어 자원을 가상화합니다. 반면, 컨테이너 기반 가상화는 호스트 운영체제의 커널을 공유하여 애플리케이션을 격리된 환경에서 실행합니다.<br/>
<br/>
1. 하이퍼바이저 기반 가상화는 가상머신 내에서 완전한 하드웨어 독립성을 가지며, 컨테이너 기반 가상화는 호스트 OS를 사용한다.<br/>
: 하이퍼바이저 기반 가상화는 각 가상머신이 독립적인 하드웨어 환경을 가지며, 컨테이너는 호스트 OS의 커널을 공유하여 실행됩니다.<br/>
<br/>
2. 하이퍼바이저 기반 가상화는 높은 오버헤드를 발생시키는 반면, 컨테이너 기반 가상화는 오버헤드가 거의 없다.<br/>
: 하이퍼바이저 기반 가상화는 가상머신을 생성하고 관리하는 데 있어 오버헤드가 발생할 수 있지만, 컨테이너는 경량화되어 있어 오버헤드가 적습니다.<br/>
<br/>
3. 컨테이너 기반 가상화는 공통 소프트웨어에 의한 중앙 집중식 관리 구조를 가지며, 하이퍼 바이저 기반 가상화는 가상머신별로 별도로 관리되는 구조를 가진다.<br/>
: 컨테이너는 공통의 운영체제 커널을 사용하여 중앙 집중식으로 관리되며, 하이퍼바이저 기반 가상화는 각 가상머신이 독립적으로 관리됩니다.<br/>
<br/>
4. Xen과 VMware ESX는 컨테이너 기반 가상화의 대표 제품이다.<br/>
: Xen과 VMware ESX는 하이퍼바이저 기반 가상화의 대표적인 제품입니다. 컨테이너 기반 가상화의 대표적인 제품은 Docker입니다.<br/>
<br/>
<br/>
선지 4는 Xen과 VMware ESX를 컨테이너 기반 가상화의 제품으로 잘못 설명하고 있습니다. 이들은 하이퍼바이저 기반 가상화의 대표적인 제품입니다. 나머지 선지들은 하이퍼바이저와 컨테이너 기반 가상화의 차이점을 올바르게 설명하고 있습니다.<br/>
<br/>
따라서, 정답은 '4. Xen과 VMware ESX는 컨테이너 기반 가상화의 대표 제품이다.' 입니다.<br/>
</div>
<div class="t2">
									#하이퍼바이저									# 가상머신									# 컨테이너									# 오버헤드							</div>
</div>

</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
<div class="sg1">
<div class="w1">
<span class="g1">2과목</span>
<span class="g1">분산 데이터 저장 기술</span>
<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
</div>
</div>
<div class="tg1">
<strong class="tt1">
<span class="tt1n">18.</span>
<span class="tt1t1">
				다음 중 MySQL에 관한 설명으로 옳지 않은 것은?							</span>
</strong>
<span class="tt1t1">
</span>
</div>
<ol class="lst1">
<li class="li1"><a class="a1"><span class="t1">
			장애가 발생했던 노드가 복구되어 클러스터에 투입된 경우에도 기존 데이터와 변경된 데이터에 대한 동기화 작업이 자동으로 수행된다.					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			MySQL의 구성요소 중 MySQL 노드는 클러스터를 관리하는 노드로 클러스터 시작과 재구성 시에만 관여한다.					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			클러스터에 참여하는 노드(SQL 노드, 데이터 노드, 매니저를 포함) 수는 255로 제한되며, 데이터 노드는 최대 48개까지만 가능하다.					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			MySQL 클러스터는 비공유형으로서 메모리 기반 데이터베이스의 클러스터링을 지원한다.					</span></a></li>
</ol>
<div class="eg1">
<a class="b2 help" href="#m-help1a18" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
<span class="t1">정답보기</span>
<i class="ic1"></i>
</a>
</div>
<div class="tg2 loaded" id="m-help1a18" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
<strong class="tt1">정답</strong>
<div class="t2">
<i class="t2n">2</i>
<span class="t2t1">
			MySQL의 구성요소 중 MySQL 노드는 클러스터를 관리하는 노드로 클러스터 시작과 재구성 시에만 관여한다.			</span>
</div>
<br/>
<strong class="tt1">해설</strong>
<div class="t1">
		②번은 관리 노드에 해당하는 설명이며, MySQL 노드는 클러스터 데이터에 접근을 지원하는 노드이다.				</div>


<div class="more-c">
<strong class="tt1">비기봇 해설</strong>
<div class="t1">
				정답은 2번입니다.<br/>
<br/>
MySQL 클러스터는 비공유형 구조로, 메모리 기반 데이터베이스의 클러스터링을 지원합니다. 이는 특정 하드웨어나 소프트웨어에 의존하지 않고 병렬 서버 구조로 확장이 가능하다는 장점이 있습니다. MySQL 클러스터는 관리 노드, 데이터 노드, MySQL 노드로 구성되며, 각각 클러스터 관리, 데이터 저장, 데이터 접근을 담당합니다. 장애가 발생한 노드가 복구되면 자동으로 데이터 동기화가 이루어지며, 클러스터에 참여하는 노드 수는 255로 제한되며, 데이터 노드는 최대 48개까지 가능합니다.<br/>
<br/>
1. 장애가 발생했던 노드가 복구되어 클러스터에 투입된 경우에도 기존 데이터와 변경된 데이터에 대한 동기화 작업이 자동으로 수행된다. <br/>
: MySQL 클러스터는 장애가 발생한 노드가 복구되었을 때 자동으로 기존 데이터와 변경된 데이터의 동기화 작업을 수행합니다. 이는 클러스터의 데이터 가용성을 높이기 위한 중요한 기능으로, 데이터 노드 간의 네트워크를 통해 동기화가 이루어집니다.<br/>
<br/>
2. MySQL의 구성요소 중 MySQL 노드는 클러스터를 관리하는 노드로 클러스터 시작과 재구성 시에만 관여한다. <br/>
: MySQL의 관리 노드는 클러스터를 관리하는 역할을 하며, 클러스터의 시작과 재구성 시에만 관여합니다. 이는 클러스터의 안정적인 운영을 위해 필수적인 역할로, 클러스터의 상태를 모니터링하고 필요 시 재구성을 지원합니다.<br/>
<br/>
3. 클러스터에 참여하는 노드(SQL 노드, 데이터 노드, 매니저를 포함) 수는 255로 제한되며, 데이터 노드는 최대 48개까지만 가능하다. <br/>
: MySQL 클러스터에 참여할 수 있는 노드의 수는 255로 제한되며, 데이터 노드는 최대 48개까지 가능합니다. 이는 클러스터의 확장성을 고려한 제한으로, 노드의 수가 많아질수록 관리의 복잡성이 증가할 수 있습니다.<br/>
<br/>
4. MySQL 클러스터는 비공유형으로서 메모리 기반 데이터베이스의 클러스터링을 지원한다. <br/>
: MySQL 클러스터는 비공유형 구조로, 메모리 기반 데이터베이스의 클러스터링을 지원합니다. 이는 데이터의 빠른 접근과 처리를 가능하게 하며, 최근에는 디스크 기반 클러스터링도 지원하여 데이터 저장의 유연성을 제공합니다.<br/>
<br/>
선지 2는 MySQL 노드에 대한 설명이 잘못되었습니다. MySQL 노드는 클러스터 데이터에 접근을 지원하는 노드로, 클러스터 시작과 재구성 시에만 관여하는 것은 관리 노드의 역할입니다. 나머지 선지들은 MySQL 클러스터의 특징과 제한 사항을 정확히 설명하고 있습니다.<br/>
따라서, 정답은 '2. MySQL의 구성요소 중 MySQL 노드는 클러스터를 관리하는 노드로 클러스터 시작과 재구성 시에만 관여한다.' 입니다.<br/>
</div>
<div class="t2">
									#MySQL 클러스터									# 비공유형									# 데이터 동기화									# 관리 노드									# 데이터 노드									# 노드 제한							</div>
</div>

</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
<div class="sg1">
<div class="w1">
<span class="g1">2과목</span>
<span class="g1">분산 컴퓨팅 기술</span>
<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
</div>
</div>
<div class="tg1">
<strong class="tt1">
<span class="tt1n">19.</span>
<span class="tt1t1">
				호스트 컴퓨터에서 다수의 운영 체제를 동시에 실행하기 위한 논리적 플랫폼인 하이퍼바이저(Hypervisor)에 대한 설명으로 옳지 않은 것은?							</span>
</strong>
<span class="tt1t1">
</span>
</div>
<ol class="lst1">
<li class="li1"><a class="a1"><span class="t1">
			일반적으로 가상머신(Virtual machine)을 하이퍼바이저라고 할 수 있다.					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			물리적 서버 위에 존재하는 가상화 레이어를 통해 운영체제를 수행하는데 필요한 하드웨어 환경을 가상으로 만들어 준다.					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			하이퍼바이저를 통해 사용자는 추가 하드웨어 구입 없이 새로운 운영체제의 설치, 애플리케이션의 테스팅 및 업그레이드를 동일한 물리적 서버에서 동시에 수행할 수 있다.					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			하이퍼바이저는 하드웨어 환경 에뮬레이션(emulation)을 수행하지만 소프트웨어 스택 보존의 기능은 수행하지 못한다.					</span></a></li>
</ol>
<div class="eg1">
<a class="b2 help" href="#m-help1a19" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
<span class="t1">정답보기</span>
<i class="ic1"></i>
</a>
</div>
<div class="tg2 loaded" id="m-help1a19" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
<strong class="tt1">정답</strong>
<div class="t2">
<i class="t2n">4</i>
<span class="t2t1">
			하이퍼바이저는 하드웨어 환경 에뮬레이션(emulation)을 수행하지만 소프트웨어 스택 보존의 기능은 수행하지 못한다.			</span>
</div>
<br/>
<strong class="tt1">해설</strong>
<div class="t1">
		하이퍼바이저는 하드웨어 환경 에뮬레이션, 실행환경 격리, 시스템 자원 할당, 소프트웨어 스택 보존 등의 기능을 수행한다.				</div>


<div class="more-c">
<strong class="tt1">비기봇 해설</strong>
<div class="t1">
				1. 하이퍼바이저와 가상머신을 엄격하게 구분할 경우에는 차이가 있지만 일반적으로 가상머신(Virtual Machine)을 하이퍼바이저라고 할 수 있으며, 하이퍼바이저는 VMM(Virtual Machine Monitor)이라고도 한다.<br/>
<br/>
2. 하이퍼바이저는 물리적 하드웨어 위에 가상화 레이어를 제공하여, 운영 체제가 필요한 가상 하드웨어 환경을 만들어 줍니다. 이를 통해 여러 운영 체제가 동시에 실행될 수 있습니다. 이 설명은 적절합니다.<br/>
<br/>
3. 하이퍼바이저는 단일 물리적 서버에서 여러 가상 머신을 실행할 수 있게 하여, 추가 하드웨어 없이 여러 운영 체제를 설치하고 애플리케이션을 테스트할 수 있도록 합니다. 이 설명은 적절합니다.<br/>
<br/>
4. 하이퍼바이저는 가상 머신이 운영 체제 및 애플리케이션을 실행할 수 있는 하드웨어 환경을 에뮬레이션하며, 가상 머신 내의 소프트웨어 스택을 보존하고 관리할 수 있습니다. 하이퍼바이저는 운영 체제와 애플리케이션의 실행 상태를 유지하고, 소프트웨어 스택을 보존하는 기능도 수행합니다. 이 설명은 부적절합니다.<br/>
</div>
<div class="t2">
									# 하이퍼바이저									# 가상머신							</div>
</div>

</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
<div class="sg1">
<div class="w1">
<span class="g1">2과목</span>
<span class="g1">분산 데이터 저장 기술</span>
<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
</div>
</div>
<div class="tg1">
<strong class="tt1">
<span class="tt1n">20.</span>
<span class="tt1t1">
				다음의 데이터베이스 클러스터에 대한 설명 중 옳지 않은 설명은 무엇인가?							</span>
</strong>
<span class="tt1t1">
</span>
</div>
<ol class="lst1">
<li class="li1"><a class="a1"><span class="t1">
			Oracle RAC 데이터베이스 서버는 공유 클러스터이며, 별도의 폴트톨러런스 기능은 제공하지 않는다.					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			데이터베이스 파티셔닝을 구현하면 성능의 선형적인 증가 효과를 볼 수 있다.					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			MS SQL Server는 연합 데이터베이스 형태이며, Active-Standby 방법의 페일오버(failover) 메커니즘을 제공한다.					</span></a></li>
<li class="li1"><a class="a1"><span class="t1">
			Oracle RAC 데이터베이스 서버에서 클러스터가 커지면 디스크 영역의 병목현상이 발생할 수도 있다.					</span></a></li>
</ol>
<div class="eg1">
<a class="b2 help" href="#m-help1a20" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
<span class="t1">정답보기</span>
<i class="ic1"></i>
</a>
</div>
<div class="tg2 loaded" id="m-help1a20" style="display: none;"> <!-- m-help1a1, m-help1a2, … -->
<strong class="tt1">정답</strong>
<div class="t2">
<i class="t2n">1</i>
<span class="t2t1">
			Oracle RAC 데이터베이스 서버는 공유 클러스터이며, 별도의 폴트톨러런스 기능은 제공하지 않는다.			</span>
</div>
<br/>
<strong class="tt1">해설</strong>
<div class="t1">
		Oracle RAC 데이터베이스 서버는 높은 수준의 폴트톨러런스를 제공하므로 클러스터를 구성하는 노드 중 하나의 노드만 살아있어도 서비스가 가능하다.				</div>


<div class="more-c">
<strong class="tt1">비기봇 해설</strong>
<div class="t1">
				1. Oracle RAC (Real Application Clusters)는 공유 디스크 클러스터링을 사용하며, 높은 가용성을 제공하기 위해 폴트톨러런스 기능을 포함하고 있습니다. 각 노드가 장애를 감지하고, 다른 노드로 페일오버를 수행하여 서비스 중단을 최소화합니다.<br/>
<br/>
2. 데이터베이스 파티셔닝은 데이터를 여러 파티션으로 분할하여 성능을 개선하고, 쿼리 성능을 최적화하며, 관리 효율성을 높이는 데 도움이 됩니다. 적절히 구현되면 성능이 선형적으로 증가할 수 있습니다.<br/>
<br/>
3. MS SQL Server는 연합 데이터베이스 형태를 지원하며, AlwaysOn 가용성 그룹과 같은 Active-Standby 페일오버 메커니즘을 제공하여 고가용성을 보장합니다.<br/>
<br/>
4. Oracle RAC 클러스터에서 노드 수가 증가하면, 공유 디스크의 I/O 성능이 병목현상이 될 수 있습니다. 이를 해결하기 위해서는 고성능 스토리지 시스템과 최적화된 디스크 구성 전략이 필요합니다.<br/>
</div>
<div class="t2">
									#데이터베이스 클러스터									# Oracle RAC									# 파티셔닝									# MS SQL Server							</div>
</div>

</div>
</div>
<!-- /cp1question1 -->





<script>
/* === AUTO-PATCH: answer-toggle-v2 === */
(function () {
  function qsa(sel, root) { return Array.from((root || document).querySelectorAll(sel)); }
  function qs(sel, root) { return (root || document).querySelector(sel); }

  function getPanelFromBtn(btn) {
    const href = btn && btn.getAttribute('href');
    if (!href || !href.startsWith('#')) return null;
    return document.querySelector(href);
  }

  function setHelpLabel(btn, open) {
    const t = btn ? btn.querySelector('.t1') : null;
    if (t) t.textContent = open ? '정답닫기' : '정답보기';
    if (btn) btn.setAttribute('aria-expanded', String(open));
  }

  function panelIsOpen(panel) {
    if (!panel) return false;
    if (panel.style.display) return panel.style.display !== 'none';
    return getComputedStyle(panel).display !== 'none';
  }

  function openPanel(btn, panel) {
    if (!panel) return;
    panel.style.display = 'block';
    panel.classList.add('loaded');     // 기존 테마 연동
    setHelpLabel(btn, true);
  }

  function closePanel(btn, panel) {
    if (!panel) return;
    panel.style.display = 'none';
    setHelpLabel(btn, false);
  }

  // ✅ 전체 정답 보기/닫기
  window.controlAllAnswers = function (show) {
    qsa('.tg2').forEach(panel => {
      panel.style.display = show ? 'block' : 'none';
      if (show) panel.classList.add('loaded');
    });
    qsa('a.b2.help').forEach(btn => setHelpLabel(btn, show));
  };

  // ✅ 개별 정답보기 토글 (이게 없으면 "클릭해도 아무 동작 없음")
  function onHelpClick(e) {
    const btn = e.target.closest('a.b2.help[href^="#"]');
    if (!btn) return;
    e.preventDefault();

    const panel = getPanelFromBtn(btn);
    if (!panel) return;

    panelIsOpen(panel) ? closePanel(btn, panel) : openPanel(btn, panel);
  }

  // ✅ 보기 클릭 → 정오답 판정 + s1/s2 적용 + 자동 정답보기
  function onOptionPick(e) {
    const li = e.target.closest('.cp1question1 .lst1 .li1');
    if (!li) return;

    const qBox = li.closest('.cp1question1');
    if (!qBox) return;

    const btn = qs('a.b2.help[href^="#"]', qBox);
    const panel = getPanelFromBtn(btn);

    // 정답 번호(i.t2n)는 해설 패널 안에 있음(1-based)
    const n = panel ? panel.querySelector('i.t2n') : null;
    const correctIdx = n ? parseInt((n.textContent || '').trim(), 10) : NaN;

    const options = qsa('.lst1 .li1', qBox);
    const idx = options.indexOf(li) + 1; // 1-based

    if (!Number.isFinite(correctIdx) || correctIdx <= 0) return;

    const isCorrect = idx === correctIdx;
    qBox.setAttribute('data-answer-state', isCorrect ? 'correct' : 'wrong');

    // 헤더 표시 (정답 s1 | 오답 s2)
    const b = qs('.w1 b', qBox);
    if (b) b.className = isCorrect ? 's1' : 's2';

    // 보기에도 클래스 부여(원하면 CSS로 강조)
    options.forEach((opt, i) => {
      opt.classList.remove('is-correct', 'is-wrong');
      if (i + 1 === correctIdx) opt.classList.add('is-correct');
    });
    li.classList.add(isCorrect ? 'is-correct' : 'is-wrong');

    // 자동 정답보기
    openPanel(btn, panel);
  }

  // capture로 등록: 다른 스크립트가 click을 막아도 최대한 동작
  document.addEventListener('click', onHelpClick, true);
  document.addEventListener('click', onOptionPick, true);
})();
</script>

<!-- AUTO:score-counter start -->
<script>
(function () {
  function qsa(sel, root) { return Array.from((root || document).querySelectorAll(sel)); }
  function qs(sel, root) { return (root || document).querySelector(sel); }

  function setText(el, n) {
    if (!el) return;
    el.textContent = String(n) + '개';
  }

  function updateTotal(total) {
    const block = qs('.cp1dlist2');
    if (!block) return;
    qsa('.cp1dlist2 .di1', block).forEach(li => {
      const label = (qs('.dt1', li)?.textContent || '').trim();
      if (label === '총 문제') {
        const dd = qs('.dd1', li);
        if (dd) dd.textContent = String(total) + '개';
      }
    });
  }

  function getPanelFromQ(qBox) {
    const btn = qBox.querySelector('a.b2.help[href^="#"]');
    if (!btn) return null;
    const href = btn.getAttribute('href');
    if (!href || !href.startsWith('#')) return null;
    return document.querySelector(href);
  }

  function getCorrectIndex(panel) {
    const n = panel ? panel.querySelector('i.t2n') : null;
    if (!n) return null;
    const v = parseInt((n.textContent || '').trim(), 10);
    return Number.isFinite(v) ? v : null; // 1-based
  }

  function recompute() {
    const total = qsa('.cp1question1').length;
    let correct = 0;
    let wrong = 0;

    qsa('.cp1question1').forEach(qBox => {
      const state = qBox.getAttribute('data-answer-state');
      if (state === 'correct') correct += 1;
      else if (state === 'wrong') wrong += 1;
    });

    const unanswered = Math.max(0, total - (correct + wrong));

    updateTotal(total);
    setText(qs('.cp1dlist2 .em1'), correct);
    setText(qs('.cp1dlist2 .em2'), wrong);
    setText(qs('.cp1dlist2 .em3'), unanswered);
  }

  function handle(e) {
    const li = e.target.closest('.cp1question1 .lst1 .li1');
    if (!li) return;

    const qBox = li.closest('.cp1question1');
    if (!qBox) return;

    const options = qsa('.lst1 .li1', qBox);
    const idx = options.indexOf(li) + 1; // 1-based
    if (idx <= 0) return;

    const panel = getPanelFromQ(qBox);
    const correctIdx = getCorrectIndex(panel);
    if (!correctIdx) {
      qBox.removeAttribute('data-answer-state');
      recompute();
      return;
    }

    qBox.setAttribute('data-answer-state', (idx === correctIdx) ? 'correct' : 'wrong');
    recompute();
  }

  // click이 막혀도 동작하도록 pointerup도 함께 수신(충돌 방어)
  document.addEventListener('click', handle, true);
  document.addEventListener('pointerup', handle, true);

  function init() { recompute(); }
  if (document.readyState === 'loading') document.addEventListener('DOMContentLoaded', init);
  else init();
})();
</script>
<!-- AUTO:score-counter end -->

</body>
</html>
